Merged few patches into one patch and fixed for Waterfox
Original authors of patch for Firefox:
Wolfgang Rosenauer <wolfgang@rosenauer.org>
Lubos Lunak <lunak@suse.com>
Original patches => http://www.rosenauer.org/hg/mozilla/file/firefox56

diff --git a/browser/base/content/browser-kde.xul b/browser/base/content/browser-kde.xul
new file mode 100644
index 000000000000..f4ffd8cb9c4f
--- /dev/null
+++ b/browser/base/content/browser-kde.xul
@@ -0,0 +1,1261 @@
+#filter substitution
+<?xml version="1.0"?>
+# -*- Mode: HTML -*-
+#
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+<?xml-stylesheet href="chrome://browser/content/browser.css" type="text/css"?>
+<?xml-stylesheet href="chrome://browser/content/places/places.css" type="text/css"?>
+<?xml-stylesheet href="chrome://browser/content/usercontext/usercontext.css" type="text/css"?>
+<?xml-stylesheet href="chrome://browser/skin/controlcenter/panel.css" type="text/css"?>
+<?xml-stylesheet href="chrome://browser/skin/customizableui/panelUI.css" type="text/css"?>
+<?xml-stylesheet href="chrome://browser/skin/" type="text/css"?>
+
+<?xul-overlay href="chrome://global/content/editMenuOverlay.xul"?>
+<?xul-overlay href="chrome://browser/content/baseMenuOverlay.xul"?>
+<?xul-overlay href="chrome://browser/content/places/placesOverlay.xul"?>
+
+# All DTD information is stored in a separate file so that it can be shared by
+# hiddenWindow.xul.
+#include browser-doctype.inc
+
+<window id="main-window"
+        xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
+        xmlns:svg="http://www.w3.org/2000/svg"
+        xmlns:html="http://www.w3.org/1999/xhtml"
+        xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
+        xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
+        onload="gBrowserInit.onLoad()" onunload="gBrowserInit.onUnload()" onclose="return WindowIsClosing();"
+        title="&mainWindow.title;"
+        title_normal="&mainWindow.title;"
+#ifdef XP_MACOSX
+        title_privatebrowsing="&mainWindow.title;&mainWindow.titlemodifiermenuseparator;&mainWindow.titlePrivateBrowsingSuffix;"
+        titledefault="&mainWindow.title;"
+        titlemodifier=""
+        titlemodifier_normal=""
+        titlemodifier_privatebrowsing="&mainWindow.titlePrivateBrowsingSuffix;"
+#else
+        title_privatebrowsing="&mainWindow.titlemodifier; &mainWindow.titlePrivateBrowsingSuffix;"
+        titlemodifier="&mainWindow.titlemodifier;"
+        titlemodifier_normal="&mainWindow.titlemodifier;"
+        titlemodifier_privatebrowsing="&mainWindow.titlemodifier; &mainWindow.titlePrivateBrowsingSuffix;"
+#endif
+#ifdef CAN_DRAW_IN_TITLEBAR
+#ifdef XP_WIN
+        chromemargin="0,2,2,2"
+#else
+        chromemargin="0,-1,-1,-1"
+#endif
+        tabsintitlebar="true"
+#endif
+        titlemenuseparator="&mainWindow.titlemodifiermenuseparator;"
+        lightweightthemes="true"
+        windowtype="navigator:browser"
+        macanimationtype="document"
+        screenX="4" screenY="4"
+        fullscreenbutton="true"
+        sizemode="normal"
+        retargetdocumentfocus="urlbar"
+        persist="screenX screenY width height sizemode">
+
+# All JS files which are not content (only) dependent that browser.xul
+# wishes to include *must* go into the global-scripts.inc file
+# so that they can be shared by macBrowserOverlay.xul.
+#include global-scripts.inc
+
+<script type="application/javascript" src="chrome://global/content/contentAreaUtils.js"/>
+
+# All sets except for popupsets (commands, keys, stringbundles and broadcasters) *must* go into the
+# browser-sets.inc file for sharing with hiddenWindow.xul.
+#define FULL_BROWSER_WINDOW
+#include browser-sets.inc
+#undef FULL_BROWSER_WINDOW
+
+  <popupset id="mainPopupSet">
+    <menupopup id="tabContextMenu"
+               onpopupshowing="if (event.target == this) TabContextMenu.updateContextMenu(this);"
+               onpopuphidden="if (event.target == this) TabContextMenu.contextTab = null;">
+      <menuitem id="context_reloadTab" label="&reloadTab.label;" accesskey="&reloadTab.accesskey;"
+                oncommand="gBrowser.reloadTab(TabContextMenu.contextTab);"/>
+      <menuitem id="context_toggleMuteTab" oncommand="TabContextMenu.contextTab.toggleMuteAudio();"/>
+      <menuitem id="context_duplicateTab" label="Duplicate Tab" accesskey="D"
+                oncommand="duplicateTabIn(TabContextMenu.contextTab, 'tab');"/>
+      <menuseparator/>
+      <menuitem id="context_pinTab" label="&pinTab.label;"
+                accesskey="&pinTab.accesskey;"
+                oncommand="gBrowser.pinTab(TabContextMenu.contextTab);"/>
+      <menuitem id="context_unpinTab" label="&unpinTab.label;" hidden="true"
+                accesskey="&unpinTab.accesskey;"
+                oncommand="gBrowser.unpinTab(TabContextMenu.contextTab);"/>
+      <menuitem id="context_openTabInWindow" label="&moveToNewWindow.label;"
+                accesskey="&moveToNewWindow.accesskey;"
+                tbattr="tabbrowser-multiple"
+                oncommand="gBrowser.replaceTabWithWindow(TabContextMenu.contextTab);"/>
+#ifdef E10S_TESTING_ONLY
+      <menuitem id="context_openNonRemoteWindow" label="Open in new non-e10s window"
+                tbattr="tabbrowser-remote"
+                hidden="true"
+                oncommand="gBrowser.openNonRemoteWindow(TabContextMenu.contextTab);"/>
+#endif
+      <menuseparator id="context_sendTabToDevice_separator"/>
+      <menu id="context_sendTabToDevice" label="&sendTabToDevice.label;"
+            accesskey="&sendTabToDevice.accesskey;">
+        <menupopup id="context_sendTabToDevicePopupMenu"
+                   onpopupshowing="gSync.populateSendTabToDevicesMenu(event.target, TabContextMenu.contextTab.linkedBrowser.currentURI.spec, TabContextMenu.contextTab.linkedBrowser.contentTitle);"/>
+      </menu>
+      <menuseparator/>
+      <menuitem id="context_reloadAllTabs" label="&reloadAllTabs.label;" accesskey="&reloadAllTabs.accesskey;"
+                tbattr="tabbrowser-multiple-visible"
+                oncommand="gBrowser.reloadAllTabs();"/>
+      <menuitem id="context_bookmarkAllTabs"
+                label="&bookmarkAllTabs.label;"
+                accesskey="&bookmarkAllTabs.accesskey;"
+                command="Browser:BookmarkAllTabs"/>
+      <menuitem id="context_closeTabsToTheEnd" label="&closeTabsToTheEnd.label;" accesskey="&closeTabsToTheEnd.accesskey;"
+                oncommand="gBrowser.removeTabsToTheEndFrom(TabContextMenu.contextTab, {animate: true});"/>
+      <menuitem id="context_closeOtherTabs" label="&closeOtherTabs.label;" accesskey="&closeOtherTabs.accesskey;"
+                oncommand="gBrowser.removeAllTabsBut(TabContextMenu.contextTab);"/>
+      <menuseparator/>
+      <menuitem id="context_undoCloseTab"
+                label="&undoCloseTab.label;"
+                accesskey="&undoCloseTab.accesskey;"
+                observes="History:UndoCloseTab"/>
+      <menuitem id="context_closeTab" label="&closeTab.label;" accesskey="&closeTab.accesskey;"
+                oncommand="gBrowser.removeTab(TabContextMenu.contextTab, { animate: true });"/>
+    </menupopup>
+
+    <!-- bug 415444/582485: event.stopPropagation is here for the cloned version
+         of this menupopup -->
+    <menupopup id="backForwardMenu"
+               onpopupshowing="return FillHistoryMenu(event.target);"
+               oncommand="gotoHistoryIndex(event); event.stopPropagation();"
+               onclick="checkForMiddleClick(this, event);"/>
+    <tooltip id="aHTMLTooltip" page="true"/>
+    <tooltip id="remoteBrowserTooltip"/>
+
+    <!-- for search and content formfill/pw manager -->
+
+    <panel type="autocomplete-richlistbox"
+           id="PopupAutoComplete"
+           noautofocus="true"
+           hidden="true"
+           overflowpadding="4"
+           norolluponanchor="true"
+           nomaxresults="true" />
+
+    <!-- for search with one-off buttons -->
+    <panel type="autocomplete" id="PopupSearchAutoComplete" noautofocus="true" hidden="true"/>
+
+    <!-- for url bar autocomplete -->
+    <panel type="autocomplete-richlistbox"
+           id="PopupAutoCompleteRichResult"
+           noautofocus="true"
+           hidden="true"
+           flip="none"
+           level="parent"
+           overflowpadding="30" />
+
+    <panel id="DateTimePickerPanel"
+           type="arrow"
+           hidden="true"
+           orient="vertical"
+           noautofocus="true"
+           noautohide="true"
+           consumeoutsideclicks="false"
+           level="parent"
+           tabspecific="true">
+    </panel>
+
+    <!-- for select dropdowns. The menupopup is what shows the list of options,
+         and the popuponly menulist makes things like the menuactive attributes
+         work correctly on the menupopup. ContentSelectDropdown expects the
+         popuponly menulist to be its immediate parent. -->
+    <menulist popuponly="true" id="ContentSelectDropdown" hidden="true">
+      <menupopup rolluponmousewheel="true"
+                 activateontab="true" position="after_start"
+                 level="parent"
+#ifdef XP_WIN
+                 consumeoutsideclicks="false" ignorekeys="shortcuts"
+#endif
+        />
+    </menulist>
+
+    <!-- for invalid form error message -->
+    <panel id="invalid-form-popup" type="arrow" orient="vertical" noautofocus="true" hidden="true" level="parent">
+      <description/>
+    </panel>
+
+    <panel id="editBookmarkPanel"
+           type="arrow"
+           orient="vertical"
+           ignorekeys="true"
+           hidden="true"
+           tabspecific="true"
+           onpopupshown="StarUI.panelShown(event);"
+           aria-labelledby="editBookmarkPanelTitle">
+      <row id="editBookmarkPanelHeader" align="center" hidden="true">
+        <vbox align="center">
+          <image id="editBookmarkPanelStarIcon"/>
+        </vbox>
+        <vbox>
+          <label id="editBookmarkPanelTitle"/>
+          <description id="editBookmarkPanelDescription"/>
+        </vbox>
+      </row>
+      <vbox id="editBookmarkPanelContent" flex="1" hidden="true"/>
+      <hbox id="editBookmarkPanelBottomButtons" pack="end">
+#ifdef XP_UNIX
+        <button id="editBookmarkPanelDoneButton"
+                class="editBookmarkPanelBottomButton"
+                label="&editBookmark.done.label;"
+                default="true"
+                oncommand="StarUI.panel.hidePopup();"/>
+        <button id="editBookmarkPanelRemoveButton"
+                class="editBookmarkPanelBottomButton"
+                oncommand="StarUI.removeBookmarkButtonCommand();"
+                accesskey="&editBookmark.removeBookmark.accessKey;"/>
+#else
+        <button id="editBookmarkPanelRemoveButton"
+                class="editBookmarkPanelBottomButton"
+                oncommand="StarUI.removeBookmarkButtonCommand();"
+                accesskey="&editBookmark.removeBookmark.accessKey;"/>
+        <button id="editBookmarkPanelDoneButton"
+                class="editBookmarkPanelBottomButton"
+                label="&editBookmark.done.label;"
+                default="true"
+                oncommand="StarUI.panel.hidePopup();"/>
+#endif
+      </hbox>
+    </panel>
+
+    <panel id="sidebarMenu-popup"
+           class="cui-widget-panel"
+           role="group"
+           type="arrow"
+           hidden="true"
+           flip="slide"
+           orient="vertical"
+           position="bottomcenter topleft">
+      <toolbarbutton id="sidebar-switcher-bookmarks"
+                     class="subviewbutton subviewbutton-iconic"
+                     key="viewBookmarksSidebarKb"
+                     observes="viewBookmarksSidebar"
+                     oncommand="SidebarUI.show('viewBookmarksSidebar');">
+         <observes element="viewBookmarksSidebar" attribute="checked"/>
+       </toolbarbutton>
+      <toolbarbutton id="sidebar-switcher-history"
+                     label="&historyButton.label;"
+                     class="subviewbutton subviewbutton-iconic"
+                     key="key_gotoHistory"
+                     observes="viewHistorySidebar"
+                     oncommand="SidebarUI.show('viewHistorySidebar');">
+         <observes element="viewHistorySidebar" attribute="checked"/>
+       </toolbarbutton>
+      <toolbarbutton id="sidebar-switcher-tabs"
+                     label="&syncedTabs.sidebar.label;"
+                     class="subviewbutton subviewbutton-iconic"
+                     observes="viewTabsSidebar"
+                     oncommand="SidebarUI.show('viewTabsSidebar');">
+         <observes element="viewTabsSidebar" attribute="checked"/>
+       </toolbarbutton>
+      <toolbarseparator/>
+      <vbox id="sidebar-extensions"></vbox>
+      <toolbarseparator/>
+      <toolbarbutton id="sidebar-reverse-position"
+                     class="subviewbutton"
+                     oncommand="SidebarUI.reversePosition()"/>
+      <toolbarseparator/>
+      <toolbarbutton label="&sidebarMenuClose.label;"
+                     class="subviewbutton"
+                     oncommand="SidebarUI.hide()"/>
+    </panel>
+
+    <menupopup id="toolbar-context-menu"
+               onpopupshowing="onViewToolbarsPopupShowing(event, document.getElementById('viewToolbarsMenuSeparator'));">
+      <menuitem oncommand="gCustomizeMode.addToPanel(document.popupNode)"
+                photonaccesskey="&customizeMenu.pinToOverflowMenu.accesskey;"
+                photonlabel="&customizeMenu.pinToOverflowMenu.label;"
+                accesskey="&customizeMenu.moveToPanel.accesskey;"
+                label="&customizeMenu.moveToPanel.label;"
+                contexttype="toolbaritem"
+                class="customize-context-moveToPanel"/>
+      <menuitem oncommand="gCustomizeMode.removeFromArea(document.popupNode)"
+                accesskey="&customizeMenu.removeFromToolbar.accesskey;"
+                label="&customizeMenu.removeFromToolbar.label;"
+                contexttype="toolbaritem"
+                class="customize-context-removeFromToolbar"/>
+      <menuitem id="toolbar-context-reloadAllTabs"
+                class="toolbaritem-tabsmenu"
+                contexttype="tabbar"
+                oncommand="gBrowser.reloadAllTabs();"
+                label="&toolbarContextMenu.reloadAllTabs.label;"
+                accesskey="&toolbarContextMenu.reloadAllTabs.accesskey;"/>
+      <menuitem id="toolbar-context-bookmarkAllTabs"
+                class="toolbaritem-tabsmenu"
+                contexttype="tabbar"
+                command="Browser:BookmarkAllTabs"
+                label="&toolbarContextMenu.bookmarkAllTabs.label;"
+                accesskey="&toolbarContextMenu.bookmarkAllTabs.accesskey;"/>
+      <menuitem id="toolbar-context-undoCloseTab"
+                class="toolbaritem-tabsmenu"
+                contexttype="tabbar"
+                label="&toolbarContextMenu.undoCloseTab.label;"
+                accesskey="&toolbarContextMenu.undoCloseTab.accesskey;"
+                observes="History:UndoCloseTab"/>
+      <menuseparator/>
+      <menuseparator id="viewToolbarsMenuSeparator"/>
+      <!-- XXXgijs: we're using oncommand handler here to avoid the event being
+                    redirected to the command element, thus preventing
+                    listeners on the menupopup or further up the tree from
+                    seeing the command event pass by. The observes attribute is
+                    here so that the menuitem is still disabled and re-enabled
+                    correctly. -->
+      <menuitem oncommand="BrowserCustomizeToolbar()"
+                observes="cmd_CustomizeToolbars"
+                class="viewCustomizeToolbar"
+                label="&viewCustomizeToolbar.label;"
+                accesskey="&viewCustomizeToolbar.accesskey;"/>
+    </menupopup>
+
+    <menupopup id="blockedPopupOptions"
+               onpopupshowing="gPopupBlockerObserver.fillPopupList(event);"
+               onpopuphiding="gPopupBlockerObserver.onPopupHiding(event);">
+      <menuitem observes="blockedPopupAllowSite"/>
+      <menuitem observes="blockedPopupEditSettings"/>
+      <menuitem observes="blockedPopupDontShowMessage"/>
+      <menuseparator observes="blockedPopupsSeparator"/>
+    </menupopup>
+
+    <menupopup id="autohide-context"
+           onpopupshowing="FullScreen.getAutohide(this.firstChild);">
+      <menuitem type="checkbox" label="&fullScreenAutohide.label;"
+                accesskey="&fullScreenAutohide.accesskey;"
+                oncommand="FullScreen.setAutohide();"/>
+      <menuseparator/>
+      <menuitem label="&fullScreenExit.label;"
+                accesskey="&fullScreenExit.accesskey;"
+                oncommand="BrowserFullScreen();"/>
+    </menupopup>
+
+    <menupopup id="contentAreaContextMenu" pagemenu="#page-menu-separator"
+               onpopupshowing="if (event.target != this)
+                                 return true;
+                               gContextMenu = new nsContextMenu(this, event.shiftKey);
+                               if (gContextMenu.shouldDisplay)
+                                 updateEditUIVisibility();
+                               return gContextMenu.shouldDisplay;"
+               onpopuphiding="if (event.target != this)
+                                return;
+                              gContextMenu.hiding();
+                              gContextMenu = null;
+                              updateEditUIVisibility();">
+#include browser-context.inc
+    </menupopup>
+
+    <menupopup id="placesContext">
+      <menuseparator id="placesContext_recentlyBookmarkedSeparator"
+                     ignoreitem="true"
+                     hidden="true"/>
+      <menuitem id="placesContext_hideRecentlyBookmarked"
+                label="&hideRecentlyBookmarked.label;"
+                accesskey="&hideRecentlyBookmarked.accesskey;"
+                oncommand="BookmarkingUI.hideRecentlyBookmarked();"
+                closemenu="single"
+                ignoreitem="true"
+                hidden="true"/>
+      <menuitem id="placesContext_showRecentlyBookmarked"
+                label="&showRecentlyBookmarked.label;"
+                accesskey="&showRecentlyBookmarked.accesskey;"
+                oncommand="BookmarkingUI.showRecentlyBookmarked();"
+                closemenu="single"
+                ignoreitem="true"
+                hidden="true"/>
+    </menupopup>
+
+    <panel id="ctrlTab-panel" hidden="true" norestorefocus="true" level="top">
+      <hbox>
+        <button class="ctrlTab-preview" flex="1"/>
+        <button class="ctrlTab-preview" flex="1"/>
+        <button class="ctrlTab-preview" flex="1"/>
+        <button class="ctrlTab-preview" flex="1"/>
+        <button class="ctrlTab-preview" flex="1"/>
+        <button class="ctrlTab-preview" flex="1"/>
+      </hbox>
+      <hbox pack="center">
+        <button id="ctrlTab-showAll" class="ctrlTab-preview" noicon="true"/>
+      </hbox>
+    </panel>
+
+#ifdef MOZ_PHOTON_THEME
+    <panel id="pageActionPanel"
+           class="cui-widget-panel"
+           role="group"
+           type="arrow"
+           hidden="true"
+           flip="slide"
+           position="bottomcenter topright"
+           tabspecific="true"
+           noautofocus="true"
+           context="pageActionPanelContextMenu"
+           oncontextmenu="BrowserPageActions.onContextMenu(event);"
+           copyURL-title="&copyURLCmd.label;"
+           emailLink-title="&emailPageCmd.label;"
+           sendToDevice-title="&sendToDevice.label2;"
+           sendToDevice-notReadyTitle="&sendToDevice.syncNotReady.label;">
+      <photonpanelmultiview id="pageActionPanelMultiView"
+                            mainViewId="pageActionPanelMainView"
+                            viewCacheId="appMenu-viewCache">
+        <panelview id="pageActionPanelMainView"
+                   class="PanelUI-subView">
+          <vbox class="panel-subview-body"/>
+        </panelview>
+      </photonpanelmultiview>
+    </panel>
+
+    <menupopup id="pageActionPanelContextMenu"
+               onpopupshowing="BrowserPageActions.onContextMenuShowing(event, this);">
+      <menuitem id="pageActionPanelContextMenu-toggleUrlbar"
+                add-label="&pageAction.addToUrlbar.label;"
+                remove-label="&pageAction.removeFromUrlbar.label;"
+                label="&pageAction.addToUrlbar.label;"
+                oncommand="BrowserPageActions.toggleShownInUrlbarForContextAction();"/>
+    </menupopup>
+#endif
+
+    <!-- Bookmarks and history tooltip -->
+    <tooltip id="bhTooltip"/>
+
+    <tooltip id="tabbrowser-tab-tooltip" onpopupshowing="gBrowser.createTooltip(event);"/>
+
+    <tooltip id="back-button-tooltip">
+      <label class="tooltip-label" value="&backButton.tooltip;"/>
+#ifdef XP_MACOSX
+      <label class="tooltip-label" value="&backForwardButtonMenuMac.tooltip;"/>
+#else
+      <label class="tooltip-label" value="&backForwardButtonMenu.tooltip;"/>
+#endif
+    </tooltip>
+
+    <tooltip id="forward-button-tooltip">
+      <label class="tooltip-label" value="&forwardButton.tooltip;"/>
+#ifdef XP_MACOSX
+      <label class="tooltip-label" value="&backForwardButtonMenuMac.tooltip;"/>
+#else
+      <label class="tooltip-label" value="&backForwardButtonMenu.tooltip;"/>
+#endif
+    </tooltip>
+
+#include popup-notifications.inc
+
+#include ../../components/customizableui/content/panelUI.inc.xul
+#include ../../components/controlcenter/content/panel.inc.xul
+
+    <hbox id="downloads-animation-container" mousethrough="always">
+      <vbox id="downloads-notification-anchor">
+        <vbox id="downloads-indicator-notification"/>
+      </vbox>
+    </hbox>
+
+    <hbox id="bookmarked-notification-container" mousethrough="always">
+      <vbox id="bookmarked-notification-anchor">
+        <vbox id="bookmarked-notification"/>
+      </vbox>
+      <vbox id="bookmarked-notification-dropmarker-anchor">
+        <image id="bookmarked-notification-dropmarker-icon"/>
+      </vbox>
+    </hbox>
+
+    <tooltip id="dynamic-shortcut-tooltip"
+             onpopupshowing="UpdateDynamicShortcutTooltipText(this);"/>
+
+    <menupopup id="SyncedTabsSidebarContext">
+      <menuitem label="&syncedTabs.context.open.label;"
+                accesskey="&syncedTabs.context.open.accesskey;"
+                id="syncedTabsOpenSelected" where="current"/>
+      <menuitem label="&syncedTabs.context.openInNewTab.label;"
+                accesskey="&syncedTabs.context.openInNewTab.accesskey;"
+                id="syncedTabsOpenSelectedInTab" where="tab"/>
+      <menuitem label="&syncedTabs.context.openInNewWindow.label;"
+                accesskey="&syncedTabs.context.openInNewWindow.accesskey;"
+                id="syncedTabsOpenSelectedInWindow" where="window"/>
+      <menuitem label="&syncedTabs.context.openInNewPrivateWindow.label;"
+                accesskey="&syncedTabs.context.openInNewPrivateWindow.accesskey;"
+                id="syncedTabsOpenSelectedInPrivateWindow" where="window" private="true"/>
+      <menuseparator/>
+      <menuitem label="&syncedTabs.context.bookmarkSingleTab.label;"
+                accesskey="&syncedTabs.context.bookmarkSingleTab.accesskey;"
+                id="syncedTabsBookmarkSelected"/>
+      <menuitem label="&syncedTabs.context.copy.label;"
+                accesskey="&syncedTabs.context.copy.accesskey;"
+                id="syncedTabsCopySelected"/>
+      <menuseparator/>
+      <menuitem label="&syncedTabs.context.openAllInTabs.label;"
+                accesskey="&syncedTabs.context.openAllInTabs.accesskey;"
+                id="syncedTabsOpenAllInTabs"/>
+      <menuitem label="&syncedTabs.context.managedevices.label;"
+                accesskey="&syncedTabs.context.managedevices.accesskey;"
+                id="syncedTabsManageDevices"
+                oncommand="gSync.openDevicesManagementPage('syncedtabs-sidebar');"/>
+      <menuitem label="&syncSyncNowItem.label;"
+                accesskey="&syncSyncNowItem.accesskey;"
+                id="syncedTabsRefresh"/>
+    </menupopup>
+    <menupopup id="SyncedTabsSidebarTabsFilterContext"
+               class="textbox-contextmenu">
+      <menuitem label="&undoCmd.label;"
+                accesskey="&undoCmd.accesskey;"
+                cmd="cmd_undo"/>
+      <menuseparator/>
+      <menuitem label="&cutCmd.label;"
+                accesskey="&cutCmd.accesskey;"
+                cmd="cmd_cut"/>
+      <menuitem label="&copyCmd.label;"
+                accesskey="&copyCmd.accesskey;"
+                cmd="cmd_copy"/>
+      <menuitem label="&pasteCmd.label;"
+                accesskey="&pasteCmd.accesskey;"
+                cmd="cmd_paste"/>
+      <menuitem label="&deleteCmd.label;"
+                accesskey="&deleteCmd.accesskey;"
+                cmd="cmd_delete"/>
+      <menuseparator/>
+      <menuitem label="&selectAllCmd.label;"
+                accesskey="&selectAllCmd.accesskey;"
+                cmd="cmd_selectAll"/>
+      <menuseparator/>
+      <menuitem label="&syncSyncNowItem.label;"
+                accesskey="&syncSyncNowItem.accesskey;"
+                id="syncedTabsRefreshFilter"/>
+    </menupopup>
+  </popupset>
+  <box id="appMenu-viewCache" hidden="true"/>
+
+#ifdef CAN_DRAW_IN_TITLEBAR
+<vbox id="titlebar">
+  <hbox id="titlebar-content">
+    <spacer id="titlebar-spacer" flex="1"/>
+    <hbox id="titlebar-buttonbox-container">
+#ifdef XP_WIN
+      <hbox id="private-browsing-indicator-titlebar">
+        <hbox class="private-browsing-indicator"/>
+      </hbox>
+#endif
+      <hbox id="titlebar-buttonbox">
+        <toolbarbutton class="titlebar-button" id="titlebar-min" oncommand="window.minimize();"/>
+        <toolbarbutton class="titlebar-button" id="titlebar-max" oncommand="onTitlebarMaxClick();"/>
+        <toolbarbutton class="titlebar-button" id="titlebar-close" command="cmd_closeWindow"/>
+      </hbox>
+    </hbox>
+#ifdef XP_MACOSX
+    <!-- OS X does not natively support RTL for its titlebar items, so we prevent this secondary
+         buttonbox from reversing order in RTL by forcing an LTR direction. -->
+    <hbox id="titlebar-secondary-buttonbox" dir="ltr">
+      <hbox class="private-browsing-indicator"/>
+      <hbox id="titlebar-fullscreen-button"/>
+    </hbox>
+#endif
+  </hbox>
+</vbox>
+#endif
+
+<deck flex="1" id="tab-view-deck">
+<vbox flex="1" id="browser-panel">
+
+  <toolbox id="navigator-toolbox" mode="icons">
+    <!-- Menu -->
+    <toolbar type="menubar" id="toolbar-menubar" class="chromeclass-menubar" customizable="true"
+             mode="icons" iconsize="small"
+#ifdef MENUBAR_CAN_AUTOHIDE
+             toolbarname="&menubarCmd.label;"
+             accesskey="&menubarCmd.accesskey;"
+             autohide="true"
+#endif
+             context="toolbar-context-menu">
+      <toolbaritem id="menubar-items" align="center">
+# The entire main menubar is placed into browser-menubar.inc, so that it can be shared by
+# hiddenWindow.xul.
+#include browser-menubar.inc
+      </toolbaritem>
+
+#ifdef CAN_DRAW_IN_TITLEBAR
+#ifndef XP_MACOSX
+      <hbox class="titlebar-placeholder" type="caption-buttons" ordinal="1000"
+            id="titlebar-placeholder-on-menubar-for-caption-buttons" persist="width"
+            skipintoolbarset="true"/>
+#endif
+#endif
+    </toolbar>
+
+    <toolbar id="TabsToolbar"
+             fullscreentoolbar="true"
+             customizable="true"
+             mode="icons"
+             iconsize="small"
+             aria-label="&tabsToolbar.label;"
+             context="toolbar-context-menu"
+             collapsed="true">
+
+#if defined(MOZ_WIDGET_GTK)
+      <hbox id="private-browsing-indicator"
+            skipintoolbarset="true"/>
+#endif
+
+      <tabs id="tabbrowser-tabs"
+            class="tabbrowser-tabs"
+            tabbrowser="content"
+            flex="1"
+            setfocus="false"
+            tooltip="tabbrowser-tab-tooltip"
+            stopwatchid="FX_TAB_CLICK_MS">
+        <tab class="tabbrowser-tab" selected="true" visuallyselected="true" fadein="true"/>
+      </tabs>
+
+      <toolbarbutton id="new-tab-button"
+                     class="toolbarbutton-1 chromeclass-toolbar-additional"
+                     label="&tabCmd.label;"
+                     command="cmd_newNavigatorTab"
+                     onclick="checkForMiddleClick(this, event);"
+                     tooltip="dynamic-shortcut-tooltip"
+                     ondrop="newTabButtonObserver.onDrop(event)"
+                     ondragover="newTabButtonObserver.onDragOver(event)"
+                     ondragenter="newTabButtonObserver.onDragOver(event)"
+                     ondragexit="newTabButtonObserver.onDragExit(event)"
+                     cui-areatype="toolbar"
+                     removable="true"/>
+
+      <toolbarbutton id="alltabs-button"
+                     class="toolbarbutton-1 chromeclass-toolbar-additional tabs-alltabs-button"
+                     type="menu"
+                     label="&listAllTabs.label;"
+                     tooltiptext="&listAllTabs.label;"
+                     removable="false">
+        <menupopup id="alltabs-popup"
+                   position="after_end">
+          <menuitem id="alltabs_undoCloseTab"
+                    key="key_undoCloseTab"
+                    label="&undoCloseTab.label;"
+                    observes="History:UndoCloseTab"/>
+          <menuseparator id="alltabs-popup-separator-1"/>
+          <menu id="alltabs_containersTab"
+                label="&newUserContext.label;">
+            <menupopup id="alltabs_containersMenuTab" />
+          </menu>
+          <menuseparator id="alltabs-popup-separator-2"/>
+        </menupopup>
+      </toolbarbutton>
+
+#if !defined(MOZ_WIDGET_GTK)
+      <hbox class="private-browsing-indicator" skipintoolbarset="true"/>
+#endif
+#ifdef CAN_DRAW_IN_TITLEBAR
+      <hbox class="titlebar-placeholder" type="caption-buttons"
+            id="titlebar-placeholder-on-TabsToolbar-for-captions-buttons" persist="width"
+#ifndef XP_MACOSX
+            ordinal="1000"
+#endif
+            skipintoolbarset="true"/>
+
+#ifdef XP_MACOSX
+      <hbox class="titlebar-placeholder" type="fullscreen-button"
+            id="titlebar-placeholder-on-TabsToolbar-for-fullscreen-button" persist="width"
+            skipintoolbarset="true"/>
+#endif
+#endif
+    </toolbar>
+
+    <toolbar id="nav-bar"
+             aria-label="&navbarCmd.label;"
+             fullscreentoolbar="true" mode="icons" customizable="true"
+             iconsize="small"
+             customizationtarget="nav-bar-customization-target"
+             overflowable="true"
+             overflowbutton="nav-bar-overflow-button"
+             overflowtarget="widget-overflow-list"
+             overflowpanel="widget-overflow"
+             context="toolbar-context-menu">
+
+      <hbox id="nav-bar-customization-target" flex="1">
+        <toolbaritem id="urlbar-container" flex="400" persist="width"
+                     removable="false"
+                     class="chromeclass-location" overflows="false">
+          <toolbarbutton id="back-button" class="toolbarbutton-1 chromeclass-toolbar-additional"
+                         removable="false" overflows="false"
+                         label="&backCmd.label;"
+                         command="Browser:BackOrBackDuplicate"
+                         onclick="checkForMiddleClick(this, event);"
+                         tooltip="back-button-tooltip"
+                         context="backForwardMenu"/>
+#ifdef MOZ_PHOTON_THEME
+          <toolbarbutton id="forward-button" class="toolbarbutton-1 chromeclass-toolbar-additional"
+                         removable="false" overflows="false"
+                         label="&forwardCmd.label;"
+                         command="Browser:ForwardOrForwardDuplicate"
+                         onclick="checkForMiddleClick(this, event);"
+                         tooltip="forward-button-tooltip"
+                         context="backForwardMenu"/>
+          <toolbaritem id="stop-reload-button"
+                       removable="false" overflows="false"
+                       class="chromeclass-toolbar-additional">
+            <toolbarbutton id="reload-button"
+                           class="toolbarbutton-1"
+                           command="Browser:ReloadOrDuplicate"
+                           onclick="checkForMiddleClick(this, event);"
+                           tooltip="dynamic-shortcut-tooltip">
+              <box class="toolbarbutton-animatable-box">
+                <image class="toolbarbutton-animatable-image"/>
+              </box>
+            </toolbarbutton>
+            <toolbarbutton id="stop-button"
+                           class="toolbarbutton-1"
+                           command="Browser:Stop"
+                           tooltip="dynamic-shortcut-tooltip">
+              <box class="toolbarbutton-animatable-box">
+                <image class="toolbarbutton-animatable-image"/>
+              </box>
+            </toolbarbutton>
+          </toolbaritem>
+#endif
+          <hbox id="urlbar-wrapper" flex="1">
+#ifndef MOZ_PHOTON_THEME
+            <toolbarbutton id="forward-button" class="toolbarbutton-1 chromeclass-toolbar-additional"
+                           label="&forwardCmd.label;"
+                           command="Browser:ForwardOrForwardDuplicate"
+                           onclick="checkForMiddleClick(this, event);"
+                           tooltip="forward-button-tooltip"
+                           context="backForwardMenu"/>
+#endif
+            <textbox id="urlbar" flex="1"
+                     placeholder="&urlbar.placeholder2;"
+                     type="autocomplete"
+                     autocompletesearch="unifiedcomplete"
+                     autocompletesearchparam="enable-actions"
+                     autocompletepopup="PopupAutoCompleteRichResult"
+                     completeselectedindex="true"
+                     shrinkdelay="250"
+                     tabscrolling="true"
+                     showcommentcolumn="true"
+                     showimagecolumn="true"
+                     enablehistory="true"
+                     newlines="stripsurroundingwhitespace"
+                     ontextentered="this.handleCommand(param);"
+                     ontextreverted="return this.handleRevert();"
+                     pageproxystate="invalid">
+              <!-- Use onclick instead of normal popup= syntax since the popup
+                   code fires onmousedown, and hence eats our favicon drag events. -->
+              <box id="identity-box" role="button"
+                   align="center"
+                   aria-label="&urlbar.viewSiteInfo.label;"
+                   onclick="gIdentityHandler.handleIdentityButtonEvent(event);"
+                   onkeypress="gIdentityHandler.handleIdentityButtonEvent(event);"
+                   ondragstart="gIdentityHandler.onDragStart(event);">
+                <image id="identity-icon"
+                       consumeanchor="identity-box"
+                       onclick="PageProxyClickHandler(event);"/>
+                <image id="sharing-icon" mousethrough="always"/>
+                <image id="tracking-protection-icon"/>
+                <box id="blocked-permissions-container" align="center">
+                  <image data-permission-id="geo" class="blocked-permission-icon geo-icon" role="button"
+                         tooltiptext="&urlbar.geolocationBlocked.tooltip;"/>
+                  <image data-permission-id="desktop-notification" class="blocked-permission-icon desktop-notification-icon" role="button"
+                         tooltiptext="&urlbar.webNotificationsBlocked.tooltip;"/>
+                  <image data-permission-id="camera" class="blocked-permission-icon camera-icon" role="button"
+                         tooltiptext="&urlbar.cameraBlocked.tooltip;"/>
+                  <image data-permission-id="indexedDB" class="blocked-permission-icon indexedDB-icon" role="button"
+                         tooltiptext="&urlbar.indexedDBBlocked.tooltip;"/>
+                  <image data-permission-id="microphone" class="blocked-permission-icon microphone-icon" role="button"
+                         tooltiptext="&urlbar.microphoneBlocked.tooltip;"/>
+                  <image data-permission-id="screen" class="blocked-permission-icon screen-icon" role="button"
+                         tooltiptext="&urlbar.screenBlocked.tooltip;"/>
+                  <image data-permission-id="persistent-storage" class="blocked-permission-icon persistent-storage-icon" role="button"
+                         tooltiptext="&urlbar.persistentStorageBlocked.tooltip;"/>
+                </box>
+                <box id="notification-popup-box"
+                     hidden="true"
+                     onmouseover="document.getElementById('identity-box').classList.add('no-hover');"
+                     onmouseout="document.getElementById('identity-box').classList.remove('no-hover');"
+                     align="center">
+                  <image id="default-notification-icon" class="notification-anchor-icon" role="button"
+                         tooltiptext="&urlbar.defaultNotificationAnchor.tooltip;"/>
+                  <image id="geo-notification-icon" class="notification-anchor-icon geo-icon" role="button"
+                         tooltiptext="&urlbar.geolocationNotificationAnchor.tooltip;"/>
+                  <image id="addons-notification-icon" class="notification-anchor-icon install-icon" role="button"
+                         tooltiptext="&urlbar.addonsNotificationAnchor.tooltip;"/>
+                  <image id="indexedDB-notification-icon" class="notification-anchor-icon indexedDB-icon" role="button"
+                         tooltiptext="&urlbar.indexedDBNotificationAnchor.tooltip;"/>
+                  <image id="password-notification-icon" class="notification-anchor-icon login-icon" role="button"
+                         tooltiptext="&urlbar.passwordNotificationAnchor.tooltip;"/>
+                  <stack id="plugins-notification-icon" class="notification-anchor-icon" role="button" align="center"
+                         tooltiptext="&urlbar.pluginsNotificationAnchor.tooltip;">
+                    <image class="plugin-icon" />
+                    <image id="plugin-icon-badge" />
+                  </stack>
+                  <image id="web-notifications-notification-icon" class="notification-anchor-icon desktop-notification-icon" role="button"
+                         tooltiptext="&urlbar.webNotificationAnchor.tooltip;"/>
+                  <image id="webRTC-shareDevices-notification-icon" class="notification-anchor-icon camera-icon" role="button"
+                         tooltiptext="&urlbar.webRTCShareDevicesNotificationAnchor.tooltip;"/>
+                  <image id="webRTC-shareMicrophone-notification-icon" class="notification-anchor-icon microphone-icon" role="button"
+                         tooltiptext="&urlbar.webRTCShareMicrophoneNotificationAnchor.tooltip;"/>
+                  <image id="webRTC-shareScreen-notification-icon" class="notification-anchor-icon screen-icon" role="button"
+                         tooltiptext="&urlbar.webRTCShareScreenNotificationAnchor.tooltip;"/>
+                  <image id="servicesInstall-notification-icon" class="notification-anchor-icon service-icon" role="button"
+                         tooltiptext="&urlbar.servicesNotificationAnchor.tooltip;"/>
+                  <image id="translate-notification-icon" class="notification-anchor-icon translation-icon" role="button"
+                         tooltiptext="&urlbar.translateNotificationAnchor.tooltip;"/>
+                  <image id="translated-notification-icon" class="notification-anchor-icon translation-icon in-use" role="button"
+                         tooltiptext="&urlbar.translatedNotificationAnchor.tooltip;"/>
+                  <image id="eme-notification-icon" class="notification-anchor-icon drm-icon" role="button"
+                         tooltiptext="&urlbar.emeNotificationAnchor.tooltip;"/>
+                  <image id="persistent-storage-notification-icon" class="notification-anchor-icon persistent-storage-icon" role="button"
+                         tooltiptext="&urlbar.persistentStorageNotificationAnchor.tooltip;"/>
+                </box>
+                <image id="connection-icon"/>
+                <image id="extension-icon"/>
+                <image id="remote-control-icon"
+                       tooltiptext="&urlbar.remoteControlNotificationAnchor.tooltip;"/>
+                <hbox id="identity-icon-labels">
+                  <label id="identity-icon-label" class="plain" flex="1"/>
+                  <label id="identity-icon-country-label" class="plain"/>
+                </hbox>
+              </box>
+              <box id="urlbar-display-box" align="center">
+                <label id="switchtab" class="urlbar-display urlbar-display-switchtab" value="&urlbar.switchToTab.label;"/>
+                <label id="extension" class="urlbar-display urlbar-display-extension" value="&urlbar.extension.label;"/>
+              </box>
+              <hbox id="urlbar-icons">
+                <image id="page-report-button"
+                       class="urlbar-icon"
+                       hidden="true"
+                       tooltiptext="&pageReportIcon.tooltip;"
+                       onmousedown="gPopupBlockerObserver.onReportButtonMousedown(event);"/>
+                <image id="reader-mode-button"
+                       class="urlbar-icon"
+                       hidden="true"
+                       onclick="ReaderParent.buttonClick(event);"/>
+                <toolbarbutton id="urlbar-zoom-button"
+                       onclick="FullZoom.reset();"
+                       tooltip="dynamic-shortcut-tooltip"
+                       hidden="true"/>
+#ifdef MOZ_PHOTON_THEME
+                <image id="pageActionButton"
+                       class="urlbar-icon"
+                       tooltiptext="&pageActionButton.tooltip;"
+                       onclick="BrowserPageActions.mainButtonClicked(event);"/>
+                <hbox id="star-button-box" hidden="true">
+                  <image id="star-button"
+                         class="urlbar-icon"
+                         onclick="BookmarkingUI.onStarCommand(event);">
+                    <observes element="bookmarkThisPageBroadcaster" attribute="starred"/>
+                    <observes element="bookmarkThisPageBroadcaster" attribute="tooltiptext"/>
+                  </image>
+                  <hbox id="star-button-animatable-box">
+                    <image id="star-button-animatable-image"
+                           onclick="BookmarkingUI.onStarCommand(event);"/>
+                  </hbox>
+                </hbox>
+#endif
+              </hbox>
+              <hbox id="userContext-icons" hidden="true">
+                <label id="userContext-label"/>
+                <image id="userContext-indicator"/>
+              </hbox>
+#ifndef MOZ_PHOTON_THEME
+              <toolbarbutton id="urlbar-go-button"
+                             class="chromeclass-toolbar-additional"
+                             onclick="gURLBar.handleCommand(event);"
+                             tooltiptext="&goEndCap.tooltip;"/>
+              <toolbarbutton id="reload-button"
+                             class="chromeclass-toolbar-additional"
+                             command="Browser:ReloadOrDuplicate"
+                             onclick="checkForMiddleClick(this, event);"
+                             tooltip="dynamic-shortcut-tooltip"/>
+              <toolbarbutton id="stop-button"
+                             class="chromeclass-toolbar-additional"
+                             command="Browser:Stop"
+                             tooltip="dynamic-shortcut-tooltip"/>
+#endif
+            </textbox>
+          </hbox>
+        </toolbaritem>
+
+        <toolbaritem id="search-container" title="&searchItem.title;"
+                     align="center" class="chromeclass-toolbar-additional panel-wide-item"
+                     cui-areatype="toolbar"
+                     flex="100" persist="width" removable="true">
+          <searchbar id="searchbar" flex="1"/>
+        </toolbaritem>
+
+        <toolbarbutton id="bookmarks-menu-button"
+                       class="toolbarbutton-1 chromeclass-toolbar-additional"
+                       removable="true"
+#ifdef MOZ_PHOTON_THEME
+                       type="menu"
+#else
+                       type="menu-button"
+#endif
+                       label="&bookmarksMenuButton.label;"
+                       tooltip="dynamic-shortcut-tooltip"
+                       anchor="dropmarker"
+                       ondragenter="PlacesMenuDNDHandler.onDragEnter(event);"
+                       ondragover="PlacesMenuDNDHandler.onDragOver(event);"
+                       ondragleave="PlacesMenuDNDHandler.onDragLeave(event);"
+                       ondrop="PlacesMenuDNDHandler.onDrop(event);"
+                       cui-areatype="toolbar"
+                       oncommand="BookmarkingUI.onCommand(event);">
+          <observes element="bookmarkThisPageBroadcaster" attribute="starred"/>
+          <observes element="bookmarkThisPageBroadcaster" attribute="buttontooltiptext"/>
+          <menupopup id="BMB_bookmarksPopup"
+                     class="cui-widget-panel cui-widget-panelview cui-widget-panelWithFooter PanelUI-subView"
+                     placespopup="true"
+                     context="placesContext"
+                     openInTabs="children"
+                     oncommand="BookmarksEventHandler.onCommand(event);"
+                     onclick="BookmarksEventHandler.onClick(event, this.parentNode._placesView);"
+                     onpopupshowing="BookmarkingUI.onPopupShowing(event);
+                                     BookmarkingUI.attachPlacesView(event, this);"
+                     tooltip="bhTooltip" popupsinherittooltip="true">
+            <menuitem id="BMB_viewBookmarksSidebar"
+                      class="subviewbutton"
+                      label="&viewBookmarksSidebar2.label;"
+                      type="checkbox"
+                      oncommand="SidebarUI.toggle('viewBookmarksSidebar');">
+              <observes element="viewBookmarksSidebar" attribute="checked"/>
+            </menuitem>
+            <!-- NB: temporary solution for bug 985024, this should go away soon. -->
+            <menuitem id="BMB_bookmarksShowAllTop"
+                      class="menuitem-iconic subviewbutton"
+                      label="&showAllBookmarks2.label;"
+                      command="Browser:ShowAllBookmarks"
+                      key="manBookmarkKb"/>
+            <menuseparator/>
+            <menuitem label="&recentBookmarks.label;"
+                      id="BMB_recentBookmarks"
+                      disabled="true"
+                      class="menuitem-iconic subviewbutton"/>
+            <menuseparator/>
+            <menu id="BMB_bookmarksToolbar"
+                  class="menu-iconic bookmark-item subviewbutton"
+                  label="&personalbarCmd.label;"
+                  container="true">
+              <menupopup id="BMB_bookmarksToolbarPopup"
+                         placespopup="true"
+                         context="placesContext"
+                         onpopupshowing="if (!this.parentNode._placesView)
+                                           new PlacesMenu(event, 'place:folder=TOOLBAR',
+                                                          PlacesUIUtils.getViewForNode(this.parentNode.parentNode).options);">
+                <menuitem id="BMB_viewBookmarksToolbar"
+                          placesanonid="view-toolbar"
+                          toolbarId="PersonalToolbar"
+                          type="checkbox"
+                          oncommand="onViewToolbarCommand(event)"
+                          label="&viewBookmarksToolbar.label;"/>
+                <menuseparator/>
+                <!-- Bookmarks toolbar items -->
+              </menupopup>
+            </menu>
+            <menu id="BMB_unsortedBookmarks"
+                  class="menu-iconic bookmark-item subviewbutton"
+                  label="&bookmarksMenuButton.other.label;"
+                  container="true">
+              <menupopup id="BMB_unsortedBookmarksPopup"
+                         placespopup="true"
+                         context="placesContext"
+                         onpopupshowing="if (!this.parentNode._placesView)
+                                           new PlacesMenu(event, 'place:folder=UNFILED_BOOKMARKS',
+                                                          PlacesUIUtils.getViewForNode(this.parentNode.parentNode).options);"/>
+            </menu>
+            <menu id="BMB_mobileBookmarks"
+                  class="menu-iconic bookmark-item subviewbutton"
+                  label="&bookmarksMenuButton.mobile.label;"
+                  hidden="true"
+                  container="true">
+              <menupopup id="BMB_mobileBookmarksPopup"
+                         placespopup="true"
+                         context="placesContext"
+                         onpopupshowing="if (!this.parentNode._placesView)
+                                           new PlacesMenu(event, 'place:folder=MOBILE_BOOKMARKS',
+                                                          PlacesUIUtils.getViewForNode(this.parentNode.parentNode).options);"/>
+            </menu>
+
+            <menuseparator/>
+            <!-- Bookmarks menu items will go here -->
+            <menuitem id="BMB_bookmarksShowAll"
+                      class="subviewbutton panel-subview-footer"
+                      label="&showAllBookmarks2.label;"
+                      command="Browser:ShowAllBookmarks"
+                      key="manBookmarkKb"/>
+          </menupopup>
+        </toolbarbutton>
+
+        <!-- This is a placeholder for the Downloads Indicator.  It is visible
+             during the customization of the toolbar, in the palette, and before
+             the Downloads Indicator overlay is loaded. -->
+        <toolbarbutton id="downloads-button"
+                       class="toolbarbutton-1 chromeclass-toolbar-additional badged-button"
+                       key="key_openDownloads"
+                       oncommand="DownloadsIndicatorView.onCommand(event);"
+                       ondrop="DownloadsIndicatorView.onDrop(event);"
+                       ondragover="DownloadsIndicatorView.onDragOver(event);"
+                       ondragenter="DownloadsIndicatorView.onDragOver(event);"
+                       label="&downloads.label;"
+                       removable="true"
+                       cui-areatype="toolbar"
+                       tooltip="dynamic-shortcut-tooltip"/>
+
+        <toolbarbutton id="home-button" class="toolbarbutton-1 chromeclass-toolbar-additional"
+                       removable="true"
+                       label="&homeButton.label;"
+                       ondragover="homeButtonObserver.onDragOver(event)"
+                       ondragenter="homeButtonObserver.onDragOver(event)"
+                       ondrop="homeButtonObserver.onDrop(event)"
+                       ondragexit="homeButtonObserver.onDragExit(event)"
+                       key="goHome"
+                       onclick="BrowserGoHome(event);"
+                       cui-areatype="toolbar"
+                       aboutHomeOverrideTooltip="&abouthome.pageTitle;"/>
+      </hbox>
+
+      <toolbarbutton id="nav-bar-overflow-button"
+                     class="toolbarbutton-1 chromeclass-toolbar-additional overflow-button"
+                     skipintoolbarset="true"
+                     tooltiptext="&navbarOverflow.label;">
+#ifdef MOZ_PHOTON_ANIMATIONS
+        <box class="toolbarbutton-animatable-box">
+          <image class="toolbarbutton-animatable-image"/>
+        </box>
+#endif
+      </toolbarbutton>
+
+      <toolbaritem id="PanelUI-button"
+                   class="chromeclass-toolbar-additional"
+                   removable="false">
+        <toolbarbutton id="PanelUI-menu-button"
+                       class="toolbarbutton-1 badged-button"
+                       consumeanchor="PanelUI-button"
+                       label="&brandShortName;"
+                       tooltiptext="&appmenu.tooltip;"/>
+      </toolbaritem>
+
+      <hbox id="window-controls" hidden="true" pack="end" skipintoolbarset="true"
+            ordinal="1000">
+        <toolbarbutton id="minimize-button"
+                       tooltiptext="&fullScreenMinimize.tooltip;"
+                       oncommand="window.minimize();"/>
+
+        <toolbarbutton id="restore-button"
+#ifdef XP_MACOSX
+# Prior to 10.7 there wasn't a native fullscreen button so we use #restore-button
+# to exit fullscreen and want it to behave like other toolbar buttons.
+                       class="toolbarbutton-1"
+#endif
+                       tooltiptext="&fullScreenRestore.tooltip;"
+                       oncommand="BrowserFullScreen();"/>
+
+        <toolbarbutton id="close-button"
+                       tooltiptext="&fullScreenClose.tooltip;"
+                       oncommand="BrowserTryToCloseWindow();"/>
+      </hbox>
+    </toolbar>
+
+    <toolbarset id="customToolbars" context="toolbar-context-menu"/>
+
+    <toolbar id="PersonalToolbar"
+             mode="icons" iconsize="small"
+             class="chromeclass-directories"
+             context="toolbar-context-menu"
+             toolbarname="&personalbarCmd.label;" accesskey="&personalbarCmd.accesskey;"
+             collapsed="true"
+             customizable="true">
+      <toolbaritem id="personal-bookmarks"
+                   title="&bookmarksToolbarItem.label;"
+                   cui-areatype="toolbar"
+                   removable="true">
+        <toolbarbutton id="bookmarks-toolbar-placeholder"
+                       class="toolbarbutton-1"
+                       mousethrough="never"
+                       label="&bookmarksToolbarItem.label;"
+                       oncommand="PlacesToolbarHelper.onPlaceholderCommand();"/>
+        <hbox flex="1"
+              id="PlacesToolbar"
+              context="placesContext"
+              onclick="BookmarksEventHandler.onClick(event, this._placesView);"
+              oncommand="BookmarksEventHandler.onCommand(event);"
+              tooltip="bhTooltip"
+              popupsinherittooltip="true">
+          <hbox flex="1">
+            <hbox id="PlacesToolbarDropIndicatorHolder" align="center" collapsed="true">
+              <image id="PlacesToolbarDropIndicator"
+                     mousethrough="always"
+                     collapsed="true"/>
+            </hbox>
+            <scrollbox orient="horizontal"
+                       id="PlacesToolbarItems"
+                       flex="1"/>
+            <toolbarbutton type="menu"
+                           id="PlacesChevron"
+                           class="chevron"
+                           mousethrough="never"
+                           collapsed="true"
+                           tooltiptext="&bookmarksToolbarChevron.tooltip;"
+                           onpopupshowing="document.getElementById('PlacesToolbar')
+                                                   ._placesView._onChevronPopupShowing(event);">
+              <menupopup id="PlacesChevronPopup"
+                         placespopup="true"
+                         tooltip="bhTooltip" popupsinherittooltip="true"
+                         context="placesContext"/>
+            </toolbarbutton>
+          </hbox>
+        </hbox>
+      </toolbaritem>
+    </toolbar>
+
+    <!-- This is a shim which will go away ASAP. See bug 749804 for details -->
+    <toolbar id="addon-bar" toolbar-delegate="nav-bar" mode="icons" iconsize="small"
+             customizable="true">
+      <hbox id="addonbar-closebutton"/>
+      <statusbar id="status-bar"/>
+    </toolbar>
+
+    <toolbarpalette id="BrowserToolbarPalette">
+
+# Update primaryToolbarButtons in browser/themes/shared/browser.inc when adding
+# or removing default items with the toolbarbutton-1 class.
+
+      <toolbarbutton id="print-button" class="toolbarbutton-1 chromeclass-toolbar-additional"
+#ifdef XP_MACOSX
+                     command="cmd_print"
+                     tooltip="dynamic-shortcut-tooltip"
+#else
+                     command="cmd_printPreview"
+                     tooltiptext="&printButton.tooltip;"
+#endif
+                     label="&printButton.label;"/>
+
+
+      <toolbarbutton id="new-window-button" class="toolbarbutton-1 chromeclass-toolbar-additional"
+                     label="&newNavigatorCmd.label;"
+                     command="cmd_newNavigator"
+                     tooltip="dynamic-shortcut-tooltip"
+                     ondrop="newWindowButtonObserver.onDrop(event)"
+                     ondragover="newWindowButtonObserver.onDragOver(event)"
+                     ondragenter="newWindowButtonObserver.onDragOver(event)"
+                     ondragexit="newWindowButtonObserver.onDragExit(event)"/>
+
+      <toolbarbutton id="fullscreen-button" class="toolbarbutton-1 chromeclass-toolbar-additional"
+                     observes="View:FullScreen"
+                     type="checkbox"
+                     label="&fullScreenCmd.label;"
+                     tooltip="dynamic-shortcut-tooltip"/>
+#ifdef MOZ_PHOTON_THEME
+      <toolbarbutton id="library-button" class="toolbarbutton-1 chromeclass-toolbar-additional"
+                     oncommand="PanelUI.showSubView('appMenu-libraryView', this, null, event);"
+                     closemenu="none"
+                     label="&places.library.title;">
+        <box class="toolbarbutton-animatable-box">
+          <image class="toolbarbutton-animatable-image"/>
+        </box>
+      </toolbarbutton>
+#endif
+    </toolbarpalette>
+  </toolbox>
+
+  <hbox id="fullscr-toggler" hidden="true"/>
+
+  <deck id="content-deck" flex="1">
+    <hbox flex="1" id="browser">
+      <vbox id="browser-border-start" hidden="true" layer="true"/>
+      <vbox id="sidebar-box" hidden="true" class="chromeclass-extrachrome">
+        <sidebarheader id="sidebar-header" align="center">
+          <toolbarbutton id="sidebar-switcher-target" flex="1" class="tabbable">
+            <image id="sidebar-icon" consumeanchor="sidebar-switcher-target"/>
+            <label id="sidebar-title" persist="value" crop="end" flex="1" control="sidebar"/>
+            <image id="sidebar-switcher-arrow"/>
+          </toolbarbutton>
+          <image id="sidebar-throbber"/>
+# To ensure the button label's intrinsic width doesn't expand the sidebar
+# if the label is long, the button needs flex=1.
+# To ensure the button doesn't expand unnecessarily for short labels, the
+# spacer should significantly out-flex the button.
+          <spacer flex="1000"/>
+          <toolbarbutton id="sidebar-close" class="tabbable" tooltiptext="&sidebarCloseButton.tooltip;" oncommand="SidebarUI.hide();"/>
+        </sidebarheader>
+        <browser id="sidebar" flex="1" autoscroll="false" disablehistory="true" disablefullscreen="true"
+                  style="min-width: 14em; width: 18em; max-width: 36em;" tooltip="aHTMLTooltip"/>
+      </vbox>
+
+      <splitter id="sidebar-splitter" class="chromeclass-extrachrome sidebar-splitter" hidden="true"/>
+      <vbox id="appcontent" flex="1">
+        <notificationbox id="high-priority-global-notificationbox" notificationside="top"/>
+        <tabbrowser id="content"
+                    flex="1" contenttooltip="aHTMLTooltip"
+                    tabcontainer="tabbrowser-tabs"
+                    contentcontextmenu="contentAreaContextMenu"
+                    autocompletepopup="PopupAutoComplete"
+                    selectmenulist="ContentSelectDropdown"
+                    datetimepicker="DateTimePickerPanel"/>
+      </vbox>
+      <vbox id="browser-border-end" hidden="true" layer="true"/>
+    </hbox>
+#include ../../components/customizableui/content/customizeMode.inc.xul
+  </deck>
+
+  <html:div id="fullscreen-warning" class="pointerlockfswarning" hidden="true">
+    <html:div class="pointerlockfswarning-domain-text">
+      &fullscreenWarning.beforeDomain.label;
+      <html:span class="pointerlockfswarning-domain"/>
+      &fullscreenWarning.afterDomain.label;
+    </html:div>
+    <html:div class="pointerlockfswarning-generic-text">
+      &fullscreenWarning.generic.label;
+    </html:div>
+    <html:button id="fullscreen-exit-button"
+                 onclick="FullScreen.exitDomFullScreen();">
+#ifdef XP_MACOSX
+            &exitDOMFullscreenMac.button;
+#else
+            &exitDOMFullscreen.button;
+#endif
+    </html:button>
+  </html:div>
+
+  <html:div id="pointerlock-warning" class="pointerlockfswarning" hidden="true">
+    <html:div class="pointerlockfswarning-domain-text">
+      &pointerlockWarning.beforeDomain.label;
+      <html:span class="pointerlockfswarning-domain"/>
+      &pointerlockWarning.afterDomain.label;
+    </html:div>
+    <html:div class="pointerlockfswarning-generic-text">
+      &pointerlockWarning.generic.label;
+    </html:div>
+  </html:div>
+
+  <vbox id="browser-bottombox" layer="true">
+    <notificationbox id="global-notificationbox" notificationside="bottom"/>
+  </vbox>
+
+  <svg:svg height="0">
+#include tab-shape.inc.svg
+#ifndef MOZ_PHOTON_THEME
+    <svg:clipPath id="urlbar-back-button-clip-path">
+#ifndef XP_MACOSX
+      <svg:path d="M -9,-4 l 0,1 a 15 15 0 0,1 0,30 l 0,1 l 10000,0 l 0,-32 l -10000,0 z" />
+#else
+      <svg:path d="M -11,-5 a 16 16 0 0 1 0,34 l 10000,0 l 0,-34 l -10000,0 z"/>
+#endif
+    </svg:clipPath>
+#ifdef XP_WIN
+    <svg:clipPath id="urlbar-back-button-clip-path-win10">
+      <svg:path d="M -6,-2 l 0,1 a 15 15 0 0,1 0,30 l 0,1 l 10000,0 l 0,-32 l -10000,0 z" />
+    </svg:clipPath>
+#endif
+#endif
+  </svg:svg>
+
+</vbox>
+# <iframe id="tab-view"> is dynamically appended as the 2nd child of #tab-view-deck.
+#     Introducing the iframe dynamically, as needed, was found to be better than
+#     starting with an empty iframe here in browser.xul from a Ts standpoint.
+</deck>
+
+</window>
diff --git a/browser/base/content/browser-menubar.inc b/browser/base/content/browser-menubar.inc
index a18dc2b89617..7afbd8d1b337 100644
--- a/browser/base/content/browser-menubar.inc
+++ b/browser/base/content/browser-menubar.inc
@@ -5,7 +5,11 @@
 
        <menubar id="main-menubar"
                 onpopupshowing="if (event.target.parentNode.parentNode == this &amp;&amp;
+#ifdef MOZ_WIDGET_GTK
+                                    document.documentElement.getAttribute('shellshowingmenubar') != 'true')
+#else
                                     !('@mozilla.org/widget/nativemenuservice;1' in Cc))
+#endif
                                   this.setAttribute('openedwithkey',
                                                     event.target.parentNode.openedWithKey);"
                 style="border:0px;padding:0px;margin:0px;-moz-appearance:none">
diff --git a/browser/base/content/browser.js b/browser/base/content/browser.js
index d55882ba5028..ae9a7fb25e65 100755
--- a/browser/base/content/browser.js
+++ b/browser/base/content/browser.js
@@ -5357,6 +5357,8 @@ function getTogglableToolbars() {
   let toolbarNodes = Array.slice(gNavToolbox.childNodes);
   toolbarNodes = toolbarNodes.concat(gNavToolbox.externalToolbars);
   toolbarNodes = toolbarNodes.filter(node => node.getAttribute("toolbarname"));
+  if (document.documentElement.getAttribute("shellshowingmenubar") == "true")
+    toolbarNodes = toolbarNodes.filter(node => node.id != "toolbar-menubar");
   return toolbarNodes;
 }
 
diff --git a/browser/base/jar.mn b/browser/base/jar.mn
index ce46eaf6d392..b9ee0712859a 100644
--- a/browser/base/jar.mn
+++ b/browser/base/jar.mn
@@ -57,6 +57,8 @@ browser.jar:
 *       content/browser/browser.css                   (content/browser.css)
         content/browser/browser.js                    (content/browser.js)
 *       content/browser/browser.xul                   (content/browser.xul)
+*       content/browser/browser-kde.xul               (content/browser-kde.xul)
+%       override chrome://browser/content/browser.xul chrome://browser/content/browser-kde.xul desktop=kde
         content/browser/browser-addons.js             (content/browser-addons.js)
         content/browser/browser-captivePortal.js      (content/browser-captivePortal.js)
         content/browser/browser-ctrlTab.js            (content/browser-ctrlTab.js)
diff --git a/browser/components/build/nsModule.cpp b/browser/components/build/nsModule.cpp
index ef0da3dddcf5..5e72b39eb650 100644
--- a/browser/components/build/nsModule.cpp
+++ b/browser/components/build/nsModule.cpp
@@ -13,7 +13,7 @@
 #elif defined(XP_MACOSX)
 #include "nsMacShellService.h"
 #elif defined(MOZ_WIDGET_GTK)
-#include "nsGNOMEShellService.h"
+#include "nsUnixShellService.h"
 #endif
 
 #if defined(XP_WIN)
@@ -36,8 +36,6 @@ NS_GENERIC_FACTORY_CONSTRUCTOR(DirectoryProvider)
 NS_GENERIC_FACTORY_CONSTRUCTOR(nsWindowsShellService)
 #elif defined(XP_MACOSX)
 NS_GENERIC_FACTORY_CONSTRUCTOR(nsMacShellService)
-#elif defined(MOZ_WIDGET_GTK)
-NS_GENERIC_FACTORY_CONSTRUCTOR_INIT(nsGNOMEShellService, Init)
 #endif
 
 #if defined(XP_WIN)
@@ -65,7 +63,7 @@ static const mozilla::Module::CIDEntry kBrowserCIDs[] = {
 #if defined(XP_WIN)
     { &kNS_SHELLSERVICE_CID, false, nullptr, nsWindowsShellServiceConstructor },
 #elif defined(MOZ_WIDGET_GTK)
-    { &kNS_SHELLSERVICE_CID, false, nullptr, nsGNOMEShellServiceConstructor },
+    { &kNS_SHELLSERVICE_CID, false, nullptr, nsUnixShellServiceConstructor },
 #endif
     { &kNS_FEEDSNIFFER_CID, false, nullptr, nsFeedSnifferConstructor },
     { &kNS_BROWSER_ABOUT_REDIRECTOR_CID, false, nullptr, AboutRedirector::Create },
diff --git a/browser/components/places/content/places.xul b/browser/components/places/content/places.xul
index 24e18b607a0b..793aae929a7e 100644
--- a/browser/components/places/content/places.xul
+++ b/browser/components/places/content/places.xul
@@ -155,7 +155,7 @@
         <toolbarbutton type="menu" class="tabbable"
               onpopupshowing="document.getElementById('placeContent').focus()"
 #else
-      <menubar id="placesMenu">
+      <menubar id="placesMenu" _moz-menubarkeeplocal="true">
         <menu accesskey="&organize.accesskey;" class="menu-iconic"
 #endif
               id="organizeButton" label="&organize.label;"
diff --git a/browser/components/preferences/in-content/main.js b/browser/components/preferences/in-content/main.js
index c1e2e15fdb26..7e41c722d5c3 100644
--- a/browser/components/preferences/in-content/main.js
+++ b/browser/components/preferences/in-content/main.js
@@ -46,6 +46,13 @@ var gMainPane = {
       }
     }
 
+    var env = Components.classes["@mozilla.org/process/environment;1"]
+      .getService(Components.interfaces.nsIEnvironment);
+    var kde_session = 0;
+    if (env.get('KDE_FULL_SESSION') == "true") {
+      kde_session = 1;
+    }
+
     this.buildContentProcessCountMenuList();
     this.updateDefaultPerformanceSettingsPref();
 
@@ -918,6 +925,17 @@ var gMainPane = {
         return;
       try {
         shellSvc.setDefaultBrowser(true, false);
+        if (kde_session == 1) {
+          var shellObj = Components.classes["@mozilla.org/file/local;1"]
+            .createInstance(Components.interfaces.nsILocalFile);
+          shellObj.initWithPath("/usr/bin/kwriteconfig");
+          var process = Components.classes["@mozilla.org/process/util;1"]
+            .createInstance(Components.interfaces.nsIProcess);
+          process.init(shellObj);
+          var args = ["--file", "kdeglobals", "--group", "General", "--key",
+              "BrowserApplication", "waterfox"];
+          process.run(false, args, args.length);
+        }
       } catch (ex) {
         Cu.reportError(ex);
         return;
diff --git a/browser/components/shell/moz.build b/browser/components/shell/moz.build
index d4a234b4a069..97689cb0d882 100644
--- a/browser/components/shell/moz.build
+++ b/browser/components/shell/moz.build
@@ -43,6 +43,8 @@ elif CONFIG['MOZ_WIDGET_TOOLKIT'] == 'cocoa':
 elif 'gtk' in CONFIG['MOZ_WIDGET_TOOLKIT']:
     SOURCES += [
         'nsGNOMEShellService.cpp',
+        'nsKDEShellService.cpp',
+        'nsUnixShellService.cpp',
     ]
 
 if SOURCES:
diff --git a/browser/components/shell/nsKDEShellService.cpp b/browser/components/shell/nsKDEShellService.cpp
new file mode 100644
index 000000000000..11ae6c709841
--- /dev/null
+++ b/browser/components/shell/nsKDEShellService.cpp
@@ -0,0 +1,203 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/ArrayUtils.h"
+
+#include "nsCOMPtr.h"
+#include "nsKDEShellService.h"
+#include "nsShellService.h"
+#include "nsKDEUtils.h"
+#include "nsIPrefService.h"
+#include "nsIProcess.h"
+#include "nsIFile.h"
+#include "nsServiceManagerUtils.h"
+#include "nsComponentManagerUtils.h"
+#include "nsIMutableArray.h"
+#include "nsISupportsPrimitives.h"
+#include "nsArrayUtils.h"
+
+using namespace mozilla;
+
+nsresult
+nsKDEShellService::Init()
+{
+    if( !nsKDEUtils::kdeSupport())
+        return NS_ERROR_NOT_AVAILABLE;
+    return NS_OK;
+}
+
+NS_IMPL_ISUPPORTS(nsKDEShellService, nsIGNOMEShellService, nsIShellService)
+
+NS_IMETHODIMP
+nsKDEShellService::IsDefaultBrowser(bool aStartupCheck,
+                                    bool aForAllTypes,
+                                    bool* aIsDefaultBrowser)
+{
+    *aIsDefaultBrowser = false;
+    if (aStartupCheck)
+        mCheckedThisSession = true;
+
+    nsCOMPtr<nsIMutableArray> command = do_CreateInstance( NS_ARRAY_CONTRACTID );
+    if (!command)
+        return NS_ERROR_FAILURE;
+
+    nsCOMPtr<nsISupportsCString> str = do_CreateInstance( NS_SUPPORTS_CSTRING_CONTRACTID );
+    if (!str)
+        return NS_ERROR_FAILURE;
+
+    str->SetData( NS_LITERAL_CSTRING( "ISDEFAULTBROWSER" ));
+    command->AppendElement( str, false );
+
+    if( nsKDEUtils::command( command ))
+        *aIsDefaultBrowser = true;
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsKDEShellService::SetDefaultBrowser(bool aClaimAllTypes,
+                                     bool aForAllUsers)
+{
+    nsCOMPtr<nsIMutableArray> command = do_CreateInstance( NS_ARRAY_CONTRACTID );
+    if (!command)
+        return NS_ERROR_FAILURE;
+
+    nsCOMPtr<nsISupportsCString> cmdstr = do_CreateInstance( NS_SUPPORTS_CSTRING_CONTRACTID );
+    nsCOMPtr<nsISupportsCString> paramstr = do_CreateInstance( NS_SUPPORTS_CSTRING_CONTRACTID );
+    if (!cmdstr || !paramstr)
+        return NS_ERROR_FAILURE;
+
+    cmdstr->SetData( NS_LITERAL_CSTRING( "SETDEFAULTBROWSER" ));
+    command->AppendElement( cmdstr, false );
+
+    paramstr->SetData( aClaimAllTypes ? NS_LITERAL_CSTRING( "ALLTYPES" ) : NS_LITERAL_CSTRING( "NORMAL" ));
+    command->AppendElement( paramstr, false );
+
+    return nsKDEUtils::command( command ) ? NS_OK : NS_ERROR_FAILURE;
+}
+
+NS_IMETHODIMP
+nsKDEShellService::GetCanSetDesktopBackground(bool* aResult)
+{
+  *aResult = true;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsKDEShellService::SetDesktopBackground(nsIDOMElement* aElement,
+                                          PRInt32 aPosition)
+{
+    return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+nsKDEShellService::GetDesktopBackgroundColor(PRUint32 *aColor)
+{
+    return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+nsKDEShellService::SetDesktopBackgroundColor(PRUint32 aColor)
+{
+    return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+nsKDEShellService::OpenApplication(PRInt32 aApplication)
+{
+    nsCOMPtr<nsIMutableArray> command = do_CreateInstance( NS_ARRAY_CONTRACTID );
+    if (!command)
+        return NS_ERROR_FAILURE;
+
+    nsCOMPtr<nsISupportsCString> str = do_CreateInstance( NS_SUPPORTS_CSTRING_CONTRACTID );
+    if (!str)
+        return NS_ERROR_FAILURE;
+
+    if( aApplication == APPLICATION_MAIL )
+        str->SetData( NS_LITERAL_CSTRING( "OPENMAIL" ));
+    else if( aApplication == APPLICATION_NEWS )
+        str->SetData( NS_LITERAL_CSTRING( "OPENNEWS" ));
+    else
+        return NS_ERROR_NOT_IMPLEMENTED;
+
+    command->AppendElement( str, false );
+    return nsKDEUtils::command( command ) ? NS_OK : NS_ERROR_FAILURE;
+}
+
+NS_IMETHODIMP
+nsKDEShellService::OpenApplicationWithURI(nsIFile* aApplication, const nsACString& aURI)
+{
+    nsCOMPtr<nsIMutableArray> command = do_CreateInstance( NS_ARRAY_CONTRACTID );
+    if (!command)
+        return NS_ERROR_FAILURE;
+
+    nsCOMPtr<nsISupportsCString> cmdstr = do_CreateInstance( NS_SUPPORTS_CSTRING_CONTRACTID );
+    nsCOMPtr<nsISupportsCString> appstr = do_CreateInstance( NS_SUPPORTS_CSTRING_CONTRACTID );
+    nsCOMPtr<nsISupportsCString> uristr = do_CreateInstance( NS_SUPPORTS_CSTRING_CONTRACTID );
+    if (!cmdstr || !appstr || !uristr)
+        return NS_ERROR_FAILURE;
+
+    cmdstr->SetData( NS_LITERAL_CSTRING( "RUN" ));
+    command->AppendElement( cmdstr, false );
+    nsAutoCString app;
+    nsresult rv = aApplication->GetNativePath( app );
+    NS_ENSURE_SUCCESS( rv, rv );
+    appstr->SetData( app );
+    command->AppendElement( appstr, false );
+    uristr->SetData( aURI );
+    command->AppendElement( uristr, false );
+    return nsKDEUtils::command( command ) ? NS_OK : NS_ERROR_FAILURE;
+}
+
+NS_IMETHODIMP
+nsKDEShellService::GetDefaultFeedReader(nsIFile** _retval)
+{
+    *_retval = nullptr;
+
+    nsCOMPtr<nsIMutableArray> command = do_CreateInstance( NS_ARRAY_CONTRACTID );
+    if( !command )
+        return NS_ERROR_FAILURE;
+
+    nsCOMPtr<nsISupportsCString> str = do_CreateInstance( NS_SUPPORTS_CSTRING_CONTRACTID );
+    if( !str )
+        return NS_ERROR_FAILURE;
+
+    str->SetData( NS_LITERAL_CSTRING( "GETDEFAULTFEEDREADER" ));
+    command->AppendElement( str, false );
+
+    nsCOMPtr<nsIArray> output;
+    if( !nsKDEUtils::command( command, getter_AddRefs( output ) ) )
+        return NS_ERROR_FAILURE;
+
+    PRUint32 length;
+    output->GetLength( &length );
+    if( length != 1 )
+        return NS_ERROR_FAILURE;
+
+    nsCOMPtr<nsISupportsCString> resstr = do_QueryElementAt( output, 0 );
+    if( !resstr )
+        return NS_ERROR_FAILURE;
+
+    nsAutoCString path;
+    resstr->GetData( path );
+    if (path.IsEmpty())
+        return NS_ERROR_FAILURE;
+
+    nsresult rv;
+    nsCOMPtr<nsIFile> defaultReader =
+        do_CreateInstance("@mozilla.org/file/local;1", &rv);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    rv = defaultReader->InitWithNativePath(path);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    bool exists;
+    rv = defaultReader->Exists(&exists);
+    NS_ENSURE_SUCCESS(rv, rv);
+    if (!exists)
+        return NS_ERROR_FAILURE;
+
+    NS_ADDREF(*_retval = defaultReader);
+    return NS_OK;
+}
diff --git a/browser/components/shell/nsKDEShellService.h b/browser/components/shell/nsKDEShellService.h
new file mode 100644
index 000000000000..8baad7d98ea8
--- /dev/null
+++ b/browser/components/shell/nsKDEShellService.h
@@ -0,0 +1,30 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef nskdeshellservice_h____
+#define nskdeshellservice_h____
+
+#include "nsIGNOMEShellService.h"
+#include "nsString.h"
+#include "mozilla/Attributes.h"
+
+class nsKDEShellService final : public nsIGNOMEShellService
+{
+public:
+  nsKDEShellService() : mCheckedThisSession(false) { }
+
+  NS_DECL_ISUPPORTS
+  NS_DECL_NSIGNOMESHELLSERVICE
+  NS_DECL_NSISHELLSERVICE
+
+  nsresult Init();
+
+private:
+  ~nsKDEShellService() {}
+
+  bool mCheckedThisSession;
+};
+
+#endif // nskdeshellservice_h____
diff --git a/browser/components/shell/nsUnixShellService.cpp b/browser/components/shell/nsUnixShellService.cpp
new file mode 100644
index 000000000000..a6827209d9e7
--- /dev/null
+++ b/browser/components/shell/nsUnixShellService.cpp
@@ -0,0 +1,22 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+
+#include "nsUnixShellService.h"
+#include "nsGNOMEShellService.h"
+#include "nsKDEShellService.h"
+#include "nsKDEUtils.h"
+#include "mozilla/ModuleUtils.h"
+
+NS_GENERIC_FACTORY_CONSTRUCTOR_INIT(nsGNOMEShellService, Init)
+NS_GENERIC_FACTORY_CONSTRUCTOR_INIT(nsKDEShellService, Init)
+
+NS_IMETHODIMP
+nsUnixShellServiceConstructor(nsISupports *aOuter, REFNSIID aIID, void **aResult)
+{
+    if( nsKDEUtils::kdeSupport())
+        return nsKDEShellServiceConstructor( aOuter, aIID, aResult );
+    return nsGNOMEShellServiceConstructor( aOuter, aIID, aResult );
+}
diff --git a/browser/components/shell/nsUnixShellService.h b/browser/components/shell/nsUnixShellService.h
new file mode 100644
index 000000000000..26b5dbac47dd
--- /dev/null
+++ b/browser/components/shell/nsUnixShellService.h
@@ -0,0 +1,15 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+
+#ifndef nsunixshellservice_h____
+#define nsunixshellservice_h____
+
+#include "nsIGNOMEShellService.h"
+
+NS_IMETHODIMP
+nsUnixShellServiceConstructor(nsISupports *aOuter, REFNSIID aIID, void **aResult);
+
+#endif // nsunixshellservice_h____
diff --git a/browser/installer/package-manifest.in b/browser/installer/package-manifest.in
index dce74878c3ef..3baac7d39b57 100644
--- a/browser/installer/package-manifest.in
+++ b/browser/installer/package-manifest.in
@@ -669,6 +669,8 @@
 ; gre location for now.
 @RESPATH@/defaults/pref/channel-prefs.js
 
+@BINPATH@/defaults/pref/kde.js
+
 ; Remote control protocol prefs
 ; defined in ../../testing/marionette/prefs/marionette.js
 @RESPATH@/defaults/pref/marionette.js
diff --git a/layout/build/moz.build b/layout/build/moz.build
index 3ed745263093..1fe66323c906 100644
--- a/layout/build/moz.build
+++ b/layout/build/moz.build
@@ -74,6 +74,10 @@ elif CONFIG['MOZ_WIDGET_TOOLKIT'] == 'android':
         '/dom/system',
         '/dom/system/android',
     ]
+elif 'gtk' in CONFIG['MOZ_WIDGET_TOOLKIT']:
+    LOCAL_INCLUDES += [
+        '/widget/gtk',
+    ]
 
 if CONFIG['MOZ_WEBSPEECH']:
     LOCAL_INCLUDES += [
diff --git a/layout/build/nsLayoutStatics.cpp b/layout/build/nsLayoutStatics.cpp
index ded58ef04e0a..f207dc66ad23 100644
--- a/layout/build/nsLayoutStatics.cpp
+++ b/layout/build/nsLayoutStatics.cpp
@@ -126,6 +126,10 @@
 #include "mozilla/dom/ipc/IPCBlobInputStreamStorage.h"
 #include "mozilla/dom/U2FTokenManager.h"
 
+#ifdef MOZ_WIDGET_GTK
+#include "nsNativeMenuAtoms.h"
+#endif
+
 using namespace mozilla;
 using namespace mozilla::net;
 using namespace mozilla::dom;
@@ -158,6 +162,9 @@ nsLayoutStatics::Initialize()
   nsTextServicesDocument::RegisterAtoms();
   nsHTMLTags::RegisterAtoms();
   nsRDFAtoms::RegisterAtoms();
+#ifdef MOZ_WIDGET_GTK
+  nsNativeMenuAtoms::RegisterAtoms();
+#endif
 
   NS_SealStaticAtomTable();
 
diff --git a/modules/libpref/Preferences.cpp b/modules/libpref/Preferences.cpp
index 4b9ef83c1559..96e0d09dac85 100644
--- a/modules/libpref/Preferences.cpp
+++ b/modules/libpref/Preferences.cpp
@@ -38,6 +38,7 @@
 #include "nsXPCOMCID.h"
 #include "nsAutoPtr.h"
 #include "nsPrintfCString.h"
+#include "nsKDEUtils.h"
 
 #include "nsQuickSort.h"
 #include "PLDHashTable.h"
@@ -1440,6 +1441,24 @@ static nsresult pref_LoadPrefsInDirList(const char *listId)
   if (NS_FAILED(rv))
     return rv;
 
+  // make sure we load these special files after all the others
+  static const char* specialFiles[] = {
+#if defined(XP_UNIX)
+    ""
+#endif
+  };
+
+  if (nsKDEUtils::kdeSession()) {
+    for(int i = 0;
+        i < MOZ_ARRAY_LENGTH(specialFiles);
+        ++i ) {
+      if (*specialFiles[ i ] == '\0') {
+        specialFiles[ i ] = "kde.js";
+        break;
+      }
+    }
+  }
+
   nsCOMPtr<nsISimpleEnumerator> list;
   dirSvc->Get(listId,
               NS_GET_IID(nsISimpleEnumerator),
@@ -1465,7 +1484,7 @@ static nsresult pref_LoadPrefsInDirList(const char *listId)
     if (Substring(leaf, leaf.Length() - 4).EqualsLiteral(".xpi"))
       ReadExtensionPrefs(path);
     else
-      pref_LoadPrefsInDir(path, nullptr, 0);
+      pref_LoadPrefsInDir(path, specialFiles, MOZ_ARRAY_LENGTH(specialFiles));
   }
   return NS_OK;
 }
@@ -1571,6 +1590,7 @@ pref_InitInitialObjects()
     "winpref.js"
 #elif defined(XP_UNIX)
     "unix.js"
+    , "" // placeholder for KDE  (empty is otherwise harmless)
 #if defined(_AIX)
     , "aix.js"
 #endif
@@ -1579,6 +1599,17 @@ pref_InitInitialObjects()
 #endif
   };
 
+  if(nsKDEUtils::kdeSession()) { // TODO what if some setup actually requires the helper?
+    for(int i = 0;
+        i < MOZ_ARRAY_LENGTH(specialFiles);
+        ++i ) {
+      if( *specialFiles[ i ] == '\0' ) {
+        specialFiles[ i ] = "kde.js";
+        break;
+      }
+    }
+  }
+
   rv = pref_LoadPrefsInDir(defaultPrefDir, specialFiles, ArrayLength(specialFiles));
   if (NS_FAILED(rv))
     NS_WARNING("Error parsing application default preferences.");
diff --git a/modules/libpref/init/all.js b/modules/libpref/init/all.js
index 4874c0309dab..9888cefd85ef 100644
--- a/modules/libpref/init/all.js
+++ b/modules/libpref/init/all.js
@@ -251,6 +251,9 @@ pref("dom.script_loader.bytecode_cache.strategy", 0);
 pref("browser.sessionhistory.max_total_viewers", -1);
 
 pref("ui.use_native_colors", true);
+#ifdef MOZ_WIDGET_GTK
+pref("ui.use_unity_menubar", true);
+#endif
 pref("ui.click_hold_context_menus", false);
 // Duration of timeout of incremental search in menus (ms).  0 means infinite.
 pref("ui.menu.incremental_search.timeout", 1000);
diff --git a/modules/libpref/moz.build b/modules/libpref/moz.build
index 5696929c6035..59333b99828f 100644
--- a/modules/libpref/moz.build
+++ b/modules/libpref/moz.build
@@ -38,6 +38,10 @@ UNIFIED_SOURCES += [
     'prefread.cpp',
 ]
 
+LOCAL_INCLUDES += [
+     '/toolkit/xre'
+]
+
 include('/ipc/chromium/chromium-config.mozbuild')
 
 FINAL_LIBRARY = 'xul'
diff --git a/python/mozbuild/mozpack/chrome/flags.py b/python/mozbuild/mozpack/chrome/flags.py
index 62aabcd3e71d..d937be879081 100644
--- a/python/mozbuild/mozpack/chrome/flags.py
+++ b/python/mozbuild/mozpack/chrome/flags.py
@@ -225,6 +225,7 @@ class Flags(OrderedDict):
         'xpcnativewrappers': Flag,
         'tablet': Flag,
         'process': StringFlag,
+        'desktop': StringFlag,
     }
     RE = re.compile(r'([!<>=]+)')
 
diff --git a/python/mozbuild/mozpack/chrome/manifest.py b/python/mozbuild/mozpack/chrome/manifest.py
index 5c5b51f9949c..31a9f54b9260 100644
--- a/python/mozbuild/mozpack/chrome/manifest.py
+++ b/python/mozbuild/mozpack/chrome/manifest.py
@@ -39,6 +39,7 @@ class ManifestEntry(object):
         'tablet',
         'process',
         'contentaccessible',
+        'desktop',
     ]
 
     def __init__(self, base, *flags):
diff --git a/toolkit/components/downloads/moz.build b/toolkit/components/downloads/moz.build
index 1621564c24cf..69d490fd19a2 100644
--- a/toolkit/components/downloads/moz.build
+++ b/toolkit/components/downloads/moz.build
@@ -42,6 +42,7 @@ FINAL_LIBRARY = 'xul'
 LOCAL_INCLUDES += [
     '../protobuf',
     '/ipc/chromium/src',
+    '/toolkit/xre',
     'chromium'
 ]
 
diff --git a/toolkit/content/jar.mn b/toolkit/content/jar.mn
index d724bd084d9a..ca5595c87ae1 100644
--- a/toolkit/content/jar.mn
+++ b/toolkit/content/jar.mn
@@ -80,6 +80,8 @@ toolkit.jar:
    content/global/bindings/datetimebox.xml     (widgets/datetimebox.xml)
    content/global/bindings/datetimebox.css     (widgets/datetimebox.css)
 *  content/global/bindings/dialog.xml          (widgets/dialog.xml)
+*  content/global/bindings/dialog-kde.xml      (widgets/dialog-kde.xml)
+% override chrome://global/content/bindings/dialog.xml chrome://global/content/bindings/dialog-kde.xml desktop=kde
    content/global/bindings/editor.xml          (widgets/editor.xml)
    content/global/bindings/expander.xml        (widgets/expander.xml)
    content/global/bindings/filefield.xml       (widgets/filefield.xml)
@@ -93,6 +95,8 @@ toolkit.jar:
    content/global/bindings/numberbox.xml       (widgets/numberbox.xml)
    content/global/bindings/popup.xml           (widgets/popup.xml)
 *  content/global/bindings/preferences.xml     (widgets/preferences.xml)
+*  content/global/bindings/preferences-kde.xml (widgets/preferences-kde.xml)
+% override chrome://global/content/bindings/preferences.xml chrome://global/content/bindings/preferences-kde.xml desktop=kde
    content/global/bindings/progressmeter.xml   (widgets/progressmeter.xml)
    content/global/bindings/radio.xml           (widgets/radio.xml)
    content/global/bindings/remote-browser.xml  (widgets/remote-browser.xml)
diff --git a/toolkit/content/widgets/dialog-kde.xml b/toolkit/content/widgets/dialog-kde.xml
new file mode 100644
index 000000000000..d7e1a80c4f5c
--- /dev/null
+++ b/toolkit/content/widgets/dialog-kde.xml
@@ -0,0 +1,455 @@
+<?xml version="1.0"?>
+<!-- This Source Code Form is subject to the terms of the Mozilla Public
+   - License, v. 2.0. If a copy of the MPL was not distributed with this
+   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->
+
+
+<bindings id="dialogBindings"
+          xmlns="http://www.mozilla.org/xbl"
+          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
+          xmlns:xbl="http://www.mozilla.org/xbl">
+
+  <binding id="dialog" extends="chrome://global/content/bindings/general.xml#root-element">
+    <resources>
+      <stylesheet src="chrome://global/skin/dialog.css"/>
+    </resources>
+    <content>
+      <xul:vbox class="box-inherit dialog-content-box" flex="1">
+        <children/>
+      </xul:vbox>
+
+      <xul:hbox class="dialog-button-box" anonid="buttons"
+                xbl:inherits="pack=buttonpack,align=buttonalign,dir=buttondir,orient=buttonorient"
+#ifdef XP_UNIX_GNOME
+                >
+        <xul:button dlgtype="disclosure" class="dialog-button" hidden="true"/>
+        <xul:button dlgtype="help" class="dialog-button" hidden="true"/>
+        <xul:button dlgtype="extra2" class="dialog-button" hidden="true"/>
+        <xul:button dlgtype="extra1" class="dialog-button" hidden="true"/>
+        <xul:spacer anonid="spacer" flex="1"/>
+        <xul:button dlgtype="cancel" class="dialog-button"/>
+        <xul:button dlgtype="accept" class="dialog-button" xbl:inherits="disabled=buttondisabledaccept"/>
+#elif XP_UNIX
+                >
+        <xul:button dlgtype="help" class="dialog-button" hidden="true"/>
+        <xul:button dlgtype="extra2" class="dialog-button" hidden="true"/>
+        <xul:spacer anonid="spacer" flex="1"/>
+        <xul:button dlgtype="accept" class="dialog-button" xbl:inherits="disabled=buttondisabledaccept"/>
+        <xul:button dlgtype="extra1" class="dialog-button" hidden="true"/>
+        <xul:button dlgtype="cancel" class="dialog-button"/>
+        <xul:button dlgtype="disclosure" class="dialog-button" hidden="true"/>
+#else
+                pack="end">
+        <xul:button dlgtype="extra2" class="dialog-button" hidden="true"/>
+        <xul:spacer anonid="spacer" flex="1" hidden="true"/>
+        <xul:button dlgtype="accept" class="dialog-button" xbl:inherits="disabled=buttondisabledaccept"/>
+        <xul:button dlgtype="extra1" class="dialog-button" hidden="true"/>
+        <xul:button dlgtype="cancel" class="dialog-button"/>
+        <xul:button dlgtype="help" class="dialog-button" hidden="true"/>
+        <xul:button dlgtype="disclosure" class="dialog-button" hidden="true"/>
+#endif
+      </xul:hbox>
+    </content>
+
+    <implementation>
+      <field name="_mStrBundle">null</field>
+      <field name="_closeHandler">(function(event) {
+        if (!document.documentElement.cancelDialog())
+          event.preventDefault();
+      })</field>
+
+      <property name="buttons"
+                onget="return this.getAttribute('buttons');"
+                onset="this._configureButtons(val); return val;"/>
+
+      <property name="defaultButton">
+        <getter>
+        <![CDATA[
+          if (this.hasAttribute("defaultButton"))
+            return this.getAttribute("defaultButton");
+          return "accept";  // default to the accept button
+        ]]>
+        </getter>
+        <setter>
+        <![CDATA[
+          this._setDefaultButton(val);
+          return val;
+        ]]>
+        </setter>
+      </property>
+
+      <method name="acceptDialog">
+        <body>
+        <![CDATA[
+          return this._doButtonCommand("accept");
+        ]]>
+        </body>
+      </method>
+
+      <method name="cancelDialog">
+        <body>
+        <![CDATA[
+          return this._doButtonCommand("cancel");
+        ]]>
+        </body>
+      </method>
+
+      <method name="getButton">
+        <parameter name="aDlgType"/>
+        <body>
+        <![CDATA[
+          return this._buttons[aDlgType];
+        ]]>
+        </body>
+      </method>
+
+      <method name="moveToAlertPosition">
+        <body>
+        <![CDATA[
+          // hack. we need this so the window has something like its final size
+          if (window.outerWidth == 1) {
+            dump("Trying to position a sizeless window; caller should have called sizeToContent() or sizeTo(). See bug 75649.\n");
+            sizeToContent();
+          }
+
+          if (opener) {
+            var xOffset = (opener.outerWidth - window.outerWidth) / 2;
+            var yOffset = opener.outerHeight / 5;
+
+            var newX = opener.screenX + xOffset;
+            var newY = opener.screenY + yOffset;
+          } else {
+            newX = (screen.availWidth - window.outerWidth) / 2;
+            newY = (screen.availHeight - window.outerHeight) / 2;
+          }
+
+          // ensure the window is fully onscreen (if smaller than the screen)
+          if (newX < screen.availLeft)
+            newX = screen.availLeft + 20;
+          if ((newX + window.outerWidth) > (screen.availLeft + screen.availWidth))
+            newX = (screen.availLeft + screen.availWidth) - window.outerWidth - 20;
+
+          if (newY < screen.availTop)
+            newY = screen.availTop + 20;
+          if ((newY + window.outerHeight) > (screen.availTop + screen.availHeight))
+            newY = (screen.availTop + screen.availHeight) - window.outerHeight - 60;
+
+          window.moveTo( newX, newY );
+        ]]>
+        </body>
+      </method>
+
+      <method name="centerWindowOnScreen">
+        <body>
+        <![CDATA[
+          var xOffset = screen.availWidth / 2 - window.outerWidth / 2;
+          var yOffset = screen.availHeight / 2 - window.outerHeight / 2;
+
+          xOffset = xOffset > 0 ? xOffset : 0;
+          yOffset = yOffset > 0 ? yOffset : 0;
+          window.moveTo(xOffset, yOffset);
+        ]]>
+        </body>
+      </method>
+
+      <constructor>
+      <![CDATA[
+        this._configureButtons(this.buttons);
+
+        // listen for when window is closed via native close buttons
+        window.addEventListener("close", this._closeHandler);
+
+        // for things that we need to initialize after onload fires
+        window.addEventListener("load", this.postLoadInit);
+
+        window.moveToAlertPosition = this.moveToAlertPosition;
+        window.centerWindowOnScreen = this.centerWindowOnScreen;
+      ]]>
+      </constructor>
+
+      <method name="postLoadInit">
+        <parameter name="aEvent"/>
+        <body>
+        <![CDATA[
+          function focusInit() {
+            const dialog = document.documentElement;
+            const defaultButton = dialog.getButton(dialog.defaultButton);
+            // give focus to the first focusable element in the dialog
+            if (!document.commandDispatcher.focusedElement) {
+              document.commandDispatcher.advanceFocusIntoSubtree(dialog);
+
+              var focusedElt = document.commandDispatcher.focusedElement;
+              if (focusedElt) {
+                var initialFocusedElt = focusedElt;
+                while (focusedElt.localName == "tab" ||
+                       focusedElt.getAttribute("noinitialfocus") == "true") {
+                  document.commandDispatcher.advanceFocusIntoSubtree(focusedElt);
+                  focusedElt = document.commandDispatcher.focusedElement;
+                  if (focusedElt == initialFocusedElt)
+                    break;
+                }
+
+                if (initialFocusedElt.localName == "tab") {
+                  if (focusedElt.hasAttribute("dlgtype")) {
+                    // We don't want to focus on anonymous OK, Cancel, etc. buttons,
+                    // so return focus to the tab itself
+                    initialFocusedElt.focus();
+                  }
+                } else if (!/Mac/.test(navigator.platform) &&
+                           focusedElt.hasAttribute("dlgtype") && focusedElt != defaultButton) {
+                  defaultButton.focus();
+                }
+              }
+            }
+
+            try {
+              if (defaultButton)
+                window.notifyDefaultButtonLoaded(defaultButton);
+            } catch (e) { }
+          }
+
+          // Give focus after onload completes, see bug 103197.
+          setTimeout(focusInit, 0);
+        ]]>
+        </body>
+      </method>
+
+      <property name="mStrBundle">
+        <getter>
+        <![CDATA[
+          if (!this._mStrBundle) {
+            // need to create string bundle manually instead of using <xul:stringbundle/>
+            // see bug 63370 for details
+            this._mStrBundle = Components.classes["@mozilla.org/intl/stringbundle;1"]
+                                         .getService(Components.interfaces.nsIStringBundleService)
+                                         .createBundle("chrome://global/locale/dialog.properties");
+          }
+          return this._mStrBundle;
+        ]]></getter>
+      </property>
+
+      <method name="_configureButtons">
+        <parameter name="aButtons"/>
+        <body>
+        <![CDATA[
+          // by default, get all the anonymous button elements
+          var buttons = {};
+          this._buttons = buttons;
+          buttons.accept = document.getAnonymousElementByAttribute(this, "dlgtype", "accept");
+          buttons.cancel = document.getAnonymousElementByAttribute(this, "dlgtype", "cancel");
+          buttons.extra1 = document.getAnonymousElementByAttribute(this, "dlgtype", "extra1");
+          buttons.extra2 = document.getAnonymousElementByAttribute(this, "dlgtype", "extra2");
+          buttons.help = document.getAnonymousElementByAttribute(this, "dlgtype", "help");
+          buttons.disclosure = document.getAnonymousElementByAttribute(this, "dlgtype", "disclosure");
+
+          // look for any overriding explicit button elements
+          var exBtns = this.getElementsByAttribute("dlgtype", "*");
+          var dlgtype;
+          var i;
+          for (i = 0; i < exBtns.length; ++i) {
+            dlgtype = exBtns[i].getAttribute("dlgtype");
+            buttons[dlgtype].hidden = true; // hide the anonymous button
+            buttons[dlgtype] = exBtns[i];
+          }
+
+          // add the label and oncommand handler to each button
+          for (dlgtype in buttons) {
+            var button = buttons[dlgtype];
+            button.addEventListener("command", this._handleButtonCommand, true);
+
+            // don't override custom labels with pre-defined labels on explicit buttons
+            if (!button.hasAttribute("label")) {
+              // dialog attributes override the default labels in dialog.properties
+              if (this.hasAttribute("buttonlabel" + dlgtype)) {
+                button.setAttribute("label", this.getAttribute("buttonlabel" + dlgtype));
+                if (this.hasAttribute("buttonaccesskey" + dlgtype))
+                  button.setAttribute("accesskey", this.getAttribute("buttonaccesskey" + dlgtype));
+              } else if (dlgtype != "extra1" && dlgtype != "extra2") {
+                button.setAttribute("label", this.mStrBundle.GetStringFromName("button-" + dlgtype));
+                var accessKey = this.mStrBundle.GetStringFromName("accesskey-" + dlgtype);
+                if (accessKey)
+                  button.setAttribute("accesskey", accessKey);
+              }
+            }
+            // allow specifying alternate icons in the dialog header
+            if (!button.hasAttribute("icon")) {
+              // if there's an icon specified, use that
+              if (this.hasAttribute("buttonicon" + dlgtype))
+                button.setAttribute("icon", this.getAttribute("buttonicon" + dlgtype));
+              // otherwise set defaults
+              else
+                switch (dlgtype) {
+                  case "accept":
+                    button.setAttribute("icon", "accept");
+                    break;
+                  case "cancel":
+                    button.setAttribute("icon", "cancel");
+                    break;
+                  case "disclosure":
+                    button.setAttribute("icon", "properties");
+                    break;
+                  case "help":
+                    button.setAttribute("icon", "help");
+                    break;
+                  default:
+                    break;
+                }
+            }
+          }
+
+          // ensure that hitting enter triggers the default button command
+          this.defaultButton = this.defaultButton;
+
+          // if there is a special button configuration, use it
+          if (aButtons) {
+            // expect a comma delimited list of dlgtype values
+            var list = aButtons.split(",");
+
+            // mark shown dlgtypes as true
+            var shown = { accept: false, cancel: false, help: false,
+                          disclosure: false, extra1: false, extra2: false };
+            for (i = 0; i < list.length; ++i)
+              shown[list[i].replace(/ /g, "")] = true;
+
+            // hide/show the buttons we want
+            for (dlgtype in buttons)
+              buttons[dlgtype].hidden = !shown[dlgtype];
+
+            // show the spacer on Windows only when the extra2 button is present
+            if (/Win/.test(navigator.platform)) {
+              var spacer = document.getAnonymousElementByAttribute(this, "anonid", "spacer");
+              spacer.removeAttribute("hidden");
+              spacer.setAttribute("flex", shown["extra2"] ? "1" : "0");
+            }
+          }
+        ]]>
+        </body>
+      </method>
+
+      <method name="_setDefaultButton">
+        <parameter name="aNewDefault"/>
+        <body>
+        <![CDATA[
+          // remove the default attribute from the previous default button, if any
+          var oldDefaultButton = this.getButton(this.defaultButton);
+          if (oldDefaultButton)
+            oldDefaultButton.removeAttribute("default");
+
+          var newDefaultButton = this.getButton(aNewDefault);
+          if (newDefaultButton) {
+            this.setAttribute("defaultButton", aNewDefault);
+            newDefaultButton.setAttribute("default", "true");
+          } else {
+            this.setAttribute("defaultButton", "none");
+            if (aNewDefault != "none")
+              dump("invalid new default button: " + aNewDefault + ", assuming: none\n");
+          }
+        ]]>
+        </body>
+      </method>
+
+      <method name="_handleButtonCommand">
+        <parameter name="aEvent"/>
+        <body>
+        <![CDATA[
+          return document.documentElement._doButtonCommand(
+                                        aEvent.target.getAttribute("dlgtype"));
+        ]]>
+        </body>
+      </method>
+
+      <method name="_doButtonCommand">
+        <parameter name="aDlgType"/>
+        <body>
+        <![CDATA[
+          var button = this.getButton(aDlgType);
+          if (!button.disabled) {
+            var noCancel = this._fireButtonEvent(aDlgType);
+            if (noCancel) {
+              if (aDlgType == "accept" || aDlgType == "cancel") {
+                var closingEvent = new CustomEvent("dialogclosing", {
+                  bubbles: true,
+                  detail: { button: aDlgType },
+                });
+                this.dispatchEvent(closingEvent);
+                window.close();
+              }
+            }
+            return noCancel;
+          }
+          return true;
+        ]]>
+        </body>
+      </method>
+
+      <method name="_fireButtonEvent">
+        <parameter name="aDlgType"/>
+        <body>
+        <![CDATA[
+          var event = document.createEvent("Events");
+          event.initEvent("dialog" + aDlgType, true, true);
+
+          // handle dom event handlers
+          var noCancel = this.dispatchEvent(event);
+
+          // handle any xml attribute event handlers
+          var handler = this.getAttribute("ondialog" + aDlgType);
+          if (handler != "") {
+            var fn = new Function("event", handler);
+            var returned = fn(event);
+            if (returned == false)
+              noCancel = false;
+          }
+
+          return noCancel;
+        ]]>
+        </body>
+      </method>
+
+      <method name="_hitEnter">
+        <parameter name="evt"/>
+        <body>
+        <![CDATA[
+          if (evt.defaultPrevented)
+            return;
+
+          var btn = this.getButton(this.defaultButton);
+          if (btn)
+            this._doButtonCommand(this.defaultButton);
+        ]]>
+        </body>
+      </method>
+
+    </implementation>
+
+    <handlers>
+      <handler event="keypress" keycode="VK_RETURN"
+               group="system" action="this._hitEnter(event);"/>
+      <handler event="keypress" keycode="VK_ESCAPE" group="system">
+        if (!event.defaultPrevented)
+          this.cancelDialog();
+      </handler>
+#ifdef XP_MACOSX
+      <handler event="keypress" key="." modifiers="meta" phase="capturing" action="this.cancelDialog();"/>
+#else
+      <handler event="focus" phase="capturing">
+        var btn = this.getButton(this.defaultButton);
+        if (btn)
+          btn.setAttribute("default", event.originalTarget == btn || !(event.originalTarget instanceof Components.interfaces.nsIDOMXULButtonElement));
+      </handler>
+#endif
+    </handlers>
+
+  </binding>
+
+  <binding id="dialogheader">
+    <resources>
+      <stylesheet src="chrome://global/skin/dialog.css"/>
+    </resources>
+    <content>
+      <xul:label class="dialogheader-title" xbl:inherits="value=title,crop" crop="right" flex="1"/>
+      <xul:label class="dialogheader-description" xbl:inherits="value=description"/>
+    </content>
+  </binding>
+
+</bindings>
diff --git a/toolkit/content/widgets/popup.xml b/toolkit/content/widgets/popup.xml
index 94d013e2c0ef..a071f9908148 100644
--- a/toolkit/content/widgets/popup.xml
+++ b/toolkit/content/widgets/popup.xml
@@ -27,8 +27,14 @@
         </getter>
       </property>
 
-      <property name="state" readonly="true"
-                onget="return this.popupBoxObject.popupState"/>
+      <property name="state" readonly="true">
+        <getter><![CDATA[
+          if (this.hasAttribute('_moz-nativemenupopupstate'))
+            return this.getAttribute('_moz-nativemenupopupstate');
+          else
+            return this.popupBoxObject.popupState;
+        ]]></getter>
+      </property>
 
       <property name="triggerNode" readonly="true"
                 onget="return this.popupBoxObject.triggerNode"/>
diff --git a/toolkit/content/widgets/preferences-kde.xml b/toolkit/content/widgets/preferences-kde.xml
new file mode 100644
index 000000000000..85684fbeae8e
--- /dev/null
+++ b/toolkit/content/widgets/preferences-kde.xml
@@ -0,0 +1,1409 @@
+<?xml version="1.0"?>
+
+<!DOCTYPE bindings [
+  <!ENTITY % preferencesDTD SYSTEM "chrome://global/locale/preferences.dtd">
+  %preferencesDTD;
+  <!ENTITY % globalKeysDTD SYSTEM "chrome://global/locale/globalKeys.dtd">
+  %globalKeysDTD;
+]>
+
+<bindings id="preferencesBindings"
+          xmlns="http://www.mozilla.org/xbl"
+          xmlns:xbl="http://www.mozilla.org/xbl"
+          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">
+
+#
+# = Preferences Window Framework
+#
+#   The syntax for use looks something like:
+#
+#   <prefwindow>
+#     <prefpane id="prefPaneA">
+#       <preferences>
+#         <preference id="preference1" name="app.preference1" type="bool" onchange="foo();"/>
+#         <preference id="preference2" name="app.preference2" type="bool" useDefault="true"/>
+#       </preferences>
+#       <checkbox label="Preference" preference="preference1"/>
+#     </prefpane>
+#   </prefwindow>
+#
+
+  <binding id="preferences">
+    <implementation implements="nsIObserver">
+      <method name="_constructAfterChildren">
+      <body>
+      <![CDATA[
+      // This method will be called after the last of the child
+      // <preference> elements is constructed. Its purpose is to propagate
+      // the values to the associated form elements. Sometimes the code for
+      // some <preference> initializers depend on other <preference> elements
+      // being initialized so we wait and call updateElements on all of them
+      // once the last one has been constructed. See bugs 997570 and 992185.
+
+      var elements = this.getElementsByTagName("preference");
+      for (let element of elements) {
+        element.updateElements();
+      }
+
+      this._constructAfterChildrenCalled = true;
+      ]]>
+      </body>
+      </method>
+      <method name="observe">
+        <parameter name="aSubject"/>
+        <parameter name="aTopic"/>
+        <parameter name="aData"/>
+        <body>
+        <![CDATA[
+          for (var i = 0; i < this.childNodes.length; ++i) {
+            var preference = this.childNodes[i];
+            if (preference.name == aData) {
+              preference.value = preference.valueFromPreferences;
+            }
+          }
+        ]]>
+        </body>
+      </method>
+
+      <method name="fireChangedEvent">
+        <parameter name="aPreference"/>
+        <body>
+        <![CDATA[
+          // Value changed, synthesize an event
+          try {
+            var event = document.createEvent("Events");
+            event.initEvent("change", true, true);
+            aPreference.dispatchEvent(event);
+          } catch (e) {
+            Components.utils.reportError(e);
+          }
+        ]]>
+        </body>
+      </method>
+
+      <field name="service">
+        Components.classes["@mozilla.org/preferences-service;1"]
+                  .getService(Components.interfaces.nsIPrefService);
+      </field>
+      <field name="rootBranch">
+        Components.classes["@mozilla.org/preferences-service;1"]
+                  .getService(Components.interfaces.nsIPrefBranch);
+      </field>
+      <field name="defaultBranch">
+        this.service.getDefaultBranch("");
+      </field>
+      <field name="rootBranchInternal">
+        Components.classes["@mozilla.org/preferences-service;1"]
+                  .getService(Components.interfaces.nsIPrefBranchInternal);
+      </field>
+      <property name="type" readonly="true">
+        <getter>
+          <![CDATA[
+            return document.documentElement.type || "";
+          ]]>
+        </getter>
+      </property>
+      <property name="instantApply" readonly="true">
+        <getter>
+          <![CDATA[
+            var doc = document.documentElement;
+            return this.type == "child" ? doc.instantApply
+                                        : doc.instantApply || this.rootBranch.getBoolPref("browser.preferences.instantApply");
+          ]]>
+        </getter>
+      </property>
+
+      <!-- We want to call _constructAfterChildren after all child
+           <preference> elements have been constructed. To do this, we get
+           and store the node list of all child <preference> elements in the
+           constructor, and maintain a count which is incremented in the
+           constructor of <preference>. _constructAfterChildren is called
+           when the count matches the length of the list. -->
+      <field name="_constructedChildrenCount">0</field>
+      <field name="_preferenceChildren">null</field>
+      <!-- Some <preference> elements are added dynamically after
+           _constructAfterChildren has already been called - we want to
+           avoid looping over all of them again in this case so we remember
+           if we already called it. -->
+      <field name="_constructAfterChildrenCalled">false</field>
+      <constructor>
+      <![CDATA[
+        this._preferenceChildren = this.getElementsByTagName("preference");
+      ]]>
+      </constructor>
+    </implementation>
+  </binding>
+
+  <binding id="preference">
+    <implementation>
+      <constructor>
+      <![CDATA[
+        // if the element has been inserted without the name attribute set,
+        // we have nothing to do here
+        if (!this.name)
+          return;
+
+        this.preferences.rootBranchInternal
+            .addObserver(this.name, this.preferences);
+        // In non-instant apply mode, we must try and use the last saved state
+        // from any previous opens of a child dialog instead of the value from
+        // preferences, to pick up any edits a user may have made.
+
+        var secMan = Components.classes["@mozilla.org/scriptsecuritymanager;1"]
+                    .getService(Components.interfaces.nsIScriptSecurityManager);
+        if (this.preferences.type == "child" &&
+            !this.instantApply && window.opener &&
+            secMan.isSystemPrincipal(window.opener.document.nodePrincipal)) {
+          var pdoc = window.opener.document;
+
+          // Try to find a preference element for the same preference.
+          var preference = null;
+          var parentPreferences = pdoc.getElementsByTagName("preferences");
+          for (var k = 0; (k < parentPreferences.length && !preference); ++k) {
+            var parentPrefs = parentPreferences[k]
+                                    .getElementsByAttribute("name", this.name);
+            for (var l = 0; (l < parentPrefs.length && !preference); ++l) {
+              if (parentPrefs[l].localName == "preference")
+                preference = parentPrefs[l];
+            }
+          }
+
+          // Don't use the value setter here, we don't want updateElements to be prematurely fired.
+          this._value = preference ? preference.value : this.valueFromPreferences;
+        } else {
+          this._value = this.valueFromPreferences;
+        }
+        if (this.preferences._constructAfterChildrenCalled) {
+          // This <preference> was added after _constructAfterChildren() was already called.
+          // We can directly call updateElements().
+          this.updateElements();
+          return;
+        }
+        this.preferences._constructedChildrenCount++;
+        if (this.preferences._constructedChildrenCount ==
+            this.preferences._preferenceChildren.length) {
+          // This is the last <preference>, time to updateElements() on all of them.
+          this.preferences._constructAfterChildren();
+        }
+      ]]>
+      </constructor>
+      <destructor>
+        this.preferences.rootBranchInternal
+            .removeObserver(this.name, this.preferences);
+      </destructor>
+      <field name="_constructed">false</field>
+      <property name="instantApply">
+        <getter>
+          if (this.getAttribute("instantApply") == "false")
+            return false;
+          return this.getAttribute("instantApply") == "true" || this.preferences.instantApply;
+        </getter>
+      </property>
+
+      <property name="preferences" onget="return this.parentNode"/>
+      <property name="name" onget="return this.getAttribute('name');">
+        <setter>
+          if (val == this.name)
+            return val;
+
+          this.preferences.rootBranchInternal
+              .removeObserver(this.name, this.preferences);
+          this.setAttribute("name", val);
+          this.preferences.rootBranchInternal
+              .addObserver(val, this.preferences);
+
+          return val;
+        </setter>
+      </property>
+      <property name="type" onget="return this.getAttribute('type');"
+                            onset="this.setAttribute('type', val); return val;"/>
+      <property name="inverted" onget="return this.getAttribute('inverted') == 'true';"
+                                onset="this.setAttribute('inverted', val); return val;"/>
+      <property name="readonly" onget="return this.getAttribute('readonly') == 'true';"
+                                onset="this.setAttribute('readonly', val); return val;"/>
+
+      <field name="_value">null</field>
+      <method name="_setValue">
+        <parameter name="aValue"/>
+        <body>
+        <![CDATA[
+          if (this.value !== aValue) {
+            this._value = aValue;
+            if (this.instantApply)
+              this.valueFromPreferences = aValue;
+            this.preferences.fireChangedEvent(this);
+          }
+          return aValue;
+        ]]>
+        </body>
+      </method>
+      <property name="value" onget="return this._value" onset="return this._setValue(val);"/>
+
+      <property name="locked">
+        <getter>
+          return this.preferences.rootBranch.prefIsLocked(this.name);
+        </getter>
+      </property>
+
+      <property name="disabled">
+        <getter>
+          return this.getAttribute("disabled") == "true";
+        </getter>
+        <setter>
+        <![CDATA[
+          if (val)
+            this.setAttribute("disabled", "true");
+          else
+            this.removeAttribute("disabled");
+
+          if (!this.id)
+            return val;
+
+          var elements = document.getElementsByAttribute("preference", this.id);
+          for (var i = 0; i < elements.length; ++i) {
+            elements[i].disabled = val;
+
+            var labels = document.getElementsByAttribute("control", elements[i].id);
+            for (var j = 0; j < labels.length; ++j)
+              labels[j].disabled = val;
+          }
+
+          return val;
+        ]]>
+        </setter>
+      </property>
+
+      <property name="tabIndex">
+        <getter>
+          return parseInt(this.getAttribute("tabindex"));
+        </getter>
+        <setter>
+        <![CDATA[
+          if (val)
+            this.setAttribute("tabindex", val);
+          else
+            this.removeAttribute("tabindex");
+
+          if (!this.id)
+            return val;
+
+          var elements = document.getElementsByAttribute("preference", this.id);
+          for (var i = 0; i < elements.length; ++i) {
+            elements[i].tabIndex = val;
+
+            var labels = document.getElementsByAttribute("control", elements[i].id);
+            for (var j = 0; j < labels.length; ++j)
+              labels[j].tabIndex = val;
+          }
+
+          return val;
+        ]]>
+        </setter>
+      </property>
+
+      <property name="hasUserValue">
+        <getter>
+        <![CDATA[
+          return this.preferences.rootBranch.prefHasUserValue(this.name) &&
+                 this.value !== undefined;
+        ]]>
+        </getter>
+      </property>
+
+      <method name="reset">
+        <body>
+          // defer reset until preference update
+          this.value = undefined;
+        </body>
+      </method>
+
+      <field name="_useDefault">false</field>
+      <property name="defaultValue">
+        <getter>
+        <![CDATA[
+          this._useDefault = true;
+          var val = this.valueFromPreferences;
+          this._useDefault = false;
+          return val;
+        ]]>
+        </getter>
+      </property>
+
+      <property name="_branch">
+        <getter>
+          return this._useDefault ? this.preferences.defaultBranch : this.preferences.rootBranch;
+        </getter>
+      </property>
+
+      <field name="batching">false</field>
+
+      <method name="_reportUnknownType">
+        <body>
+        <![CDATA[
+          var consoleService = Components.classes["@mozilla.org/consoleservice;1"]
+                                         .getService(Components.interfaces.nsIConsoleService);
+          var msg = "<preference> with id='" + this.id + "' and name='" +
+                    this.name + "' has unknown type '" + this.type + "'.";
+          consoleService.logStringMessage(msg);
+        ]]>
+        </body>
+      </method>
+
+      <property name="valueFromPreferences">
+        <getter>
+        <![CDATA[
+          try {
+            // Force a resync of value with preferences.
+            switch (this.type) {
+            case "int":
+              return this._branch.getIntPref(this.name);
+            case "bool":
+              var val = this._branch.getBoolPref(this.name);
+              return this.inverted ? !val : val;
+            case "wstring":
+              return this._branch
+                         .getComplexValue(this.name, Components.interfaces.nsIPrefLocalizedString)
+                         .data;
+            case "string":
+            case "unichar":
+              return this._branch.getStringPref(this.name);
+            case "fontname":
+              var family = this._branch.getStringPref(this.name);
+              var fontEnumerator = Components.classes["@mozilla.org/gfx/fontenumerator;1"]
+                                             .createInstance(Components.interfaces.nsIFontEnumerator);
+              return fontEnumerator.getStandardFamilyName(family);
+            case "file":
+              var f = this._branch
+                          .getComplexValue(this.name, Components.interfaces.nsILocalFile);
+              return f;
+            default:
+              this._reportUnknownType();
+            }
+          } catch (e) { }
+          return null;
+        ]]>
+        </getter>
+        <setter>
+        <![CDATA[
+          // Exit early if nothing to do.
+          if (this.readonly || this.valueFromPreferences == val)
+            return val;
+
+          // The special value undefined means 'reset preference to default'.
+          if (val === undefined) {
+            this.preferences.rootBranch.clearUserPref(this.name);
+            return val;
+          }
+
+          // Force a resync of preferences with value.
+          switch (this.type) {
+          case "int":
+            this.preferences.rootBranch.setIntPref(this.name, val);
+            break;
+          case "bool":
+            this.preferences.rootBranch.setBoolPref(this.name, this.inverted ? !val : val);
+            break;
+          case "wstring":
+            var pls = Components.classes["@mozilla.org/pref-localizedstring;1"]
+                                .createInstance(Components.interfaces.nsIPrefLocalizedString);
+            pls.data = val;
+            this.preferences.rootBranch
+                .setComplexValue(this.name, Components.interfaces.nsIPrefLocalizedString, pls);
+            break;
+          case "string":
+          case "unichar":
+          case "fontname":
+            this.preferences.rootBranch.setStringPref(this.name, val);
+            break;
+          case "file":
+            var lf;
+            if (typeof(val) == "string") {
+              lf = Components.classes["@mozilla.org/file/local;1"]
+                             .createInstance(Components.interfaces.nsILocalFile);
+              lf.persistentDescriptor = val;
+              if (!lf.exists())
+                lf.initWithPath(val);
+            } else
+              lf = val.QueryInterface(Components.interfaces.nsILocalFile);
+            this.preferences.rootBranch
+                .setComplexValue(this.name, Components.interfaces.nsILocalFile, lf);
+            break;
+          default:
+            this._reportUnknownType();
+          }
+          if (!this.batching)
+            this.preferences.service.savePrefFile(null);
+          return val;
+        ]]>
+        </setter>
+      </property>
+
+      <method name="setElementValue">
+        <parameter name="aElement"/>
+        <body>
+        <![CDATA[
+          if (this.locked)
+            aElement.disabled = true;
+
+          if (!this.isElementEditable(aElement))
+            return;
+
+          var rv = undefined;
+          if (aElement.hasAttribute("onsyncfrompreference")) {
+            // Value changed, synthesize an event
+            try {
+              var event = document.createEvent("Events");
+              event.initEvent("syncfrompreference", true, true);
+              var f = new Function("event",
+                                   aElement.getAttribute("onsyncfrompreference"));
+              rv = f.call(aElement, event);
+            } catch (e) {
+              Components.utils.reportError(e);
+            }
+          }
+          var val = rv;
+          if (val === undefined)
+            val = this.instantApply ? this.valueFromPreferences : this.value;
+          // if the preference is marked for reset, show default value in UI
+          if (val === undefined)
+            val = this.defaultValue;
+
+          /**
+           * Initialize a UI element property with a value. Handles the case
+           * where an element has not yet had a XBL binding attached for it and
+           * the property setter does not yet exist by setting the same attribute
+           * on the XUL element using DOM apis and assuming the element's
+           * constructor or property getters appropriately handle this state.
+           */
+          function setValue(element, attribute, value) {
+            if (attribute in element)
+              element[attribute] = value;
+            else
+              element.setAttribute(attribute, value);
+          }
+          if (aElement.localName == "checkbox" ||
+              aElement.localName == "listitem")
+            setValue(aElement, "checked", val);
+          else if (aElement.localName == "colorpicker")
+            setValue(aElement, "color", val);
+          else if (aElement.localName == "textbox") {
+            // XXXmano Bug 303998: Avoid a caret placement issue if either the
+            // preference observer or its setter calls updateElements as a result
+            // of the input event handler.
+            if (aElement.value !== val)
+              setValue(aElement, "value", val);
+          } else
+            setValue(aElement, "value", val);
+        ]]>
+        </body>
+      </method>
+
+      <method name="getElementValue">
+        <parameter name="aElement"/>
+        <body>
+        <![CDATA[
+          if (aElement.hasAttribute("onsynctopreference")) {
+            // Value changed, synthesize an event
+            try {
+              var event = document.createEvent("Events");
+              event.initEvent("synctopreference", true, true);
+              var f = new Function("event",
+                                   aElement.getAttribute("onsynctopreference"));
+              var rv = f.call(aElement, event);
+              if (rv !== undefined)
+                return rv;
+            } catch (e) {
+              Components.utils.reportError(e);
+            }
+          }
+
+          /**
+           * Read the value of an attribute from an element, assuming the
+           * attribute is a property on the element's node API. If the property
+           * is not present in the API, then assume its value is contained in
+           * an attribute, as is the case before a binding has been attached.
+           */
+          function getValue(element, attribute) {
+            if (attribute in element)
+              return element[attribute];
+            return element.getAttribute(attribute);
+          }
+          if (aElement.localName == "checkbox" ||
+              aElement.localName == "listitem")
+            var value = getValue(aElement, "checked");
+          else if (aElement.localName == "colorpicker")
+            value = getValue(aElement, "color");
+          else
+            value = getValue(aElement, "value");
+
+          switch (this.type) {
+          case "int":
+            return parseInt(value, 10) || 0;
+          case "bool":
+            return typeof(value) == "boolean" ? value : value == "true";
+          }
+          return value;
+        ]]>
+        </body>
+      </method>
+
+      <method name="isElementEditable">
+        <parameter name="aElement"/>
+        <body>
+        <![CDATA[
+          switch (aElement.localName) {
+          case "checkbox":
+          case "colorpicker":
+          case "radiogroup":
+          case "textbox":
+          case "listitem":
+          case "listbox":
+          case "menulist":
+            return true;
+          }
+          return aElement.getAttribute("preference-editable") == "true";
+        ]]>
+        </body>
+      </method>
+
+      <method name="updateElements">
+        <body>
+        <![CDATA[
+          if (!this.id)
+            return;
+
+          // This "change" event handler tracks changes made to preferences by
+          // sources other than the user in this window.
+          var elements = document.getElementsByAttribute("preference", this.id);
+          for (var i = 0; i < elements.length; ++i)
+            this.setElementValue(elements[i]);
+        ]]>
+        </body>
+      </method>
+    </implementation>
+
+    <handlers>
+      <handler event="change">
+        this.updateElements();
+      </handler>
+    </handlers>
+  </binding>
+
+  <binding id="prefwindow"
+           extends="chrome://global/content/bindings/dialog.xml#dialog">
+    <resources>
+      <stylesheet src="chrome://global/skin/preferences.css"/>
+    </resources>
+    <content dlgbuttons="accept,cancel" persist="lastSelected screenX screenY"
+             closebuttonlabel="&preferencesCloseButton.label;"
+             closebuttonaccesskey="&preferencesCloseButton.accesskey;"
+             role="dialog"
+#ifdef XP_WIN
+             title="&preferencesDefaultTitleWin.title;">
+#else
+             title="&preferencesDefaultTitleMac.title;">
+#endif
+      <xul:windowdragbox orient="vertical">
+        <xul:radiogroup anonid="selector" orient="horizontal" class="paneSelector chromeclass-toolbar"
+                        role="listbox"/> <!-- Expose to accessibility APIs as a listbox -->
+      </xul:windowdragbox>
+      <xul:hbox flex="1" class="paneDeckContainer">
+        <xul:deck anonid="paneDeck" flex="1">
+          <children includes="prefpane"/>
+        </xul:deck>
+      </xul:hbox>
+      <xul:hbox anonid="dlg-buttons" class="prefWindow-dlgbuttons" pack="end">
+#ifndef XP_UNIX
+        <xul:button dlgtype="disclosure" class="dialog-button" hidden="true"/>
+        <xul:button dlgtype="help" class="dialog-button" hidden="true" icon="help"/>
+        <xul:button dlgtype="extra2" class="dialog-button" hidden="true"/>
+        <xul:button dlgtype="extra1" class="dialog-button" hidden="true"/>
+        <xul:spacer anonid="spacer" flex="1"/>
+        <xul:button dlgtype="cancel" class="dialog-button" icon="cancel"/>
+        <xul:button dlgtype="accept" class="dialog-button" icon="accept"/>
+#else
+        <xul:button dlgtype="extra2" class="dialog-button" hidden="true"/>
+        <xul:spacer anonid="spacer" flex="1"/>
+        <xul:button dlgtype="accept" class="dialog-button" icon="accept"/>
+        <xul:button dlgtype="extra1" class="dialog-button" hidden="true"/>
+        <xul:button dlgtype="cancel" class="dialog-button" icon="cancel"/>
+        <xul:button dlgtype="help" class="dialog-button" hidden="true" icon="help"/>
+        <xul:button dlgtype="disclosure" class="dialog-button" hidden="true"/>
+#endif
+      </xul:hbox>
+      <xul:hbox>
+        <children/>
+      </xul:hbox>
+    </content>
+    <implementation implements="nsITimerCallback">
+      <constructor>
+      <![CDATA[
+        if (this.type != "child") {
+          if (!this._instantApplyInitialized) {
+            let psvc = Components.classes["@mozilla.org/preferences-service;1"]
+                                 .getService(Components.interfaces.nsIPrefBranch);
+            this.instantApply = psvc.getBoolPref("browser.preferences.instantApply");
+          }
+          if (this.instantApply) {
+            var docElt = document.documentElement;
+            var acceptButton = docElt.getButton("accept");
+            acceptButton.hidden = true;
+            var cancelButton  = docElt.getButton("cancel");
+            if (/Mac/.test(navigator.platform)) {
+              // no buttons on Mac except Help
+              cancelButton.hidden = true;
+              // Move Help button to the end
+              document.getAnonymousElementByAttribute(this, "anonid", "spacer").hidden = true;
+              // Also, don't fire onDialogAccept on enter
+              acceptButton.disabled = true;
+            } else {
+              // morph the Cancel button into the Close button
+              cancelButton.setAttribute("icon", "close");
+              cancelButton.label = docElt.getAttribute("closebuttonlabel");
+              cancelButton.accesskey = docElt.getAttribute("closebuttonaccesskey");
+            }
+          }
+        }
+        this.setAttribute("animated", this._shouldAnimate ? "true" : "false");
+        var panes = this.preferencePanes;
+
+        var lastPane = null;
+        if (this.lastSelected) {
+          lastPane = document.getElementById(this.lastSelected);
+          if (!lastPane) {
+            this.lastSelected = "";
+          }
+        }
+
+        var paneToLoad;
+        if ("arguments" in window && window.arguments[0] && document.getElementById(window.arguments[0]) && document.getElementById(window.arguments[0]).nodeName == "prefpane") {
+          paneToLoad = document.getElementById(window.arguments[0]);
+          this.lastSelected = paneToLoad.id;
+        } else if (lastPane)
+          paneToLoad = lastPane;
+        else
+          paneToLoad = panes[0];
+
+        for (var i = 0; i < panes.length; ++i) {
+          this._makePaneButton(panes[i]);
+          if (panes[i].loaded) {
+            // Inline pane content, fire load event to force initialization.
+            this._fireEvent("paneload", panes[i]);
+          }
+        }
+        this.showPane(paneToLoad);
+
+        if (panes.length == 1)
+          this._selector.setAttribute("collapsed", "true");
+      ]]>
+      </constructor>
+
+      <destructor>
+      <![CDATA[
+        // Release timers to avoid reference cycles.
+        if (this._animateTimer) {
+          this._animateTimer.cancel();
+          this._animateTimer = null;
+        }
+        if (this._fadeTimer) {
+          this._fadeTimer.cancel();
+          this._fadeTimer = null;
+        }
+      ]]>
+      </destructor>
+
+      <!-- Derived bindings can set this to true to cause us to skip
+           reading the browser.preferences.instantApply pref in the constructor.
+           Then they can set instantApply to their wished value. -->
+      <field name="_instantApplyInitialized">false</field>
+      <!-- Controls whether changed pref values take effect immediately. -->
+      <field name="instantApply">false</field>
+
+      <property name="preferencePanes"
+                onget="return this.getElementsByTagName('prefpane');"/>
+
+      <property name="type" onget="return this.getAttribute('type');"/>
+      <property name="_paneDeck"
+                onget="return document.getAnonymousElementByAttribute(this, 'anonid', 'paneDeck');"/>
+      <property name="_paneDeckContainer"
+                onget="return document.getAnonymousElementByAttribute(this, 'class', 'paneDeckContainer');"/>
+      <property name="_selector"
+                onget="return document.getAnonymousElementByAttribute(this, 'anonid', 'selector');"/>
+      <property name="lastSelected"
+                onget="return this.getAttribute('lastSelected');">
+        <setter>
+          this.setAttribute("lastSelected", val);
+          document.persist(this.id, "lastSelected");
+          return val;
+        </setter>
+      </property>
+      <property name="currentPane"
+                onset="return this._currentPane = val;">
+        <getter>
+          if (!this._currentPane)
+            this._currentPane = this.preferencePanes[0];
+
+          return this._currentPane;
+        </getter>
+      </property>
+      <field name="_currentPane">null</field>
+
+
+      <method name="_makePaneButton">
+        <parameter name="aPaneElement"/>
+        <body>
+        <![CDATA[
+          var radio = document.createElement("radio");
+          radio.setAttribute("pane", aPaneElement.id);
+          radio.setAttribute("label", aPaneElement.label);
+          // Expose preference group choice to accessibility APIs as an unchecked list item
+          // The parent group is exposed to accessibility APIs as a list
+          if (aPaneElement.image)
+            radio.setAttribute("src", aPaneElement.image);
+          radio.style.listStyleImage = aPaneElement.style.listStyleImage;
+          this._selector.appendChild(radio);
+          return radio;
+        ]]>
+        </body>
+      </method>
+
+      <method name="showPane">
+        <parameter name="aPaneElement"/>
+        <body>
+        <![CDATA[
+          if (!aPaneElement)
+            return;
+
+          this._selector.selectedItem = document.getAnonymousElementByAttribute(this, "pane", aPaneElement.id);
+          if (!aPaneElement.loaded) {
+            let OverlayLoadObserver = function(aPane) {
+              this._pane = aPane;
+            }
+            OverlayLoadObserver.prototype = {
+              _outer: this,
+              observe(aSubject, aTopic, aData) {
+                this._pane.loaded = true;
+                this._outer._fireEvent("paneload", this._pane);
+                this._outer._selectPane(this._pane);
+              }
+            };
+
+            var obs = new OverlayLoadObserver(aPaneElement);
+            document.loadOverlay(aPaneElement.src, obs);
+          } else
+            this._selectPane(aPaneElement);
+        ]]>
+        </body>
+      </method>
+
+      <method name="_fireEvent">
+        <parameter name="aEventName"/>
+        <parameter name="aTarget"/>
+        <body>
+        <![CDATA[
+          // Panel loaded, synthesize a load event.
+          try {
+            var event = document.createEvent("Events");
+            event.initEvent(aEventName, true, true);
+            var cancel = !aTarget.dispatchEvent(event);
+            if (aTarget.hasAttribute("on" + aEventName)) {
+              var fn = new Function("event", aTarget.getAttribute("on" + aEventName));
+              var rv = fn.call(aTarget, event);
+              if (rv == false)
+                cancel = true;
+            }
+            return !cancel;
+          } catch (e) {
+            Components.utils.reportError(e);
+          }
+          return false;
+        ]]>
+        </body>
+      </method>
+
+      <field name="_initialized">false</field>
+      <method name="_selectPane">
+        <parameter name="aPaneElement"/>
+        <body>
+        <![CDATA[
+          if (/Mac/.test(navigator.platform)) {
+            var paneTitle = aPaneElement.label;
+            if (paneTitle != "")
+              document.title = paneTitle;
+          }
+          var helpButton = document.documentElement.getButton("help");
+          if (aPaneElement.helpTopic)
+            helpButton.hidden = false;
+          else
+            helpButton.hidden = true;
+
+          // Find this pane's index in the deck and set the deck's
+          // selectedIndex to that value to switch to it.
+          var prefpanes = this.preferencePanes;
+          for (var i = 0; i < prefpanes.length; ++i) {
+            if (prefpanes[i] == aPaneElement) {
+              this._paneDeck.selectedIndex = i;
+
+              if (this.type != "child") {
+                if (aPaneElement.hasAttribute("flex") && this._shouldAnimate &&
+                    prefpanes.length > 1)
+                  aPaneElement.removeAttribute("flex");
+                // Calling sizeToContent after the first prefpane is loaded
+                // will size the windows contents so style information is
+                // available to calculate correct sizing.
+                if (!this._initialized && prefpanes.length > 1) {
+                  if (this._shouldAnimate)
+                    this.style.minHeight = 0;
+                  window.sizeToContent();
+                }
+
+                var oldPane = this.lastSelected ? document.getElementById(this.lastSelected) : this.preferencePanes[0];
+                oldPane.selected = !(aPaneElement.selected = true);
+                this.lastSelected = aPaneElement.id;
+                this.currentPane = aPaneElement;
+                this._initialized = true;
+
+                // Only animate if we've switched between prefpanes
+                if (this._shouldAnimate && oldPane.id != aPaneElement.id) {
+                  aPaneElement.style.opacity = 0.0;
+                  this.animate(oldPane, aPaneElement);
+                } else if (!this._shouldAnimate && prefpanes.length > 1) {
+                  var targetHeight = parseInt(window.getComputedStyle(this._paneDeckContainer).height);
+                  var verticalPadding = parseInt(window.getComputedStyle(aPaneElement).paddingTop);
+                  verticalPadding += parseInt(window.getComputedStyle(aPaneElement).paddingBottom);
+                  if (aPaneElement.contentHeight > targetHeight - verticalPadding) {
+                    // To workaround the bottom border of a groupbox from being
+                    // cutoff an hbox with a class of bottomBox may enclose it.
+                    // This needs to include its padding to resize properly.
+                    // See bug 394433
+                    var bottomPadding = 0;
+                    var bottomBox = aPaneElement.getElementsByAttribute("class", "bottomBox")[0];
+                    if (bottomBox)
+                      bottomPadding = parseInt(window.getComputedStyle(bottomBox).paddingBottom);
+                    window.innerHeight += bottomPadding + verticalPadding + aPaneElement.contentHeight - targetHeight;
+                  }
+
+                  // XXX rstrong - extend the contents of the prefpane to
+                  // prevent elements from being cutoff (see bug 349098).
+                  if (aPaneElement.contentHeight + verticalPadding < targetHeight)
+                    aPaneElement._content.style.height = targetHeight - verticalPadding + "px";
+                }
+              }
+              break;
+            }
+          }
+        ]]>
+        </body>
+      </method>
+
+      <property name="_shouldAnimate">
+        <getter>
+        <![CDATA[
+          var psvc = Components.classes["@mozilla.org/preferences-service;1"]
+                               .getService(Components.interfaces.nsIPrefBranch);
+          return psvc.getBoolPref("browser.preferences.animateFadeIn",
+                                  /Mac/.test(navigator.platform));
+        ]]>
+        </getter>
+      </property>
+
+      <method name="animate">
+        <parameter name="aOldPane"/>
+        <parameter name="aNewPane"/>
+        <body>
+        <![CDATA[
+          // if we are already resizing, use currentHeight
+          var oldHeight = this._currentHeight ? this._currentHeight : aOldPane.contentHeight;
+
+          this._multiplier = aNewPane.contentHeight > oldHeight ? 1 : -1;
+          var sizeDelta = Math.abs(oldHeight - aNewPane.contentHeight);
+          this._animateRemainder = sizeDelta % this._animateIncrement;
+
+          this._setUpAnimationTimer(oldHeight);
+        ]]>
+        </body>
+      </method>
+
+      <property name="_sizeIncrement">
+        <getter>
+        <![CDATA[
+          var lastSelectedPane = document.getElementById(this.lastSelected);
+          var increment = this._animateIncrement * this._multiplier;
+          var newHeight = this._currentHeight + increment;
+          if ((this._multiplier > 0 && this._currentHeight >= lastSelectedPane.contentHeight) ||
+              (this._multiplier < 0 && this._currentHeight <= lastSelectedPane.contentHeight))
+            return 0;
+
+          if ((this._multiplier > 0 && newHeight > lastSelectedPane.contentHeight) ||
+              (this._multiplier < 0 && newHeight < lastSelectedPane.contentHeight))
+            increment = this._animateRemainder * this._multiplier;
+          return increment;
+        ]]>
+        </getter>
+      </property>
+
+      <method name="notify">
+        <parameter name="aTimer"/>
+        <body>
+        <![CDATA[
+          if (!document)
+            aTimer.cancel();
+
+          if (aTimer == this._animateTimer) {
+            var increment = this._sizeIncrement;
+            if (increment != 0) {
+              window.innerHeight += increment;
+              this._currentHeight += increment;
+            } else {
+              aTimer.cancel();
+              this._setUpFadeTimer();
+            }
+          } else if (aTimer == this._fadeTimer) {
+            var elt = document.getElementById(this.lastSelected);
+            var newOpacity = parseFloat(window.getComputedStyle(elt).opacity) + this._fadeIncrement;
+            if (newOpacity < 1.0)
+              elt.style.opacity = newOpacity;
+            else {
+              aTimer.cancel();
+              elt.style.opacity = 1.0;
+            }
+          }
+        ]]>
+        </body>
+      </method>
+
+      <method name="_setUpAnimationTimer">
+        <parameter name="aStartHeight"/>
+        <body>
+        <![CDATA[
+          if (!this._animateTimer)
+            this._animateTimer = Components.classes["@mozilla.org/timer;1"]
+                                           .createInstance(Components.interfaces.nsITimer);
+          else
+            this._animateTimer.cancel();
+          this._currentHeight = aStartHeight;
+
+          this._animateTimer.initWithCallback(this, this._animateDelay,
+                                              Components.interfaces.nsITimer.TYPE_REPEATING_SLACK);
+        ]]>
+        </body>
+      </method>
+
+      <method name="_setUpFadeTimer">
+        <body>
+        <![CDATA[
+          if (!this._fadeTimer)
+            this._fadeTimer = Components.classes["@mozilla.org/timer;1"]
+                                        .createInstance(Components.interfaces.nsITimer);
+          else
+            this._fadeTimer.cancel();
+
+          this._fadeTimer.initWithCallback(this, this._fadeDelay,
+                                           Components.interfaces.nsITimer.TYPE_REPEATING_SLACK);
+        ]]>
+        </body>
+      </method>
+
+      <field name="_animateTimer">null</field>
+      <field name="_fadeTimer">null</field>
+      <field name="_animateDelay">15</field>
+      <field name="_animateIncrement">40</field>
+      <field name="_fadeDelay">5</field>
+      <field name="_fadeIncrement">0.40</field>
+      <field name="_animateRemainder">0</field>
+      <field name="_currentHeight">0</field>
+      <field name="_multiplier">0</field>
+
+      <method name="addPane">
+        <parameter name="aPaneElement"/>
+        <body>
+        <![CDATA[
+          this.appendChild(aPaneElement);
+
+          // Set up pane button
+          this._makePaneButton(aPaneElement);
+        ]]>
+        </body>
+      </method>
+
+      <method name="openSubDialog">
+        <parameter name="aURL"/>
+        <parameter name="aFeatures"/>
+        <parameter name="aParams"/>
+        <body>
+          return openDialog(aURL, "", "modal,centerscreen,resizable=no" + (aFeatures != "" ? ("," + aFeatures) : ""), aParams);
+        </body>
+      </method>
+
+      <method name="openWindow">
+        <parameter name="aWindowType"/>
+        <parameter name="aURL"/>
+        <parameter name="aFeatures"/>
+        <parameter name="aParams"/>
+        <body>
+        <![CDATA[
+          var wm = Components.classes["@mozilla.org/appshell/window-mediator;1"]
+                             .getService(Components.interfaces.nsIWindowMediator);
+          var win = aWindowType ? wm.getMostRecentWindow(aWindowType) : null;
+          if (win) {
+            if ("initWithParams" in win)
+              win.initWithParams(aParams);
+            win.focus();
+          } else {
+            var features = "resizable,dialog=no,centerscreen" + (aFeatures != "" ? ("," + aFeatures) : "");
+            var parentWindow = (this.instantApply || !window.opener || window.opener.closed) ? window : window.opener;
+            win = parentWindow.openDialog(aURL, "_blank", features, aParams);
+          }
+          return win;
+        ]]>
+        </body>
+      </method>
+    </implementation>
+    <handlers>
+      <handler event="dialogaccept">
+      <![CDATA[
+        if (!this._fireEvent("beforeaccept", this)) {
+          return false;
+        }
+
+        var secMan = Components.classes["@mozilla.org/scriptsecuritymanager;1"]
+                    .getService(Components.interfaces.nsIScriptSecurityManager);
+        if (this.type == "child" && window.opener &&
+            secMan.isSystemPrincipal(window.opener.document.nodePrincipal)) {
+          var pdocEl = window.opener.document.documentElement;
+          if (pdocEl.instantApply) {
+            let panes = this.preferencePanes;
+            for (let i = 0; i < panes.length; ++i)
+              panes[i].writePreferences(true);
+          } else {
+            // Clone all the preferences elements from the child document and
+            // insert them into the pane collection of the parent.
+            var pdoc = window.opener.document;
+            if (pdoc.documentElement.localName == "prefwindow") {
+              var currentPane = pdoc.documentElement.currentPane;
+              var id = window.location.href + "#childprefs";
+              var childPrefs = pdoc.getElementById(id);
+              if (!childPrefs) {
+                childPrefs = pdoc.createElement("preferences");
+                currentPane.appendChild(childPrefs);
+                childPrefs.id = id;
+              }
+              let panes = this.preferencePanes;
+              for (let i = 0; i < panes.length; ++i) {
+                var preferences = panes[i].preferences;
+                for (var j = 0; j < preferences.length; ++j) {
+                  // Try to find a preference element for the same preference.
+                  var preference = null;
+                  var parentPreferences = pdoc.getElementsByTagName("preferences");
+                  for (var k = 0; (k < parentPreferences.length && !preference); ++k) {
+                    var parentPrefs = parentPreferences[k]
+                                         .getElementsByAttribute("name", preferences[j].name);
+                    for (var l = 0; (l < parentPrefs.length && !preference); ++l) {
+                      if (parentPrefs[l].localName == "preference")
+                        preference = parentPrefs[l];
+                    }
+                  }
+                  if (!preference) {
+                    // No matching preference in the parent window.
+                    preference = pdoc.createElement("preference");
+                    childPrefs.appendChild(preference);
+                    preference.name     = preferences[j].name;
+                    preference.type     = preferences[j].type;
+                    preference.inverted = preferences[j].inverted;
+                    preference.readonly = preferences[j].readonly;
+                    preference.disabled = preferences[j].disabled;
+                  }
+                  preference.value = preferences[j].value;
+                }
+              }
+            }
+          }
+        } else {
+          let panes = this.preferencePanes;
+          for (var i = 0; i < panes.length; ++i)
+            panes[i].writePreferences(false);
+
+          let psvc = Components.classes["@mozilla.org/preferences-service;1"]
+                               .getService(Components.interfaces.nsIPrefService);
+          psvc.savePrefFile(null);
+        }
+
+        return true;
+      ]]>
+      </handler>
+      <handler event="command">
+        if (event.originalTarget.hasAttribute("pane")) {
+          var pane = document.getElementById(event.originalTarget.getAttribute("pane"));
+          this.showPane(pane);
+        }
+      </handler>
+
+      <handler event="keypress" key="&windowClose.key;" modifiers="accel" phase="capturing">
+      <![CDATA[
+        if (this.instantApply)
+          window.close();
+        event.stopPropagation();
+        event.preventDefault();
+      ]]>
+      </handler>
+
+      <handler event="keypress"
+#ifdef XP_MACOSX
+               key="&openHelpMac.commandkey;" modifiers="accel"
+#else
+               keycode="&openHelp.commandkey;"
+#endif
+               phase="capturing">
+      <![CDATA[
+        var helpButton = this.getButton("help");
+        if (helpButton.disabled || helpButton.hidden)
+          return;
+        this._fireEvent("dialoghelp", this);
+        event.stopPropagation();
+        event.preventDefault();
+      ]]>
+      </handler>
+    </handlers>
+  </binding>
+
+  <binding id="prefpane">
+    <resources>
+      <stylesheet src="chrome://global/skin/preferences.css"/>
+    </resources>
+    <content>
+      <xul:vbox class="content-box" xbl:inherits="flex">
+        <children/>
+      </xul:vbox>
+    </content>
+    <implementation>
+      <method name="writePreferences">
+        <parameter name="aFlushToDisk"/>
+        <body>
+        <![CDATA[
+          // Write all values to preferences.
+          if (this._deferredValueUpdateElements.size) {
+            this._finalizeDeferredElements();
+          }
+
+          var preferences = this.preferences;
+          for (var i = 0; i < preferences.length; ++i) {
+            var preference = preferences[i];
+            preference.batching = true;
+            preference.valueFromPreferences = preference.value;
+            preference.batching = false;
+          }
+          if (aFlushToDisk) {
+            var psvc = Components.classes["@mozilla.org/preferences-service;1"]
+                                 .getService(Components.interfaces.nsIPrefService);
+            psvc.savePrefFile(null);
+          }
+        ]]>
+        </body>
+      </method>
+
+      <property name="src"
+                onget="return this.getAttribute('src');"
+                onset="this.setAttribute('src', val); return val;"/>
+      <property name="selected"
+                onget="return this.getAttribute('selected') == 'true';"
+                onset="this.setAttribute('selected', val); return val;"/>
+      <property name="image"
+                onget="return this.getAttribute('image');"
+                onset="this.setAttribute('image', val); return val;"/>
+      <property name="label"
+                onget="return this.getAttribute('label');"
+                onset="this.setAttribute('label', val); return val;"/>
+
+      <property name="preferenceElements"
+                onget="return this.getElementsByAttribute('preference', '*');"/>
+      <property name="preferences"
+                onget="return this.getElementsByTagName('preference');"/>
+
+      <property name="helpTopic">
+        <getter>
+        <![CDATA[
+          // if there are tabs, and the selected tab provides a helpTopic, return that
+          var box = this.getElementsByTagName("tabbox");
+          if (box[0]) {
+            var tab = box[0].selectedTab;
+            if (tab && tab.hasAttribute("helpTopic"))
+              return tab.getAttribute("helpTopic");
+          }
+
+          // otherwise, return the helpTopic of the current panel
+          return this.getAttribute("helpTopic");
+        ]]>
+        </getter>
+      </property>
+
+      <field name="_loaded">false</field>
+      <property name="loaded"
+                onget="return !this.src ? true : this._loaded;"
+                onset="this._loaded = val; return val;"/>
+
+      <method name="preferenceForElement">
+        <parameter name="aElement"/>
+        <body>
+          return document.getElementById(aElement.getAttribute("preference"));
+        </body>
+      </method>
+
+      <method name="getPreferenceElement">
+        <parameter name="aStartElement"/>
+        <body>
+        <![CDATA[
+          var temp = aStartElement;
+          while (temp && temp.nodeType == Node.ELEMENT_NODE &&
+                 !temp.hasAttribute("preference"))
+            temp = temp.parentNode;
+          return temp && temp.nodeType == Node.ELEMENT_NODE ?
+                 temp : aStartElement;
+        ]]>
+        </body>
+      </method>
+
+      <property name="DeferredTask" readonly="true">
+        <getter><![CDATA[
+          let module = {};
+          Components.utils.import("resource://gre/modules/DeferredTask.jsm", module);
+          Object.defineProperty(this, "DeferredTask", {
+            configurable: true,
+            enumerable: true,
+            writable: true,
+            value: module.DeferredTask
+          });
+          return module.DeferredTask;
+        ]]></getter>
+      </property>
+      <method name="_deferredValueUpdate">
+        <parameter name="aElement"/>
+        <body>
+        <![CDATA[
+          delete aElement._deferredValueUpdateTask;
+          let preference = document.getElementById(aElement.getAttribute("preference"));
+          let prefVal = preference.getElementValue(aElement);
+          preference.value = prefVal;
+          this._deferredValueUpdateElements.delete(aElement);
+        ]]>
+        </body>
+      </method>
+      <field name="_deferredValueUpdateElements">
+        new Set();
+      </field>
+      <method name="_finalizeDeferredElements">
+        <body>
+        <![CDATA[
+          for (let el of this._deferredValueUpdateElements) {
+            if (el._deferredValueUpdateTask) {
+              el._deferredValueUpdateTask.finalize();
+            }
+          }
+        ]]>
+        </body>
+      </method>
+      <method name="userChangedValue">
+        <parameter name="aElement"/>
+        <body>
+        <![CDATA[
+          let element = this.getPreferenceElement(aElement);
+          if (element.hasAttribute("preference")) {
+            if (element.getAttribute("delayprefsave") != "true") {
+              var preference = document.getElementById(element.getAttribute("preference"));
+              var prefVal = preference.getElementValue(element);
+              preference.value = prefVal;
+            } else {
+              if (!element._deferredValueUpdateTask) {
+                element._deferredValueUpdateTask = new this.DeferredTask(this._deferredValueUpdate.bind(this, element), 1000);
+                this._deferredValueUpdateElements.add(element);
+              } else {
+                // Each time the preference is changed, restart the delay.
+                element._deferredValueUpdateTask.disarm();
+              }
+              element._deferredValueUpdateTask.arm();
+            }
+          }
+        ]]>
+        </body>
+      </method>
+
+      <property name="contentHeight">
+        <getter>
+          var targetHeight = parseInt(window.getComputedStyle(this._content).height);
+          targetHeight += parseInt(window.getComputedStyle(this._content).marginTop);
+          targetHeight += parseInt(window.getComputedStyle(this._content).marginBottom);
+          return targetHeight;
+        </getter>
+      </property>
+      <field name="_content">
+        document.getAnonymousElementByAttribute(this, "class", "content-box");
+      </field>
+    </implementation>
+    <handlers>
+      <handler event="command">
+        // This "command" event handler tracks changes made to preferences by
+        // the user in this window.
+        if (event.sourceEvent)
+          event = event.sourceEvent;
+        this.userChangedValue(event.target);
+      </handler>
+      <handler event="select">
+        // This "select" event handler tracks changes made to colorpicker
+        // preferences by the user in this window.
+        if (event.target.localName == "colorpicker")
+          this.userChangedValue(event.target);
+      </handler>
+      <handler event="change">
+        // This "change" event handler tracks changes made to preferences by
+        // the user in this window.
+        this.userChangedValue(event.target);
+      </handler>
+      <handler event="input">
+        // This "input" event handler tracks changes made to preferences by
+        // the user in this window.
+        this.userChangedValue(event.target);
+      </handler>
+      <handler event="paneload">
+      <![CDATA[
+        // Initialize all values from preferences.
+        var elements = this.preferenceElements;
+        for (var i = 0; i < elements.length; ++i) {
+          try {
+            var preference = this.preferenceForElement(elements[i]);
+            preference.setElementValue(elements[i]);
+          } catch (e) {
+            dump("*** No preference found for " + elements[i].getAttribute("preference") + "\n");
+          }
+        }
+      ]]>
+      </handler>
+    </handlers>
+  </binding>
+
+  <binding id="panebutton" role="xul:listitem"
+           extends="chrome://global/content/bindings/radio.xml#radio">
+    <resources>
+      <stylesheet src="chrome://global/skin/preferences.css"/>
+    </resources>
+    <content>
+      <xul:image class="paneButtonIcon" xbl:inherits="src"/>
+      <xul:label class="paneButtonLabel" xbl:inherits="value=label"/>
+    </content>
+  </binding>
+
+</bindings>
+
+# -*- Mode: Java; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+#
+# This is PrefWindow 6. The Code Could Well Be Ready, Are You?
+#
+#    Historical References:
+#    PrefWindow V   (February 1, 2003)
+#    PrefWindow IV  (April 24, 2000)
+#    PrefWindow III (January 6, 2000)
+#    PrefWindow II  (???)
+#    PrefWindow I   (June 4, 1999)
+#
diff --git a/toolkit/content/xul.css b/toolkit/content/xul.css
index 095e7da69afc..1d2c13a063f5 100644
--- a/toolkit/content/xul.css
+++ b/toolkit/content/xul.css
@@ -319,6 +319,18 @@ toolbar[type="menubar"][autohide="true"][inactive="true"]:not([customizing="true
 }
 %endif
 
+%ifdef MOZ_WIDGET_GTK
+window[shellshowingmenubar="true"] menubar {
+  display: none !important;
+}
+
+window[shellshowingmenubar="true"]
+toolbar[type="menubar"]:not([customizing="true"]) {
+  min-height: 0 !important;
+  border: 0 !important;
+}
+%endif
+
 toolbarseparator {
   -moz-binding: url("chrome://global/content/bindings/toolbar.xml#toolbardecoration");
 }
diff --git a/toolkit/mozapps/downloads/nsHelperAppDlg.js b/toolkit/mozapps/downloads/nsHelperAppDlg.js
index 986acae2fe5a..e29691b3f8b2 100644
--- a/toolkit/mozapps/downloads/nsHelperAppDlg.js
+++ b/toolkit/mozapps/downloads/nsHelperAppDlg.js
@@ -633,7 +633,7 @@ nsUnknownContentTypeDialog.prototype = {
       let [size, unit] = DownloadUtils.
                          convertByteUnits(this.mLauncher.contentLength);
       type.value = this.dialogElement("strings")
-                       .getFormattedString("orderedFileSizeWithType", 
+                       .getFormattedString("orderedFileSizeWithType",
                                            [typeString, size, unit]);
     }
     else {
@@ -807,7 +807,7 @@ nsUnknownContentTypeDialog.prototype = {
       case 1:
         // only enable the OK button if we have a default app to use or if
         // the user chose an app....
-        ok = this.chosenApp || /\S/.test(this.dialogElement("otherHandler").getAttribute("path")); 
+        ok = this.chosenApp || /\S/.test(this.dialogElement("otherHandler").getAttribute("path"));
         break;
       }
     }
@@ -1072,20 +1072,47 @@ nsUnknownContentTypeDialog.prototype = {
         this.chosenApp = params.handlerApp;
       }
     } else if ("@mozilla.org/applicationchooser;1" in Components.classes) {
-      var nsIApplicationChooser = Components.interfaces.nsIApplicationChooser;
-      var appChooser = Components.classes["@mozilla.org/applicationchooser;1"]
-                                 .createInstance(nsIApplicationChooser);
-      appChooser.init(this.mDialog, this.dialogElement("strings").getString("chooseAppFilePickerTitle"));
-      var contentTypeDialogObj = this;
-      let appChooserCallback = function appChooserCallback_done(aResult) {
-        if (aResult) {
-           contentTypeDialogObj.chosenApp = aResult.QueryInterface(Components.interfaces.nsILocalHandlerApp);
+      // handle the KDE case which is implemented in the filepicker
+      // therefore falling back to Gtk2 like behaviour if KDE is running
+      // FIXME this should be better handled in the nsIApplicationChooser
+      // interface
+      var env = Components.classes["@mozilla.org/process/environment;1"]
+                          .getService(Components.interfaces.nsIEnvironment);
+      if (env.get('KDE_FULL_SESSION') == "true")
+      {
+        var nsIFilePicker = Components.interfaces.nsIFilePicker;
+        var fp = Components.classes["@mozilla.org/filepicker;1"]
+                           .createInstance(nsIFilePicker);
+        fp.init(this.mDialog,
+                this.dialogElement("strings").getString("chooseAppFilePickerTitle"),
+                nsIFilePicker.modeOpen);
+
+        fp.appendFilters(nsIFilePicker.filterApps);
+
+        if (fp.show() == nsIFilePicker.returnOK && fp.file) {
+          // Remember the file they chose to run.
+          var localHandlerApp =
+            Components.classes["@mozilla.org/uriloader/local-handler-app;1"].
+                       createInstance(Components.interfaces.nsILocalHandlerApp);
+          localHandlerApp.executable = fp.file;
+          this.chosenApp = localHandlerApp;
         }
-        contentTypeDialogObj.finishChooseApp();
-      };
-      appChooser.open(this.mLauncher.MIMEInfo.MIMEType, appChooserCallback);
-      // The finishChooseApp is called from appChooserCallback
-      return;
+      } else {
+        var nsIApplicationChooser = Components.interfaces.nsIApplicationChooser;
+        var appChooser = Components.classes["@mozilla.org/applicationchooser;1"]
+                                   .createInstance(nsIApplicationChooser);
+        appChooser.init(this.mDialog, this.dialogElement("strings").getString("chooseAppFilePickerTitle"));
+        var contentTypeDialogObj = this;
+        let appChooserCallback = function appChooserCallback_done(aResult) {
+          if (aResult) {
+             contentTypeDialogObj.chosenApp = aResult.QueryInterface(Components.interfaces.nsILocalHandlerApp);
+          }
+          contentTypeDialogObj.finishChooseApp();
+        };
+        appChooser.open(this.mLauncher.MIMEInfo.MIMEType, appChooserCallback);
+        // The finishChooseApp is called from appChooserCallback
+        return;
+      }
     } else {
       var nsIFilePicker = Components.interfaces.nsIFilePicker;
       var fp = Components.classes["@mozilla.org/filepicker;1"]
diff --git a/toolkit/system/unixproxy/nsUnixSystemProxySettings.cpp b/toolkit/system/unixproxy/nsUnixSystemProxySettings.cpp
index 8b4c9a89597f..9cc4152358da 100644
--- a/toolkit/system/unixproxy/nsUnixSystemProxySettings.cpp
+++ b/toolkit/system/unixproxy/nsUnixSystemProxySettings.cpp
@@ -20,6 +20,7 @@
 #include "nsInterfaceHashtable.h"
 #include "mozilla/Attributes.h"
 #include "nsIURI.h"
+#include "nsKDEUtils.h"
 
 class nsUnixSystemProxySettings final : public nsISystemProxySettings {
 public:
@@ -44,6 +45,7 @@ private:
   nsresult GetProxyFromGConf(const nsACString& aScheme, const nsACString& aHost, int32_t aPort, nsACString& aResult);
   nsresult GetProxyFromGSettings(const nsACString& aScheme, const nsACString& aHost, int32_t aPort, nsACString& aResult);
   nsresult SetProxyResultFromGSettings(const char* aKeyBase, const char* aType, nsACString& aResult);
+  nsresult GetProxyFromKDE(const nsACString& aScheme, const nsACString& aHost, PRInt32 aPort, nsACString& aResult);
 };
 
 NS_IMPL_ISUPPORTS(nsUnixSystemProxySettings, nsISystemProxySettings)
@@ -510,6 +512,9 @@ nsUnixSystemProxySettings::GetProxyForURI(const nsACString & aSpec,
                                           const int32_t      aPort,
                                           nsACString & aResult)
 {
+  if (nsKDEUtils::kdeSupport())
+    return GetProxyFromKDE(aScheme, aHost, aPort, aResult);
+
   if (mProxySettings) {
     nsresult rv = GetProxyFromGSettings(aScheme, aHost, aPort, aResult);
     if (NS_SUCCEEDED(rv))
@@ -545,3 +550,28 @@ static const mozilla::Module kUnixProxyModule = {
 };
 
 NSMODULE_DEFN(nsUnixProxyModule) = &kUnixProxyModule;
+
+nsresult
+nsUnixSystemProxySettings::GetProxyFromKDE(const nsACString& aScheme,
+                                           const nsACString& aHost,
+                                           PRInt32 aPort,
+                                           nsACString& aResult)
+{
+  nsAutoCString url;
+  url = aScheme;
+  url += "://";
+  url += aHost;
+  if( aPort >= 0 )
+  {
+    url += ":";
+    url += nsPrintfCString("%d", aPort);
+  }
+  nsTArray<nsCString> command;
+  command.AppendElement( NS_LITERAL_CSTRING( "GETPROXY" ));
+  command.AppendElement( url );
+  nsTArray<nsCString> result;
+  if( !nsKDEUtils::command( command, &result ) || result.Length() != 1 )
+    return NS_ERROR_FAILURE;
+  aResult = result[0];
+  return NS_OK;
+}
diff --git a/toolkit/xre/moz.build b/toolkit/xre/moz.build
index 7a65cd5d296b..8fea9e954ca2 100644
--- a/toolkit/xre/moz.build
+++ b/toolkit/xre/moz.build
@@ -66,7 +66,9 @@ elif CONFIG['MOZ_WIDGET_TOOLKIT'] == 'uikit':
         'UIKitDirProvider.mm',
     ]
 elif 'gtk' in CONFIG['MOZ_WIDGET_TOOLKIT']:
+    EXPORTS += ['nsKDEUtils.h']
     UNIFIED_SOURCES += [
+        'nsKDEUtils.cpp',
         'nsNativeAppSupportUnix.cpp',
     ]
 else:
diff --git a/toolkit/xre/nsKDEUtils.cpp b/toolkit/xre/nsKDEUtils.cpp
new file mode 100644
index 000000000000..7d3b9da15645
--- /dev/null
+++ b/toolkit/xre/nsKDEUtils.cpp
@@ -0,0 +1,344 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "nsKDEUtils.h"
+#include "nsIWidget.h"
+#include "nsISupportsPrimitives.h"
+#include "nsIMutableArray.h"
+#include "nsComponentManagerUtils.h"
+#include "nsArrayUtils.h"
+
+#include <gtk/gtk.h>
+
+#include <limits.h>
+#include <stdio.h>
+#include <sys/wait.h>
+#include <sys/resource.h>
+#include <unistd.h>
+#include <X11/Xlib.h>
+// copied from X11/X.h as a hack since for an unknown
+// reason it's not picked up from X11/X.h
+#ifndef None
+#define None                 0L /* universal null resource or null atom */
+#endif
+
+//#define DEBUG_KDE
+#ifdef DEBUG_KDE
+#define KWATERFOXHELPER "kwaterfoxhelper"
+#else
+// not need for lib64, it's a binary
+#define KWATERFOXHELPER "/usr/lib/waterfox/kwaterfoxhelper"
+#endif
+
+#define KWATERFOXHELPER_VERSION 6
+#define MAKE_STR2( n ) #n
+#define MAKE_STR( n ) MAKE_STR2( n )
+
+static bool getKdeSession()
+    {
+    Display* dpy = XOpenDisplay( NULL );
+    if( dpy == NULL )
+        return false;
+    Atom kde_full_session = XInternAtom( dpy, "KDE_FULL_SESSION", True );
+    bool kde = false;
+    if( kde_full_session != None )
+        {
+        int cnt;
+        if( Atom* props = XListProperties( dpy, DefaultRootWindow( dpy ), &cnt ))
+            {
+            for( int i = 0;
+                 i < cnt;
+                 ++i )
+                {
+                if( props[ i ] == kde_full_session )
+                    {
+                    kde = true;
+#ifdef DEBUG_KDE
+                    fprintf( stderr, "KDE SESSION %d\n", kde );
+#endif
+                    break;
+                    }
+                }
+            XFree( props );
+            }
+        }
+    XCloseDisplay( dpy );
+    return kde;
+    }
+
+static bool getKdeSupport()
+    {
+    nsTArray<nsCString> command;
+    command.AppendElement( NS_LITERAL_CSTRING( "CHECK" ));
+    command.AppendElement( NS_LITERAL_CSTRING( MAKE_STR( KWATERFOXHELPER_VERSION )));
+    bool kde = nsKDEUtils::command( command );
+#ifdef DEBUG_KDE
+    fprintf( stderr, "KDE RUNNING %d\n", kde );
+#endif
+    return kde;
+    }
+
+nsKDEUtils::nsKDEUtils()
+    : commandFile( NULL )
+    , replyFile( NULL )
+    {
+    }
+
+nsKDEUtils::~nsKDEUtils()
+    {
+//    closeHelper(); not actually useful, exiting will close the fd too
+    }
+
+nsKDEUtils* nsKDEUtils::self()
+    {
+    static nsKDEUtils s;
+    return &s;
+    }
+
+static bool helperRunning = false;
+static bool helperFailed = false;
+
+bool nsKDEUtils::kdeSession()
+    {
+    static bool session = getKdeSession();
+    return session;
+    }
+
+bool nsKDEUtils::kdeSupport()
+    {
+    static bool support = kdeSession() && getKdeSupport();
+    return support && helperRunning;
+    }
+
+struct nsKDECommandData
+    {
+    FILE* file;
+    nsTArray<nsCString>* output;
+    GMainLoop* loop;
+    bool success;
+    };
+
+static gboolean kdeReadFunc( GIOChannel*, GIOCondition, gpointer data )
+    {
+    nsKDECommandData* p = static_cast< nsKDECommandData* >( data );
+    char buf[ 8192 ]; // TODO big enough
+    bool command_done = false;
+    bool command_failed = false;
+    while( !command_done && !command_failed && fgets( buf, 8192, p->file ) != NULL )
+        { // TODO what if the kernel splits a line into two chunks?
+//#ifdef DEBUG_KDE
+//        fprintf( stderr, "READ: %s %d\n", buf, feof( p->file ));
+//#endif
+        if( char* eol = strchr( buf, '\n' ))
+            *eol = '\0';
+        command_done = ( strcmp( buf, "\\1" ) == 0 );
+        command_failed = ( strcmp( buf, "\\0" ) == 0 );
+        nsAutoCString line( buf );
+        line.ReplaceSubstring( "\\n", "\n" );
+        line.ReplaceSubstring( "\\" "\\", "\\" ); //  \\ -> \ , i.e. unescape
+        if( p->output && !( command_done || command_failed ))
+            p->output->AppendElement( nsCString( buf )); // TODO utf8?
+        }
+    bool quit = false;
+    if( feof( p->file ) || command_failed )
+        {
+        quit = true;
+        p->success = false;
+        }
+    if( command_done )
+        { // reading one reply finished
+        quit = true;
+        p->success = true;
+        }
+    if( quit )
+        {
+        if( p->loop )
+            g_main_loop_quit( p->loop );
+        return FALSE;
+        }
+    return TRUE;
+    }
+
+bool nsKDEUtils::command( const nsTArray<nsCString>& command, nsTArray<nsCString>* output )
+    {
+    return self()->internalCommand( command, NULL, false, output );
+    }
+
+bool nsKDEUtils::command( nsIArray* command, nsIArray** output)
+    {
+    nsTArray<nsCString> in;
+    PRUint32 length;
+    command->GetLength( &length );
+    for ( PRUint32 i = 0; i < length; i++ )
+        {
+        nsCOMPtr<nsISupportsCString> str = do_QueryElementAt( command, i );
+        if( str )
+            {
+            nsAutoCString s;
+            str->GetData( s );
+            in.AppendElement( s );
+            }
+        }
+
+    nsTArray<nsCString> out;
+    bool ret = self()->internalCommand( in, NULL, false, &out );
+
+    if ( !output ) return ret;
+
+    nsCOMPtr<nsIMutableArray> result = do_CreateInstance( NS_ARRAY_CONTRACTID );
+    if ( !result ) return false;
+
+    for ( PRUint32 i = 0; i < out.Length(); i++ )
+        {
+        nsCOMPtr<nsISupportsCString> rstr = do_CreateInstance( NS_SUPPORTS_CSTRING_CONTRACTID );
+        if ( !rstr ) return false;
+
+        rstr->SetData( out[i] );
+        result->AppendElement( rstr, false );
+        }
+
+    NS_ADDREF( *output = result);
+    return ret;
+    }
+
+
+bool nsKDEUtils::commandBlockUi( const nsTArray<nsCString>& command, GtkWindow* parent, nsTArray<nsCString>* output )
+    {
+    return self()->internalCommand( command, parent, true, output );
+    }
+
+bool nsKDEUtils::internalCommand( const nsTArray<nsCString>& command, GtkWindow* parent, bool blockUi,
+    nsTArray<nsCString>* output )
+    {
+    if( !startHelper())
+        return false;
+    feedCommand( command );
+    // do not store the data in 'this' but in extra structure, just in case there
+    // is reentrancy (can there be? the event loop is re-entered)
+    nsKDECommandData data;
+    data.file = replyFile;
+    data.output = output;
+    data.success = false;
+    if( blockUi )
+        {
+        data.loop = g_main_loop_new( NULL, FALSE );
+        GtkWidget* window = gtk_window_new( GTK_WINDOW_TOPLEVEL );
+        if( parent && gtk_window_get_group(parent) )
+            gtk_window_group_add_window( gtk_window_get_group(parent), GTK_WINDOW( window ));
+        gtk_widget_realize( window );
+        gtk_widget_set_sensitive( window, TRUE );
+        gtk_grab_add( window );
+        GIOChannel* channel = g_io_channel_unix_new( fileno( data.file ));
+        g_io_add_watch( channel, static_cast< GIOCondition >( G_IO_IN | G_IO_ERR | G_IO_HUP ), kdeReadFunc, &data );
+        g_io_channel_unref( channel );
+        g_main_loop_run( data.loop );
+        g_main_loop_unref( data.loop );
+        gtk_grab_remove( window );
+        gtk_widget_destroy( window );
+        }
+    else
+        {
+        data.loop = NULL;
+        while( kdeReadFunc( NULL, static_cast< GIOCondition >( 0 ), &data ))
+            ;
+        }
+    return data.success;
+    }
+
+bool nsKDEUtils::startHelper()
+    {
+    if( helperRunning )
+        return true;
+    if( helperFailed )
+        return false;
+    helperFailed = true;
+    int fdcommand[ 2 ];
+    int fdreply[ 2 ];
+    if( pipe( fdcommand ) < 0 )
+        return false;
+    if( pipe( fdreply ) < 0 )
+        {
+        close( fdcommand[ 0 ] );
+        close( fdcommand[ 1 ] );
+        return false;
+        }
+    char* args[ 2 ] = { const_cast< char* >( KWATERFOXHELPER ), NULL };
+    switch( fork())
+        {
+        case -1:
+            {
+            close( fdcommand[ 0 ] );
+            close( fdcommand[ 1 ] );
+            close( fdreply[ 0 ] );
+            close( fdreply[ 1 ] );
+            return false;
+            }
+        case 0: // child
+            {
+            if( dup2( fdcommand[ 0 ], STDIN_FILENO ) < 0 )
+                _exit( 1 );
+            if( dup2( fdreply[ 1 ], STDOUT_FILENO ) < 0 )
+                _exit( 1 );
+            int maxfd = 1024; // close all other fds
+            struct rlimit rl;
+            if( getrlimit( RLIMIT_NOFILE, &rl ) == 0 )
+                maxfd = rl.rlim_max;
+            for( int i = 3;
+                 i < maxfd;
+                 ++i )
+                close( i );
+#ifdef DEBUG_KDE
+            execvp( KWATERFOXHELPER, args );
+#else
+            execv( KWATERFOXHELPER, args );
+#endif
+            _exit( 1 ); // failed
+            }
+        default: // parent
+            {
+            commandFile = fdopen( fdcommand[ 1 ], "w" );
+            replyFile = fdopen( fdreply[ 0 ], "r" );
+            close( fdcommand[ 0 ] );
+            close( fdreply[ 1 ] );
+            if( commandFile == NULL || replyFile == NULL )
+                {
+                closeHelper();
+                return false;
+                }
+            // ok, helper ready, getKdeRunning() will check if it works
+            }
+        }
+    helperFailed = false;
+    helperRunning = true;
+    return true;
+    }
+
+void nsKDEUtils::closeHelper()
+    {
+    if( commandFile != NULL )
+        fclose( commandFile ); // this will also make the helper quit
+    if( replyFile != NULL )
+        fclose( replyFile );
+    helperRunning = false;
+    }
+
+void nsKDEUtils::feedCommand( const nsTArray<nsCString>& command )
+    {
+    for( int i = 0;
+         i < command.Length();
+         ++i )
+        {
+        nsCString line = command[ i ];
+        line.ReplaceSubstring( "\\", "\\" "\\" ); // \ -> \\ , i.e. escape
+        line.ReplaceSubstring( "\n", "\\n" );
+#ifdef DEBUG_KDE
+        fprintf( stderr, "COMM: %s\n", line.get());
+#endif
+        fputs( line.get(), commandFile );
+        fputs( "\n", commandFile );
+        }
+    fputs( "\\E\n", commandFile ); // done as \E, so it cannot happen in normal data
+    fflush( commandFile );
+    }
diff --git a/toolkit/xre/nsKDEUtils.h b/toolkit/xre/nsKDEUtils.h
new file mode 100644
index 000000000000..a19271b98f78
--- /dev/null
+++ b/toolkit/xre/nsKDEUtils.h
@@ -0,0 +1,48 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef nsKDEUtils_h__
+#define nsKDEUtils_h__
+
+#include "nsStringGlue.h"
+#include "nsTArray.h"
+#include <stdio.h>
+
+typedef struct _GtkWindow GtkWindow;
+
+class nsIArray;
+
+class NS_EXPORT nsKDEUtils
+    {
+    public:
+        /* Returns true if running inside a KDE session (regardless of whether there is KDE
+           support available for Waterfox). This should be used e.g. when determining
+           dialog button order but not for code that requires the KDE support. */
+        static bool kdeSession();
+        /* Returns true if running inside a KDE session and KDE support is available
+           for Waterfox. This should be used everywhere where the external helper is needed. */
+        static bool kdeSupport();
+        /* Executes the given helper command, returns true if helper returned success. */
+        static bool command( const nsTArray<nsCString>& command, nsTArray<nsCString>* output = NULL );
+        static bool command( nsIArray* command, nsIArray** output = NULL );
+        /* Like command(), but additionally blocks the parent widget like if there was
+           a modal dialog shown and enters the event loop (i.e. there are still paint updates,
+           this is for commands that take long). */
+        static bool commandBlockUi( const nsTArray<nsCString>& command, GtkWindow* parent, nsTArray<nsCString>* output = NULL );
+
+    private:
+        nsKDEUtils();
+        ~nsKDEUtils();
+        static nsKDEUtils* self();
+        bool startHelper();
+        void closeHelper();
+        void feedCommand( const nsTArray<nsCString>& command );
+        bool internalCommand( const nsTArray<nsCString>& command, GtkWindow* parent, bool isParent,
+            nsTArray<nsCString>* output );
+        FILE* commandFile;
+        FILE* replyFile;
+    };
+
+#endif // nsKDEUtils
diff --git a/uriloader/exthandler/moz.build b/uriloader/exthandler/moz.build
index 3349d5006901..fc8d57a09355 100644
--- a/uriloader/exthandler/moz.build
+++ b/uriloader/exthandler/moz.build
@@ -82,7 +82,9 @@ else:
 
 if 'gtk' in CONFIG['MOZ_WIDGET_TOOLKIT']:
     UNIFIED_SOURCES += [
+        'unix/nsCommonRegistry.cpp',
         'unix/nsGNOMERegistry.cpp',
+	'unix/nsKDERegistry.cpp',
         'unix/nsMIMEInfoUnix.cpp',
     ]
 elif CONFIG['MOZ_WIDGET_TOOLKIT'] == 'android':
@@ -130,6 +132,7 @@ LOCAL_INCLUDES += [
     '/dom/ipc',
     '/netwerk/base',
     '/netwerk/protocol/http',
+    '/toolkit/xre',
 ]
 
 if CONFIG['MOZ_ENABLE_DBUS']:
diff --git a/uriloader/exthandler/unix/nsCommonRegistry.cpp b/uriloader/exthandler/unix/nsCommonRegistry.cpp
new file mode 100644
index 000000000000..630ab6147db3
--- /dev/null
+++ b/uriloader/exthandler/unix/nsCommonRegistry.cpp
@@ -0,0 +1,53 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "nsCommonRegistry.h"
+
+#include "nsGNOMERegistry.h"
+#include "nsKDERegistry.h"
+#include "nsString.h"
+#include "nsKDEUtils.h"
+
+/* static */ bool
+nsCommonRegistry::HandlerExists(const char *aProtocolScheme)
+{
+    if( nsKDEUtils::kdeSupport())
+        return nsKDERegistry::HandlerExists( aProtocolScheme );
+    return nsGNOMERegistry::HandlerExists( aProtocolScheme );
+}
+
+/* static */ nsresult
+nsCommonRegistry::LoadURL(nsIURI *aURL)
+{
+    if( nsKDEUtils::kdeSupport())
+        return nsKDERegistry::LoadURL( aURL );
+    return nsGNOMERegistry::LoadURL( aURL );
+}
+
+/* static */ void
+nsCommonRegistry::GetAppDescForScheme(const nsACString& aScheme,
+                                     nsAString& aDesc)
+{
+    if( nsKDEUtils::kdeSupport())
+        return nsKDERegistry::GetAppDescForScheme( aScheme, aDesc );
+    return nsGNOMERegistry::GetAppDescForScheme( aScheme, aDesc );
+}
+
+
+/* static */ already_AddRefed<nsMIMEInfoBase>
+nsCommonRegistry::GetFromExtension(const nsACString& aFileExt)
+{
+    if( nsKDEUtils::kdeSupport())
+        return nsKDERegistry::GetFromExtension( aFileExt );
+    return nsGNOMERegistry::GetFromExtension( aFileExt );
+}
+
+/* static */ already_AddRefed<nsMIMEInfoBase>
+nsCommonRegistry::GetFromType(const nsACString& aMIMEType)
+{
+    if( nsKDEUtils::kdeSupport())
+        return nsKDERegistry::GetFromType( aMIMEType );
+    return nsGNOMERegistry::GetFromType( aMIMEType );
+}
diff --git a/uriloader/exthandler/unix/nsCommonRegistry.h b/uriloader/exthandler/unix/nsCommonRegistry.h
new file mode 100644
index 000000000000..85b3d9cee25e
--- /dev/null
+++ b/uriloader/exthandler/unix/nsCommonRegistry.h
@@ -0,0 +1,28 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef nsCommonRegistry_h__
+#define nsCommonRegistry_h__
+
+#include "nsIURI.h"
+#include "nsCOMPtr.h"
+
+class nsMIMEInfoBase;
+
+class nsCommonRegistry
+{
+ public:
+  static bool HandlerExists(const char *aProtocolScheme);
+
+  static nsresult LoadURL(nsIURI *aURL);
+
+  static void GetAppDescForScheme(const nsACString& aScheme,
+                                  nsAString& aDesc);
+
+  static already_AddRefed<nsMIMEInfoBase> GetFromExtension(const nsACString& aFileExt);
+
+  static already_AddRefed<nsMIMEInfoBase> GetFromType(const nsACString& aMIMEType);
+};
+
+#endif
diff --git a/uriloader/exthandler/unix/nsKDERegistry.cpp b/uriloader/exthandler/unix/nsKDERegistry.cpp
new file mode 100644
index 000000000000..6a2ca0abc7e1
--- /dev/null
+++ b/uriloader/exthandler/unix/nsKDERegistry.cpp
@@ -0,0 +1,88 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "nsKDERegistry.h"
+#include "prlink.h"
+#include "prmem.h"
+#include "nsString.h"
+#include "nsILocalFile.h"
+#include "nsMIMEInfoUnix.h"
+#include "nsAutoPtr.h"
+#include "nsKDEUtils.h"
+
+/* static */ bool
+nsKDERegistry::HandlerExists(const char *aProtocolScheme)
+{
+    nsTArray<nsCString> command;
+    command.AppendElement( NS_LITERAL_CSTRING( "HANDLEREXISTS" ));
+    command.AppendElement( nsAutoCString( aProtocolScheme ));
+    return nsKDEUtils::command( command );
+}
+
+/* static */ nsresult
+nsKDERegistry::LoadURL(nsIURI *aURL)
+{
+    nsTArray<nsCString> command;
+    command.AppendElement( NS_LITERAL_CSTRING( "OPEN" ));
+    nsCString url;
+    aURL->GetSpec( url );
+    command.AppendElement( url );
+    bool rv = nsKDEUtils::command( command );
+    if (!rv)
+      return NS_ERROR_FAILURE;
+
+    return NS_OK;
+}
+
+/* static */ void
+nsKDERegistry::GetAppDescForScheme(const nsACString& aScheme,
+                                     nsAString& aDesc)
+{
+    nsTArray<nsCString> command;
+    command.AppendElement( NS_LITERAL_CSTRING( "GETAPPDESCFORSCHEME" ));
+    command.AppendElement( aScheme );
+    nsTArray<nsCString> output;
+    if( nsKDEUtils::command( command, &output ) && output.Length() == 1 )
+        CopyUTF8toUTF16( output[ 0 ], aDesc );
+}
+
+
+/* static */ already_AddRefed<nsMIMEInfoBase>
+nsKDERegistry::GetFromExtension(const nsACString& aFileExt)
+{
+    NS_ASSERTION(aFileExt[0] != '.', "aFileExt shouldn't start with a dot");
+    nsTArray<nsCString> command;
+    command.AppendElement( NS_LITERAL_CSTRING( "GETFROMEXTENSION" ));
+    command.AppendElement( aFileExt );
+    return GetFromHelper( command );
+}
+
+/* static */ already_AddRefed<nsMIMEInfoBase>
+nsKDERegistry::GetFromType(const nsACString& aMIMEType)
+{
+    nsTArray<nsCString> command;
+    command.AppendElement( NS_LITERAL_CSTRING( "GETFROMTYPE" ));
+    command.AppendElement( aMIMEType );
+    return GetFromHelper( command );
+}
+
+/* static */ already_AddRefed<nsMIMEInfoBase>
+nsKDERegistry::GetFromHelper(const nsTArray<nsCString>& command)
+{
+    nsTArray<nsCString> output;
+    if( nsKDEUtils::command( command, &output ) && output.Length() == 3 )
+        {
+        nsCString mimetype = output[ 0 ];
+        RefPtr<nsMIMEInfoUnix> mimeInfo = new nsMIMEInfoUnix( mimetype );
+        NS_ENSURE_TRUE(mimeInfo, nullptr);
+        nsCString description = output[ 1 ];
+        mimeInfo->SetDescription(NS_ConvertUTF8toUTF16(description));
+        nsCString handlerAppName = output[ 2 ];
+        mimeInfo->SetDefaultDescription(NS_ConvertUTF8toUTF16(handlerAppName));
+        mimeInfo->SetPreferredAction(nsIMIMEInfo::useSystemDefault);
+        return mimeInfo.forget();
+        }
+    return nullptr;
+}
diff --git a/uriloader/exthandler/unix/nsKDERegistry.h b/uriloader/exthandler/unix/nsKDERegistry.h
new file mode 100644
index 000000000000..4eaaa4493efd
--- /dev/null
+++ b/uriloader/exthandler/unix/nsKDERegistry.h
@@ -0,0 +1,34 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef nsKDERegistry_h__
+#define nsKDERegistry_h__
+
+#include "nsIURI.h"
+#include "nsCOMPtr.h"
+#include "nsTArray.h"
+
+class nsMIMEInfoBase;
+class nsAutoCString;
+class nsCString;
+
+class nsKDERegistry
+{
+ public:
+  static bool HandlerExists(const char *aProtocolScheme);
+
+  static nsresult LoadURL(nsIURI *aURL);
+
+  static void GetAppDescForScheme(const nsACString& aScheme,
+                                  nsAString& aDesc);
+
+  static already_AddRefed<nsMIMEInfoBase> GetFromExtension(const nsACString& aFileExt);
+
+  static already_AddRefed<nsMIMEInfoBase> GetFromType(const nsACString& aMIMEType);
+ private:
+  static already_AddRefed<nsMIMEInfoBase> GetFromHelper(const nsTArray<nsCString>& command);
+
+};
+
+#endif //nsKDERegistry_h__
diff --git a/uriloader/exthandler/unix/nsMIMEInfoUnix.cpp b/uriloader/exthandler/unix/nsMIMEInfoUnix.cpp
index e51660887354..95989b990bba 100644
--- a/uriloader/exthandler/unix/nsMIMEInfoUnix.cpp
+++ b/uriloader/exthandler/unix/nsMIMEInfoUnix.cpp
@@ -5,7 +5,7 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "nsMIMEInfoUnix.h"
-#include "nsGNOMERegistry.h"
+#include "nsCommonRegistry.h"
 #include "nsIGIOService.h"
 #include "nsNetCID.h"
 #include "nsIIOService.h"
@@ -13,11 +13,14 @@
 #ifdef MOZ_ENABLE_DBUS
 #include "nsDBusHandlerApp.h"
 #endif
+#if defined(XP_UNIX) && !defined(XP_MACOSX)
+#include "nsKDEUtils.h"
+#endif
 
 nsresult
 nsMIMEInfoUnix::LoadUriInternal(nsIURI * aURI)
 {
-  return nsGNOMERegistry::LoadURL(aURI);
+  return nsCommonRegistry::LoadURL(aURI);
 }
 
 NS_IMETHODIMP
@@ -32,14 +35,14 @@ nsMIMEInfoUnix::GetHasDefaultHandler(bool *_retval)
   *_retval = false;
 
   if (mClass == eProtocolInfo) {
-    *_retval = nsGNOMERegistry::HandlerExists(mSchemeOrType.get());
+    *_retval = nsCommonRegistry::HandlerExists(mSchemeOrType.get());
   } else {
-    RefPtr<nsMIMEInfoBase> mimeInfo = nsGNOMERegistry::GetFromType(mSchemeOrType);
+    RefPtr<nsMIMEInfoBase> mimeInfo = nsCommonRegistry::GetFromType(mSchemeOrType);
     if (!mimeInfo) {
       nsAutoCString ext;
       nsresult rv = GetPrimaryExtension(ext);
       if (NS_SUCCEEDED(rv)) {
-        mimeInfo = nsGNOMERegistry::GetFromExtension(ext);
+        mimeInfo = nsCommonRegistry::GetFromExtension(ext);
       }
     }
     if (mimeInfo)
@@ -84,6 +87,23 @@ nsMIMEInfoUnix::LaunchDefaultWithFile(nsIFile *aFile)
   return NS_ERROR_FAILURE;
 #endif
 
+  if( nsKDEUtils::kdeSupport()) {
+    bool supports;
+    if( NS_SUCCEEDED( GetHasDefaultHandler( &supports )) && supports ) {
+      nsTArray<nsCString> command;
+      command.AppendElement( NS_LITERAL_CSTRING( "OPEN" ));
+      command.AppendElement( nativePath );
+      command.AppendElement( NS_LITERAL_CSTRING( "MIMETYPE" ));
+      command.AppendElement( mSchemeOrType );
+      if( nsKDEUtils::command( command ))
+        return NS_OK;
+    }
+    if (!mDefaultApplication)
+      return NS_ERROR_FILE_NOT_FOUND;
+
+    return LaunchWithIProcess(mDefaultApplication, nativePath);
+  }
+
   nsCOMPtr<nsIGIOService> giovfs = do_GetService(NS_GIOSERVICE_CONTRACTID);
   if (!giovfs) {
     return NS_ERROR_FAILURE;
diff --git a/uriloader/exthandler/unix/nsOSHelperAppService.cpp b/uriloader/exthandler/unix/nsOSHelperAppService.cpp
index e1ac2582e65b..ea762d0c1383 100644
--- a/uriloader/exthandler/unix/nsOSHelperAppService.cpp
+++ b/uriloader/exthandler/unix/nsOSHelperAppService.cpp
@@ -15,7 +15,7 @@
 #include "nsOSHelperAppService.h"
 #include "nsMIMEInfoUnix.h"
 #ifdef MOZ_WIDGET_GTK
-#include "nsGNOMERegistry.h"
+#include "nsCommonRegistry.h"
 #endif
 #include "nsISupports.h"
 #include "nsString.h"
@@ -1148,7 +1148,7 @@ nsresult nsOSHelperAppService::OSProtocolHandlerExists(const char * aProtocolSch
 
 #ifdef MOZ_WIDGET_GTK
   // Check the GNOME registry for a protocol handler
-  *aHandlerExists = nsGNOMERegistry::HandlerExists(aProtocolScheme);
+  *aHandlerExists = nsCommonRegistry::HandlerExists(aProtocolScheme);
 #endif
 
   return NS_OK;
@@ -1157,7 +1157,7 @@ nsresult nsOSHelperAppService::OSProtocolHandlerExists(const char * aProtocolSch
 NS_IMETHODIMP nsOSHelperAppService::GetApplicationDescription(const nsACString& aScheme, nsAString& _retval)
 {
 #ifdef MOZ_WIDGET_GTK
-  nsGNOMERegistry::GetAppDescForScheme(aScheme, _retval);
+  nsCommonRegistry::GetAppDescForScheme(aScheme, _retval);
   return _retval.IsEmpty() ? NS_ERROR_NOT_AVAILABLE : NS_OK;
 #else
   return NS_ERROR_NOT_AVAILABLE;
@@ -1254,7 +1254,7 @@ nsOSHelperAppService::GetFromExtension(const nsCString& aFileExt) {
 #ifdef MOZ_WIDGET_GTK
     LOG(("Looking in GNOME registry\n"));
     RefPtr<nsMIMEInfoBase> gnomeInfo =
-      nsGNOMERegistry::GetFromExtension(aFileExt);
+      nsCommonRegistry::GetFromExtension(aFileExt);
     if (gnomeInfo) {
       LOG(("Got MIMEInfo from GNOME registry\n"));
       return gnomeInfo.forget();
@@ -1375,7 +1375,7 @@ nsOSHelperAppService::GetFromType(const nsCString& aMIMEType) {
 
 #ifdef MOZ_WIDGET_GTK
   if (handler.IsEmpty()) {
-    RefPtr<nsMIMEInfoBase> gnomeInfo = nsGNOMERegistry::GetFromType(aMIMEType);
+    RefPtr<nsMIMEInfoBase> gnomeInfo = nsCommonRegistry::GetFromType(aMIMEType);
     if (gnomeInfo) {
       LOG(("Got MIMEInfo from GNOME registry without extensions; setting them "
            "to %s\n", NS_LossyConvertUTF16toASCII(extensions).get()));
diff --git a/widget/gtk/moz.build b/widget/gtk/moz.build
index 59eafda2fd1e..75f03a07d796 100644
--- a/widget/gtk/moz.build
+++ b/widget/gtk/moz.build
@@ -33,10 +33,18 @@ UNIFIED_SOURCES += [
     'nsAppShell.cpp',
     'nsBidiKeyboard.cpp',
     'nsColorPicker.cpp',
+    'nsDbusmenu.cpp',
     'nsFilePicker.cpp',
     'nsGtkKeyUtils.cpp',
     'nsImageToPixbuf.cpp',
     'nsLookAndFeel.cpp',
+    'nsMenuBar.cpp',
+    'nsMenuContainer.cpp',
+    'nsMenuItem.cpp',
+    'nsMenuObject.cpp',
+    'nsMenuSeparator.cpp',
+    'nsNativeMenuAtoms.cpp',
+    'nsNativeMenuDocListener.cpp',
     'nsNativeThemeGTK.cpp',
     'nsSound.cpp',
     'nsToolkit.cpp',
@@ -48,6 +56,8 @@ UNIFIED_SOURCES += [
 ]
 
 SOURCES += [
+    'nsMenu.cpp', # conflicts with X11 headers
+    'nsNativeMenuService.cpp',
     'nsWindow.cpp', # conflicts with X11 headers
 ]
 
@@ -112,8 +122,10 @@ FINAL_LIBRARY = 'xul'
 
 LOCAL_INCLUDES += [
     '/layout/generic',
+    '/layout/style',
     '/layout/xul',
     '/other-licenses/atk-1.0',
+    '/toolkit/xre',
     '/widget',
     '/widget/headless',
 ]
diff --git a/widget/gtk/nsDbusmenu.cpp b/widget/gtk/nsDbusmenu.cpp
new file mode 100644
index 000000000000..98ba3c975e74
--- /dev/null
+++ b/widget/gtk/nsDbusmenu.cpp
@@ -0,0 +1,63 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* vim:expandtab:shiftwidth=4:tabstop=4:
+ */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "nsDbusmenu.h"
+#include "prlink.h"
+#include "mozilla/ArrayUtils.h"
+
+#define FUNC(name, type, params) \
+nsDbusmenuFunctions::_##name##_fn nsDbusmenuFunctions::s_##name;
+DBUSMENU_GLIB_FUNCTIONS
+DBUSMENU_GTK_FUNCTIONS
+#undef FUNC
+
+static PRLibrary *gDbusmenuGlib = nullptr;
+static PRLibrary *gDbusmenuGtk = nullptr;
+
+typedef void (*nsDbusmenuFunc)();
+struct nsDbusmenuDynamicFunction {
+    const char *functionName;
+    nsDbusmenuFunc *function;
+};
+
+/* static */ nsresult
+nsDbusmenuFunctions::Init()
+{
+#define FUNC(name, type, params) \
+    { #name, (nsDbusmenuFunc *)&nsDbusmenuFunctions::s_##name },
+    static const nsDbusmenuDynamicFunction kDbusmenuGlibSymbols[] = {
+        DBUSMENU_GLIB_FUNCTIONS
+    };
+    static const nsDbusmenuDynamicFunction kDbusmenuGtkSymbols[] = {
+        DBUSMENU_GTK_FUNCTIONS
+    };
+
+#define LOAD_LIBRARY(symbol, name) \
+    if (!g##symbol) { \
+        g##symbol = PR_LoadLibrary(name); \
+        if (!g##symbol) { \
+            return NS_ERROR_FAILURE; \
+        } \
+    } \
+    for (uint32_t i = 0; i < mozilla::ArrayLength(k##symbol##Symbols); ++i) { \
+        *k##symbol##Symbols[i].function = \
+            PR_FindFunctionSymbol(g##symbol, k##symbol##Symbols[i].functionName); \
+        if (!*k##symbol##Symbols[i].function) { \
+            return NS_ERROR_FAILURE; \
+        } \
+    }
+
+    LOAD_LIBRARY(DbusmenuGlib, "libdbusmenu-glib.so.4")
+#if (MOZ_WIDGET_GTK == 3)
+    LOAD_LIBRARY(DbusmenuGtk, "libdbusmenu-gtk3.so.4")
+#else
+    LOAD_LIBRARY(DbusmenuGtk, "libdbusmenu-gtk.so.4")
+#endif
+#undef LOAD_LIBRARY
+
+    return NS_OK;
+}
diff --git a/widget/gtk/nsDbusmenu.h b/widget/gtk/nsDbusmenu.h
new file mode 100644
index 000000000000..8d46a0d27bdb
--- /dev/null
+++ b/widget/gtk/nsDbusmenu.h
@@ -0,0 +1,101 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* vim:expandtab:shiftwidth=4:tabstop=4:
+ */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef __nsDbusmenu_h__
+#define __nsDbusmenu_h__
+
+#include "nsError.h"
+
+#include <glib.h>
+#include <gdk/gdk.h>
+
+#define DBUSMENU_GLIB_FUNCTIONS \
+    FUNC(dbusmenu_menuitem_child_add_position, gboolean, (DbusmenuMenuitem *mi, DbusmenuMenuitem *child, guint position)) \
+    FUNC(dbusmenu_menuitem_child_append, gboolean, (DbusmenuMenuitem *mi, DbusmenuMenuitem *child)) \
+    FUNC(dbusmenu_menuitem_child_delete, gboolean, (DbusmenuMenuitem *mi, DbusmenuMenuitem *child)) \
+    FUNC(dbusmenu_menuitem_get_children, GList*, (DbusmenuMenuitem *mi)) \
+    FUNC(dbusmenu_menuitem_new, DbusmenuMenuitem*, (void)) \
+    FUNC(dbusmenu_menuitem_property_get, const gchar*, (DbusmenuMenuitem *mi, const gchar *property)) \
+    FUNC(dbusmenu_menuitem_property_get_bool, gboolean, (DbusmenuMenuitem *mi, const gchar *property)) \
+    FUNC(dbusmenu_menuitem_property_remove, void, (DbusmenuMenuitem *mi, const gchar *property)) \
+    FUNC(dbusmenu_menuitem_property_set, gboolean, (DbusmenuMenuitem *mi, const gchar *property, const gchar *value)) \
+    FUNC(dbusmenu_menuitem_property_set_bool, gboolean, (DbusmenuMenuitem *mi, const gchar *property, const gboolean value)) \
+    FUNC(dbusmenu_menuitem_property_set_int, gboolean, (DbusmenuMenuitem *mi, const gchar *property, const gint value)) \
+    FUNC(dbusmenu_menuitem_show_to_user, void, (DbusmenuMenuitem *mi, guint timestamp)) \
+    FUNC(dbusmenu_menuitem_take_children, GList*, (DbusmenuMenuitem *mi)) \
+    FUNC(dbusmenu_server_new, DbusmenuServer*, (const gchar *object)) \
+    FUNC(dbusmenu_server_set_root, void, (DbusmenuServer *server, DbusmenuMenuitem *root)) \
+    FUNC(dbusmenu_server_set_status, void, (DbusmenuServer *server, DbusmenuStatus status))
+
+#define DBUSMENU_GTK_FUNCTIONS \
+    FUNC(dbusmenu_menuitem_property_set_image, gboolean, (DbusmenuMenuitem *menuitem, const gchar *property, const GdkPixbuf *data)) \
+    FUNC(dbusmenu_menuitem_property_set_shortcut, gboolean, (DbusmenuMenuitem *menuitem, guint key, GdkModifierType modifier))
+
+typedef struct _DbusmenuMenuitem DbusmenuMenuitem;
+typedef struct _DbusmenuServer DbusmenuServer;
+
+enum DbusmenuStatus {
+    DBUSMENU_STATUS_NORMAL,
+    DBUSMENU_STATUS_NOTICE
+};
+
+#define DBUSMENU_MENUITEM_CHILD_DISPLAY_SUBMENU "submenu"
+#define DBUSMENU_MENUITEM_PROP_CHILD_DISPLAY "children-display"
+#define DBUSMENU_MENUITEM_PROP_ENABLED "enabled"
+#define DBUSMENU_MENUITEM_PROP_ICON_DATA "icon-data"
+#define DBUSMENU_MENUITEM_PROP_LABEL "label"
+#define DBUSMENU_MENUITEM_PROP_SHORTCUT "shortcut"
+#define DBUSMENU_MENUITEM_PROP_TYPE "type"
+#define DBUSMENU_MENUITEM_PROP_TOGGLE_STATE "toggle-state"
+#define DBUSMENU_MENUITEM_PROP_TOGGLE_TYPE "toggle-type"
+#define DBUSMENU_MENUITEM_PROP_VISIBLE "visible"
+#define DBUSMENU_MENUITEM_SIGNAL_ABOUT_TO_SHOW "about-to-show"
+#define DBUSMENU_MENUITEM_SIGNAL_EVENT "event"
+#define DBUSMENU_MENUITEM_SIGNAL_ITEM_ACTIVATED "item-activated"
+#define DBUSMENU_MENUITEM_TOGGLE_CHECK "checkmark"
+#define DBUSMENU_MENUITEM_TOGGLE_RADIO "radio"
+#define DBUSMENU_MENUITEM_TOGGLE_STATE_CHECKED 1
+#define DBUSMENU_MENUITEM_TOGGLE_STATE_UNCHECKED 0
+#define DBUSMENU_SERVER_PROP_DBUS_OBJECT "dbus-object"
+
+class nsDbusmenuFunctions
+{
+public:
+    nsDbusmenuFunctions() = delete;
+
+    static nsresult Init();
+
+#define FUNC(name, type, params) \
+    typedef type (*_##name##_fn) params; \
+    static _##name##_fn s_##name;
+    DBUSMENU_GLIB_FUNCTIONS
+    DBUSMENU_GTK_FUNCTIONS
+#undef FUNC
+
+};
+
+#define dbusmenu_menuitem_child_add_position nsDbusmenuFunctions::s_dbusmenu_menuitem_child_add_position
+#define dbusmenu_menuitem_child_append nsDbusmenuFunctions::s_dbusmenu_menuitem_child_append
+#define dbusmenu_menuitem_child_delete nsDbusmenuFunctions::s_dbusmenu_menuitem_child_delete
+#define dbusmenu_menuitem_get_children nsDbusmenuFunctions::s_dbusmenu_menuitem_get_children
+#define dbusmenu_menuitem_new nsDbusmenuFunctions::s_dbusmenu_menuitem_new
+#define dbusmenu_menuitem_property_get nsDbusmenuFunctions::s_dbusmenu_menuitem_property_get
+#define dbusmenu_menuitem_property_get_bool nsDbusmenuFunctions::s_dbusmenu_menuitem_property_get_bool
+#define dbusmenu_menuitem_property_remove nsDbusmenuFunctions::s_dbusmenu_menuitem_property_remove
+#define dbusmenu_menuitem_property_set nsDbusmenuFunctions::s_dbusmenu_menuitem_property_set
+#define dbusmenu_menuitem_property_set_bool nsDbusmenuFunctions::s_dbusmenu_menuitem_property_set_bool
+#define dbusmenu_menuitem_property_set_int nsDbusmenuFunctions::s_dbusmenu_menuitem_property_set_int
+#define dbusmenu_menuitem_show_to_user nsDbusmenuFunctions::s_dbusmenu_menuitem_show_to_user
+#define dbusmenu_menuitem_take_children nsDbusmenuFunctions::s_dbusmenu_menuitem_take_children
+#define dbusmenu_server_new nsDbusmenuFunctions::s_dbusmenu_server_new
+#define dbusmenu_server_set_root nsDbusmenuFunctions::s_dbusmenu_server_set_root
+#define dbusmenu_server_set_status nsDbusmenuFunctions::s_dbusmenu_server_set_status
+
+#define dbusmenu_menuitem_property_set_image nsDbusmenuFunctions::s_dbusmenu_menuitem_property_set_image
+#define dbusmenu_menuitem_property_set_shortcut nsDbusmenuFunctions::s_dbusmenu_menuitem_property_set_shortcut
+
+#endif /* __nsDbusmenu_h__ */
diff --git a/widget/gtk/nsFilePicker.cpp b/widget/gtk/nsFilePicker.cpp
index 172cb4444849..baafbaf5fefd 100644
--- a/widget/gtk/nsFilePicker.cpp
+++ b/widget/gtk/nsFilePicker.cpp
@@ -9,6 +9,7 @@
 #include <unistd.h>
 
 #include <gtk/gtk.h>
+#include <gdk/gdkx.h>
 
 #include "nsGtkUtils.h"
 #include "nsIFileURL.h"
@@ -25,6 +26,7 @@
 #include "mozcontainer.h"
 
 #include "nsFilePicker.h"
+#include "nsKDEUtils.h"
 
 using namespace mozilla;
 
@@ -251,7 +253,9 @@ nsFilePicker::AppendFilter(const nsAString& aTitle, const nsAString& aFilter)
 {
   if (aFilter.EqualsLiteral("..apps")) {
     // No platform specific thing we can do here, really....
-    return NS_OK;
+    // Unless it's KDE.
+    if( mMode != modeOpen || !nsKDEUtils::kdeSupport())
+      return NS_OK;
   }
 
   nsAutoCString filter, name;
@@ -376,6 +380,29 @@ nsFilePicker::Open(nsIFilePickerShownCallback *aCallback)
   if (mRunning)
     return NS_ERROR_NOT_AVAILABLE;
 
+  // KDE file picker is not handled via callback
+  if( nsKDEUtils::kdeSupport()) {
+    mCallback = aCallback;
+    mRunning = true;
+    NS_ADDREF_THIS();
+    g_idle_add([](gpointer data) -> gboolean {
+      nsFilePicker* queuedPicker = (nsFilePicker*) data;
+      int16_t result;
+      queuedPicker->kdeFileDialog(&result);
+      if (queuedPicker->mCallback) {
+        queuedPicker->mCallback->Done(result);
+        queuedPicker->mCallback = nullptr;
+      } else {
+        queuedPicker->mResult = result;
+      }
+      queuedPicker->mRunning = false;
+      NS_RELEASE(queuedPicker);
+      return G_SOURCE_REMOVE;
+    }, this);
+
+    return NS_OK;
+  }
+
   nsXPIDLCString title;
   title.Adopt(ToNewUTF8String(mTitle));
 
@@ -608,3 +635,227 @@ nsFilePicker::Done(GtkWidget* file_chooser, gint response)
   }
   NS_RELEASE_THIS();
 }
+
+nsCString nsFilePicker::kdeMakeFilter( int index )
+    {
+    nsCString buf = mFilters[ index ];
+    for( PRUint32 i = 0;
+         i < buf.Length();
+         ++i )
+        if( buf[ i ] == ';' ) // KDE separates just using spaces
+            buf.SetCharAt( ' ', i );
+    if (!mFilterNames[index].IsEmpty())
+        {
+        buf += "|";
+        buf += mFilterNames[index].get();
+        }
+    return buf;
+    }
+
+static PRInt32 windowToXid( nsIWidget* widget )
+    {
+    GtkWindow *parent_widget = GTK_WINDOW(widget->GetNativeData(NS_NATIVE_SHELLWIDGET));
+    GdkWindow* gdk_window = gtk_widget_get_window( gtk_widget_get_toplevel( GTK_WIDGET( parent_widget )));
+    return GDK_WINDOW_XID( gdk_window );
+    }
+
+NS_IMETHODIMP nsFilePicker::kdeFileDialog(PRInt16 *aReturn)
+    {
+    NS_ENSURE_ARG_POINTER(aReturn);
+
+    if( mMode == modeOpen && mFilters.Length() == 1 && mFilters[ 0 ].EqualsLiteral( "..apps" ))
+        return kdeAppsDialog( aReturn );
+
+    nsXPIDLCString title;
+    title.Adopt(ToNewUTF8String(mTitle));
+
+    const char* arg = NULL;
+    if( mAllowURLs )
+        {
+        switch( mMode )
+            {
+            case nsIFilePicker::modeOpen:
+            case nsIFilePicker::modeOpenMultiple:
+                arg = "GETOPENURL";
+                break;
+            case nsIFilePicker::modeSave:
+                arg = "GETSAVEURL";
+                break;
+            case nsIFilePicker::modeGetFolder:
+                arg = "GETDIRECTORYURL";
+                break;
+            }
+        }
+    else
+        {
+        switch( mMode )
+            {
+            case nsIFilePicker::modeOpen:
+            case nsIFilePicker::modeOpenMultiple:
+                arg = "GETOPENFILENAME";
+                break;
+            case nsIFilePicker::modeSave:
+                arg = "GETSAVEFILENAME";
+                break;
+            case nsIFilePicker::modeGetFolder:
+                arg = "GETDIRECTORYFILENAME";
+                break;
+            }
+        }
+
+  nsAutoCString directory;
+  if (mDisplayDirectory) {
+    mDisplayDirectory->GetNativePath(directory);
+  } else if (mPrevDisplayDirectory) {
+    mPrevDisplayDirectory->GetNativePath(directory);
+  }
+
+    nsAutoCString startdir;
+  if (!directory.IsEmpty()) {
+    startdir = directory;
+  }
+  if (mMode == nsIFilePicker::modeSave) {
+    if( !startdir.IsEmpty())
+      {
+      startdir += "/";
+      startdir += ToNewUTF8String(mDefault);
+      }
+    else
+      startdir = ToNewUTF8String(mDefault);
+  }
+
+    nsAutoCString filters;
+    PRInt32 count = mFilters.Length();
+    if( count == 0 ) //just in case
+        filters = "*";
+    else
+        {
+        filters = kdeMakeFilter( 0 );
+        for (PRInt32 i = 1; i < count; ++i)
+            {
+            filters += "\n";
+            filters += kdeMakeFilter( i );
+            }
+        }
+
+    nsTArray<nsCString> command;
+    command.AppendElement( nsAutoCString( arg ));
+    command.AppendElement( startdir );
+    if( mMode != nsIFilePicker::modeGetFolder )
+        {
+        command.AppendElement( filters );
+        nsAutoCString selected;
+        selected.AppendInt( mSelectedType );
+        command.AppendElement( selected );
+        }
+    command.AppendElement( title );
+    if( mMode == nsIFilePicker::modeOpenMultiple )
+        command.AppendElement( NS_LITERAL_CSTRING( "MULTIPLE" ));
+    if( PRInt32 xid = windowToXid( mParentWidget ))
+        {
+        command.AppendElement( NS_LITERAL_CSTRING( "PARENT" ));
+        nsAutoCString parent;
+        parent.AppendInt( xid );
+        command.AppendElement( parent );
+        }
+
+    nsTArray<nsCString> output;
+    if( nsKDEUtils::commandBlockUi( command, GTK_WINDOW(mParentWidget->GetNativeData(NS_NATIVE_SHELLWIDGET)), &output ))
+        {
+        *aReturn = nsIFilePicker::returnOK;
+        mFiles.Clear();
+        if( mMode != nsIFilePicker::modeGetFolder )
+            {
+            mSelectedType = atoi( output[ 0 ].get());
+            output.RemoveElementAt( 0 );
+            }
+        if (mMode == nsIFilePicker::modeOpenMultiple)
+            {
+            mFileURL.Truncate();
+            PRUint32 count = output.Length();
+            for( PRUint32 i = 0;
+                 i < count;
+                 ++i )
+                {
+                nsCOMPtr<nsIFile> localfile;
+                nsresult rv = NS_NewNativeLocalFile( output[ i ],
+                                      PR_FALSE,
+                                      getter_AddRefs(localfile));
+                if (NS_SUCCEEDED(rv))
+                    mFiles.AppendObject(localfile);
+                }
+            }
+        else
+            {
+            if( output.Length() == 0 )
+                mFileURL = nsCString();
+            else if( mAllowURLs )
+                mFileURL = output[ 0 ];
+            else // GetFile() actually requires it to be url even for local files :-/
+                {
+                mFileURL = nsCString( "file://" );
+                mFileURL.Append( output[ 0 ] );
+                }
+            }
+  // Remember last used directory.
+  nsCOMPtr<nsIFile> file;
+  GetFile(getter_AddRefs(file));
+  if (file) {
+    nsCOMPtr<nsIFile> dir;
+    file->GetParent(getter_AddRefs(dir));
+    nsCOMPtr<nsIFile> localDir(do_QueryInterface(dir));
+    if (localDir) {
+      localDir.swap(mPrevDisplayDirectory);
+    }
+  }
+        if (mMode == nsIFilePicker::modeSave)
+            {
+            nsCOMPtr<nsIFile> file;
+            GetFile(getter_AddRefs(file));
+            if (file)
+                {
+                bool exists = false;
+                file->Exists(&exists);
+                if (exists) // TODO do overwrite check in the helper app
+                    *aReturn = nsIFilePicker::returnReplace;
+                }
+            }
+        }
+    else
+        {
+        *aReturn = nsIFilePicker::returnCancel;
+        }
+    return NS_OK;
+    }
+
+
+NS_IMETHODIMP nsFilePicker::kdeAppsDialog(PRInt16 *aReturn)
+    {
+    NS_ENSURE_ARG_POINTER(aReturn);
+
+    nsXPIDLCString title;
+    title.Adopt(ToNewUTF8String(mTitle));
+
+    nsTArray<nsCString> command;
+    command.AppendElement( NS_LITERAL_CSTRING( "APPSDIALOG" ));
+    command.AppendElement( title );
+    if( PRInt32 xid = windowToXid( mParentWidget ))
+        {
+        command.AppendElement( NS_LITERAL_CSTRING( "PARENT" ));
+        nsAutoCString parent;
+        parent.AppendInt( xid );
+        command.AppendElement( parent );
+        }
+
+    nsTArray<nsCString> output;
+    if( nsKDEUtils::commandBlockUi( command, GTK_WINDOW(mParentWidget->GetNativeData(NS_NATIVE_SHELLWIDGET)), &output ))
+        {
+        *aReturn = nsIFilePicker::returnOK;
+        mFileURL = output.Length() > 0 ? output[ 0 ] : nsCString();
+        }
+    else
+        {
+        *aReturn = nsIFilePicker::returnCancel;
+        }
+    return NS_OK;
+    }
diff --git a/widget/gtk/nsFilePicker.h b/widget/gtk/nsFilePicker.h
index 2b5042098c65..2b02d412d6d7 100644
--- a/widget/gtk/nsFilePicker.h
+++ b/widget/gtk/nsFilePicker.h
@@ -74,6 +74,12 @@ protected:
 private:
   static nsIFile *mPrevDisplayDirectory;
 
+  bool kdeRunning();
+  bool getKdeRunning();
+  NS_IMETHODIMP kdeFileDialog(PRInt16 *aReturn);
+  NS_IMETHODIMP kdeAppsDialog(PRInt16 *aReturn);
+  nsCString kdeMakeFilter( int index );
+
 #if (MOZ_WIDGET_GTK == 3)
   GtkFileChooserWidget *mFileChooserDelegate;
 #endif
diff --git a/widget/gtk/nsMenu.cpp b/widget/gtk/nsMenu.cpp
new file mode 100644
index 000000000000..1392cfe86525
--- /dev/null
+++ b/widget/gtk/nsMenu.cpp
@@ -0,0 +1,857 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* vim:expandtab:shiftwidth=4:tabstop=4:
+ */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#define _IMPL_NS_LAYOUT
+
+#include "mozilla/dom/Element.h"
+#include "mozilla/Assertions.h"
+#include "mozilla/EventDispatcher.h"
+#include "mozilla/GeckoStyleContext.h"
+#include "mozilla/GuardObjects.h"
+#include "mozilla/MouseEvents.h"
+#include "mozilla/Move.h"
+#include "mozilla/ServoStyleContext.h"
+#include "mozilla/ServoStyleSet.h"
+#include "mozilla/ServoTypes.h"
+#include "mozilla/StyleSetHandleInlines.h"
+#include "nsAutoPtr.h"
+#include "nsBindingManager.h"
+#include "nsComponentManagerUtils.h"
+#include "nsContentUtils.h"
+#include "nsCSSValue.h"
+#include "nsGkAtoms.h"
+#include "nsGtkUtils.h"
+#include "nsIAtom.h"
+#include "nsIContent.h"
+#include "nsIDocument.h"
+#include "nsIPresShell.h"
+#include "nsIRunnable.h"
+#include "nsITimer.h"
+#include "nsString.h"
+#include "nsStyleContext.h"
+#include "nsStyleContextInlines.h"
+#include "nsStyleSet.h"
+#include "nsStyleStruct.h"
+#include "nsThreadUtils.h"
+#include "nsXBLBinding.h"
+#include "nsXBLService.h"
+
+#include "nsNativeMenuAtoms.h"
+#include "nsNativeMenuDocListener.h"
+
+#include <glib-object.h>
+
+#include "nsMenu.h"
+
+using namespace mozilla;
+
+class nsMenuContentInsertedEvent : public Runnable
+{
+public:
+    nsMenuContentInsertedEvent(nsMenu *aMenu,
+                               nsIContent *aContainer,
+                               nsIContent *aChild,
+                               nsIContent *aPrevSibling) :
+        Runnable("nsMenuContentInsertedEvent"),
+        mWeakMenu(aMenu),
+        mContainer(aContainer),
+        mChild(aChild),
+        mPrevSibling(aPrevSibling) { }
+
+    NS_IMETHODIMP Run()
+    {
+        if (!mWeakMenu) {
+            return NS_OK;
+        }
+
+        static_cast<nsMenu *>(mWeakMenu.get())->HandleContentInserted(mContainer,
+                                                                      mChild,
+                                                                      mPrevSibling);
+        return NS_OK;
+    }
+
+private:
+    nsWeakMenuObject mWeakMenu;
+
+    nsCOMPtr<nsIContent> mContainer;
+    nsCOMPtr<nsIContent> mChild;
+    nsCOMPtr<nsIContent> mPrevSibling;
+};
+
+class nsMenuContentRemovedEvent : public Runnable
+{
+public:
+    nsMenuContentRemovedEvent(nsMenu *aMenu,
+                              nsIContent *aContainer,
+                              nsIContent *aChild) :
+        Runnable("nsMenuContentRemovedEvent"),
+        mWeakMenu(aMenu),
+        mContainer(aContainer),
+        mChild(aChild) { }
+
+    NS_IMETHODIMP Run()
+    {
+        if (!mWeakMenu) {
+            return NS_OK;
+        }
+
+        static_cast<nsMenu *>(mWeakMenu.get())->HandleContentRemoved(mContainer,
+                                                                     mChild);
+        return NS_OK;
+    }
+
+private:
+    nsWeakMenuObject mWeakMenu;
+
+    nsCOMPtr<nsIContent> mContainer;
+    nsCOMPtr<nsIContent> mChild;
+};
+
+static void
+DispatchMouseEvent(nsIContent *aTarget, mozilla::EventMessage aMsg)
+{
+    if (!aTarget) {
+        return;
+    }
+
+    WidgetMouseEvent event(true, aMsg, nullptr, WidgetMouseEvent::eReal);
+    EventDispatcher::Dispatch(aTarget, nullptr, &event);
+}
+
+static void
+AttachXBLBindings(nsIContent *aContent)
+{
+    nsIDocument *doc = aContent->OwnerDoc();
+    nsIPresShell *shell = doc->GetShell();
+    if (!shell) {
+        return;
+    }
+
+    RefPtr<nsStyleContext> sc;
+    if (shell->StyleSet()->IsGecko()) {
+        sc = shell->StyleSet()->AsGecko()->ResolveStyleFor(aContent->AsElement(),
+                                                           nullptr);
+    } else {
+        sc = shell->StyleSet()->AsServo()->ResolveStyleFor(aContent->AsElement(),
+                                                           nullptr,
+                                                           LazyComputeBehavior::Allow);
+    }
+
+    if (!sc) {
+        return;
+    }
+
+    const nsStyleDisplay* display = sc->StyleDisplay();
+    if (!display->mBinding) {
+        return;
+    }
+
+    nsXBLService* xbl = nsXBLService::GetInstance();
+    if (!xbl) {
+        return;
+    }
+
+    RefPtr<nsXBLBinding> binding;
+    bool dummy;
+    nsresult rv = xbl->LoadBindings(aContent, display->mBinding->GetURI(),
+                                    display->mBinding->mExtraData->GetPrincipal(),
+                                    getter_AddRefs(binding), &dummy);
+    if ((NS_FAILED(rv) && rv != NS_ERROR_XBL_BLOCKED) || !binding) {
+        return;
+    }
+
+    doc->BindingManager()->AddToAttachedQueue(binding);
+}
+
+void
+nsMenu::SetPopupState(EPopupState aState)
+{
+    mPopupState = aState;
+
+    if (!mPopupContent) {
+        return;
+    }
+
+    nsAutoString state;
+    switch (aState) {
+        case ePopupState_Showing:
+            state.Assign(NS_LITERAL_STRING("showing"));
+            break;
+        case ePopupState_Open:
+            state.Assign(NS_LITERAL_STRING("open"));
+            break;
+        case ePopupState_Hiding:
+            state.Assign(NS_LITERAL_STRING("hiding"));
+            break;
+        default:
+            break;
+    }
+
+    if (state.IsEmpty()) {
+        mPopupContent->UnsetAttr(kNameSpaceID_None,
+                                 nsNativeMenuAtoms::_moz_nativemenupopupstate,
+                                 false);
+    } else {
+        mPopupContent->SetAttr(kNameSpaceID_None,
+                               nsNativeMenuAtoms::_moz_nativemenupopupstate,
+                               state, false);
+    }
+}
+
+/* static */ void
+nsMenu::DoOpenCallback(nsITimer *aTimer, void *aClosure)
+{
+    nsMenu* self = static_cast<nsMenu *>(aClosure);
+
+    dbusmenu_menuitem_show_to_user(self->GetNativeData(), 0);
+
+    self->mOpenDelayTimer = nullptr;
+}
+
+/* static */ void
+nsMenu::menu_event_cb(DbusmenuMenuitem *menu,
+                      const gchar *name,
+                      GVariant *value,
+                      guint timestamp,
+                      gpointer user_data)
+{
+    nsMenu *self = static_cast<nsMenu *>(user_data);
+
+    nsAutoCString event(name);
+
+    if (event.Equals(NS_LITERAL_CSTRING("closed"))) {
+        self->OnClose();
+        return;
+    }
+
+    if (event.Equals(NS_LITERAL_CSTRING("opened"))) {
+        self->OnOpen();
+        return;
+    }
+}
+
+void
+nsMenu::MaybeAddPlaceholderItem()
+{
+    MOZ_ASSERT(!IsInBatchedUpdate(),
+               "Shouldn't be modifying the native menu structure now");
+
+    GList *children = dbusmenu_menuitem_get_children(GetNativeData());
+    if (!children) {
+        MOZ_ASSERT(!mPlaceholderItem);
+
+        mPlaceholderItem = dbusmenu_menuitem_new();
+        if (!mPlaceholderItem) {
+            return;
+        }
+
+        dbusmenu_menuitem_property_set_bool(mPlaceholderItem,
+                                            DBUSMENU_MENUITEM_PROP_VISIBLE,
+                                            false);
+
+        MOZ_ALWAYS_TRUE(
+            dbusmenu_menuitem_child_append(GetNativeData(), mPlaceholderItem));
+    }
+}
+
+void
+nsMenu::EnsureNoPlaceholderItem()
+{
+    MOZ_ASSERT(!IsInBatchedUpdate(),
+               "Shouldn't be modifying the native menu structure now");
+
+    if (!mPlaceholderItem) {
+        return;
+    }
+
+    MOZ_ALWAYS_TRUE(
+        dbusmenu_menuitem_child_delete(GetNativeData(), mPlaceholderItem));
+    MOZ_ASSERT(!dbusmenu_menuitem_get_children(GetNativeData()));
+
+    g_object_unref(mPlaceholderItem);
+    mPlaceholderItem = nullptr;
+}
+
+void
+nsMenu::OnOpen()
+{
+    if (mNeedsRebuild) {
+        Build();
+    }
+
+    nsWeakMenuObject self(this);
+    nsCOMPtr<nsIContent> origPopupContent(mPopupContent);
+    {
+        nsNativeMenuDocListener::BlockUpdatesScope updatesBlocker;
+
+        SetPopupState(ePopupState_Showing);
+        DispatchMouseEvent(mPopupContent, eXULPopupShowing);
+
+        ContentNode()->SetAttr(kNameSpaceID_None, nsGkAtoms::open,
+                               NS_LITERAL_STRING("true"), true);
+    }
+
+    if (!self) {
+        // We were deleted!
+        return;
+    }
+
+    // I guess that the popup could have changed
+    if (origPopupContent != mPopupContent) {
+        return;
+    }
+
+    nsNativeMenuDocListener::BlockUpdatesScope updatesBlocker;
+
+    size_t count = ChildCount();
+    for (size_t i = 0; i < count; ++i) {
+        ChildAt(i)->ContainerIsOpening();
+    }
+
+    SetPopupState(ePopupState_Open);
+    DispatchMouseEvent(mPopupContent, eXULPopupShown);
+}
+
+void
+nsMenu::Build()
+{
+    mNeedsRebuild = false;
+
+    while (ChildCount() > 0) {
+        RemoveChildAt(0);
+    }
+
+    InitializePopup();
+
+    if (!mPopupContent) {
+        return;
+    }
+
+    uint32_t count = mPopupContent->GetChildCount();
+    for (uint32_t i = 0; i < count; ++i) {
+        nsIContent *childContent = mPopupContent->GetChildAt(i);
+
+        UniquePtr<nsMenuObject> child = CreateChild(childContent);
+
+        if (!child) {
+            continue;
+        }
+
+        AppendChild(Move(child));
+    }
+}
+
+void
+nsMenu::InitializePopup()
+{
+    nsCOMPtr<nsIContent> oldPopupContent;
+    oldPopupContent.swap(mPopupContent);
+
+    for (uint32_t i = 0; i < ContentNode()->GetChildCount(); ++i) {
+        nsIContent *child = ContentNode()->GetChildAt(i);
+
+        int32_t dummy;
+        nsCOMPtr<nsIAtom> tag = child->OwnerDoc()->BindingManager()->ResolveTag(child, &dummy);
+        if (tag == nsGkAtoms::menupopup) {
+            mPopupContent = child;
+            break;
+        }
+    }
+
+    if (oldPopupContent == mPopupContent) {
+        return;
+    }
+
+    // The popup has changed
+
+    if (oldPopupContent) {
+        DocListener()->UnregisterForContentChanges(oldPopupContent);
+    }
+
+    SetPopupState(ePopupState_Closed);
+
+    if (!mPopupContent) {
+        return;
+    }
+
+    AttachXBLBindings(mPopupContent);
+
+    DocListener()->RegisterForContentChanges(mPopupContent, this);
+}
+
+void
+nsMenu::RemoveChildAt(size_t aIndex)
+{
+    MOZ_ASSERT(IsInBatchedUpdate() || !mPlaceholderItem,
+               "Shouldn't have a placeholder menuitem");
+
+    nsMenuContainer::RemoveChildAt(aIndex, !IsInBatchedUpdate());
+    StructureMutated();
+
+    if (!IsInBatchedUpdate()) {
+        MaybeAddPlaceholderItem();
+    }
+}
+
+void
+nsMenu::RemoveChild(nsIContent *aChild)
+{
+    size_t index = IndexOf(aChild);
+    if (index == NoIndex) {
+        return;
+    }
+
+    RemoveChildAt(index);
+}
+
+void
+nsMenu::InsertChildAfter(UniquePtr<nsMenuObject> aChild,
+                         nsIContent *aPrevSibling)
+{
+    if (!IsInBatchedUpdate()) {
+        EnsureNoPlaceholderItem();
+    }
+
+    nsMenuContainer::InsertChildAfter(Move(aChild), aPrevSibling,
+                                      !IsInBatchedUpdate());
+    StructureMutated();
+}
+
+void
+nsMenu::AppendChild(UniquePtr<nsMenuObject> aChild)
+{
+    if (!IsInBatchedUpdate()) {
+        EnsureNoPlaceholderItem();
+    }
+
+    nsMenuContainer::AppendChild(Move(aChild), !IsInBatchedUpdate());
+    StructureMutated();
+}
+
+bool
+nsMenu::IsInBatchedUpdate() const
+{
+    return mBatchedUpdateState != eBatchedUpdateState_Inactive;
+}
+
+void
+nsMenu::StructureMutated()
+{
+    if (!IsInBatchedUpdate()) {
+        return;
+    }
+
+    mBatchedUpdateState = eBatchedUpdateState_DidMutate;
+}
+
+bool
+nsMenu::CanOpen() const
+{
+    bool isVisible = dbusmenu_menuitem_property_get_bool(GetNativeData(),
+                                                         DBUSMENU_MENUITEM_PROP_VISIBLE);
+    bool isDisabled = ContentNode()->AttrValueIs(kNameSpaceID_None,
+                                                 nsGkAtoms::disabled,
+                                                 nsGkAtoms::_true,
+                                                 eCaseMatters);
+
+    return (isVisible && !isDisabled);
+}
+
+void
+nsMenu::HandleContentInserted(nsIContent *aContainer,
+                              nsIContent *aChild,
+                              nsIContent *aPrevSibling)
+{
+    if (aContainer == mPopupContent) {
+        UniquePtr<nsMenuObject> child = CreateChild(aChild);
+
+        if (child) {
+            InsertChildAfter(Move(child), aPrevSibling);
+        }
+    } else {
+        Build();
+    }
+}
+
+void
+nsMenu::HandleContentRemoved(nsIContent *aContainer, nsIContent *aChild)
+{
+    if (aContainer == mPopupContent) {
+        RemoveChild(aChild);
+    } else {
+        Build();
+    }
+}
+
+void
+nsMenu::InitializeNativeData()
+{
+    // Dbusmenu provides an "about-to-show" signal, and also "opened" and
+    // "closed" events. However, Unity is the only thing that sends
+    // both "about-to-show" and "opened" events. Unity 2D and the HUD only
+    // send "opened" events, so we ignore "about-to-show" (I don't think
+    // there's any real difference between them anyway).
+    // To complicate things, there are certain conditions where we don't
+    // get a "closed" event, so we need to be able to handle this :/
+    g_signal_connect(G_OBJECT(GetNativeData()), "event",
+                     G_CALLBACK(menu_event_cb), this);
+
+    mNeedsRebuild = true;
+    mNeedsUpdate = true;
+
+    MaybeAddPlaceholderItem();
+
+    AttachXBLBindings(ContentNode());
+}
+
+void
+nsMenu::Update(nsStyleContext *aStyleContext)
+{
+    if (mNeedsUpdate) {
+        mNeedsUpdate = false;
+
+        UpdateLabel();
+        UpdateSensitivity();
+    }
+
+    UpdateVisibility(aStyleContext);
+    UpdateIcon(aStyleContext);
+}
+
+nsMenuObject::PropertyFlags
+nsMenu::SupportedProperties() const
+{
+    return static_cast<nsMenuObject::PropertyFlags>(
+        nsMenuObject::ePropLabel |
+        nsMenuObject::ePropEnabled |
+        nsMenuObject::ePropVisible |
+        nsMenuObject::ePropIconData |
+        nsMenuObject::ePropChildDisplay
+    );
+}
+
+void
+nsMenu::OnAttributeChanged(nsIContent *aContent, nsIAtom *aAttribute)
+{
+    MOZ_ASSERT(aContent == ContentNode() || aContent == mPopupContent,
+               "Received an event that wasn't meant for us!");
+
+    if (mNeedsUpdate) {
+        return;
+    }
+
+    if (aContent != ContentNode()) {
+        return;
+    }
+
+    if (!Parent()->IsBeingDisplayed()) {
+        mNeedsUpdate = true;
+        return;
+    }
+
+    if (aAttribute == nsGkAtoms::disabled) {
+        UpdateSensitivity();
+    } else if (aAttribute == nsGkAtoms::label ||
+               aAttribute == nsGkAtoms::accesskey ||
+               aAttribute == nsGkAtoms::crop) {
+        UpdateLabel();
+    } else if (aAttribute == nsGkAtoms::hidden ||
+        aAttribute == nsGkAtoms::collapsed) {
+        RefPtr<nsStyleContext> sc = GetStyleContext();
+        UpdateVisibility(sc);
+    } else if (aAttribute == nsGkAtoms::image) {
+        RefPtr<nsStyleContext> sc = GetStyleContext();
+        UpdateIcon(sc);
+    }
+}
+
+void
+nsMenu::OnContentInserted(nsIContent *aContainer, nsIContent *aChild,
+                          nsIContent *aPrevSibling)
+{
+    MOZ_ASSERT(aContainer == ContentNode() || aContainer == mPopupContent,
+               "Received an event that wasn't meant for us!");
+
+    if (mNeedsRebuild) {
+        return;
+    }
+
+    if (mPopupState == ePopupState_Closed) {
+        mNeedsRebuild = true;
+        return;
+    }
+
+    nsContentUtils::AddScriptRunner(
+        new nsMenuContentInsertedEvent(this, aContainer, aChild,
+                                       aPrevSibling));
+}
+
+void
+nsMenu::OnContentRemoved(nsIContent *aContainer, nsIContent *aChild)
+{
+    MOZ_ASSERT(aContainer == ContentNode() || aContainer == mPopupContent,
+               "Received an event that wasn't meant for us!");
+
+    if (mNeedsRebuild) {
+        return;
+    }
+
+    if (mPopupState == ePopupState_Closed) {
+        mNeedsRebuild = true;
+        return;
+    }
+
+    nsContentUtils::AddScriptRunner(
+        new nsMenuContentRemovedEvent(this, aContainer, aChild));
+}
+
+/*
+ * Some menus (eg, the History menu in Firefox) refresh themselves on
+ * opening by removing all children and then re-adding new ones. As this
+ * happens whilst the menu is opening in Unity, it causes some flickering
+ * as the menu popup is resized multiple times. To avoid this, we try to
+ * reuse native menu items when the menu structure changes during a
+ * batched update. If we can handle menu structure changes from Gecko
+ * just by updating properties of native menu items (rather than destroying
+ * and creating new ones), then we eliminate any flickering that occurs as
+ * the menu is opened. To do this, we don't modify any native menu items
+ * until the end of the update batch.
+ */
+
+void
+nsMenu::OnBeginUpdates(nsIContent *aContent)
+{
+    MOZ_ASSERT(aContent == ContentNode() || aContent == mPopupContent,
+               "Received an event that wasn't meant for us!");
+    MOZ_ASSERT(!IsInBatchedUpdate(), "Already in an update batch!");
+
+    if (aContent != mPopupContent) {
+        return;
+    }
+
+    mBatchedUpdateState = eBatchedUpdateState_Active;
+}
+
+void
+nsMenu::OnEndUpdates()
+{
+    if (!IsInBatchedUpdate()) {
+        return;
+    }
+
+    bool didMutate = mBatchedUpdateState == eBatchedUpdateState_DidMutate;
+    mBatchedUpdateState = eBatchedUpdateState_Inactive;
+
+    /* Optimize for the case where we only had attribute changes */
+    if (!didMutate) {
+        return;
+    }
+
+    EnsureNoPlaceholderItem();
+
+    GList *nextNativeChild = dbusmenu_menuitem_get_children(GetNativeData());
+    DbusmenuMenuitem *nextOwnedNativeChild = nullptr;
+
+    size_t count = ChildCount();
+
+    // Find the first native menu item that is `owned` by a corresponding
+    // Gecko menuitem
+    for (size_t i = 0; i < count; ++i) {
+        if (ChildAt(i)->GetNativeData()) {
+            nextOwnedNativeChild = ChildAt(i)->GetNativeData();
+            break;
+        }
+    }
+
+    // Now iterate over all Gecko menuitems
+    for (size_t i = 0; i < count; ++i) {
+        nsMenuObject *child = ChildAt(i);
+
+        if (child->GetNativeData()) {
+            // This child already has a corresponding native menuitem.
+            // Remove all preceding orphaned native items. At this point, we
+            // modify the native menu structure.
+            while (nextNativeChild &&
+                   nextNativeChild->data != nextOwnedNativeChild) {
+
+                DbusmenuMenuitem *data =
+                    static_cast<DbusmenuMenuitem *>(nextNativeChild->data);
+                nextNativeChild = nextNativeChild->next;
+
+                MOZ_ALWAYS_TRUE(dbusmenu_menuitem_child_delete(GetNativeData(),
+                                                               data));
+            }
+
+            if (nextNativeChild) {
+                nextNativeChild = nextNativeChild->next;
+            }
+
+            // Now find the next native menu item that is `owned`
+            nextOwnedNativeChild = nullptr;
+            for (size_t j = i + 1; j < count; ++j) {
+                if (ChildAt(j)->GetNativeData()) {
+                    nextOwnedNativeChild = ChildAt(j)->GetNativeData();
+                    break;
+                }
+            }
+        } else {
+            // This child is new, and doesn't have a native menu item. Find one!
+            if (nextNativeChild &&
+                nextNativeChild->data != nextOwnedNativeChild) {
+
+                DbusmenuMenuitem *data =
+                    static_cast<DbusmenuMenuitem *>(nextNativeChild->data);
+
+                if (NS_SUCCEEDED(child->AdoptNativeData(data))) {
+                    nextNativeChild = nextNativeChild->next;
+                }
+            }
+
+            // There wasn't a suitable one available, so create a new one.
+            // At this point, we modify the native menu structure.
+            if (!child->GetNativeData()) {
+                child->CreateNativeData();
+                MOZ_ALWAYS_TRUE(
+                    dbusmenu_menuitem_child_add_position(GetNativeData(),
+                                                         child->GetNativeData(),
+                                                         i));
+            }
+        }
+    }
+
+    while (nextNativeChild) {
+        DbusmenuMenuitem *data =
+            static_cast<DbusmenuMenuitem *>(nextNativeChild->data);
+        nextNativeChild = nextNativeChild->next;
+
+        MOZ_ALWAYS_TRUE(dbusmenu_menuitem_child_delete(GetNativeData(), data));
+    }
+
+    MaybeAddPlaceholderItem();
+}
+
+nsMenu::nsMenu(nsMenuContainer *aParent, nsIContent *aContent) :
+    nsMenuContainer(aParent, aContent),
+    mNeedsRebuild(false),
+    mNeedsUpdate(false),
+    mPlaceholderItem(nullptr),
+    mPopupState(ePopupState_Closed),
+    mBatchedUpdateState(eBatchedUpdateState_Inactive)
+{
+    MOZ_COUNT_CTOR(nsMenu);
+}
+
+nsMenu::~nsMenu()
+{
+    if (IsInBatchedUpdate()) {
+        OnEndUpdates();
+    }
+
+    // Although nsTArray will take care of this in its destructor,
+    // we have to manually ensure children are removed from our native menu
+    // item, just in case our parent recycles us
+    while (ChildCount() > 0) {
+        RemoveChildAt(0);
+    }
+
+    EnsureNoPlaceholderItem();
+
+    if (DocListener() && mPopupContent) {
+        DocListener()->UnregisterForContentChanges(mPopupContent);
+    }
+
+    if (GetNativeData()) {
+        g_signal_handlers_disconnect_by_func(GetNativeData(),
+                                             FuncToGpointer(menu_event_cb),
+                                             this);
+    }
+
+    MOZ_COUNT_DTOR(nsMenu);
+}
+
+nsMenuObject::EType
+nsMenu::Type() const
+{
+    return eType_Menu;
+}
+
+bool
+nsMenu::IsBeingDisplayed() const
+{
+    return mPopupState == ePopupState_Open;
+}
+
+bool
+nsMenu::NeedsRebuild() const
+{
+    return mNeedsRebuild;
+}
+
+void
+nsMenu::OpenMenu()
+{
+    if (!CanOpen()) {
+        return;
+    }
+
+    if (mOpenDelayTimer) {
+        return;
+    }
+
+    // Here, we synchronously fire popupshowing and popupshown events and then
+    // open the menu after a short delay. This allows the menu to refresh before
+    // it's shown, and avoids an issue where keyboard focus is not on the first
+    // item of the history menu in Firefox when opening it with the keyboard,
+    // because extra items to appear at the top of the menu
+
+    OnOpen();
+
+    mOpenDelayTimer = do_CreateInstance(NS_TIMER_CONTRACTID);
+    if (!mOpenDelayTimer) {
+        return;
+    }
+
+    if (NS_FAILED(mOpenDelayTimer->InitWithNamedFuncCallback(DoOpenCallback,
+                                                             this,
+                                                             100,
+                                                             nsITimer::TYPE_ONE_SHOT,
+                                                             "nsMenu::DoOpenCallback"))) {
+        mOpenDelayTimer = nullptr;
+    }
+}
+
+void
+nsMenu::OnClose()
+{
+    if (mPopupState == ePopupState_Closed) {
+        return;
+    }
+
+    MOZ_ASSERT(nsContentUtils::IsSafeToRunScript());
+
+    // We do this to avoid mutating our view of the menu until
+    // after we have finished
+    nsNativeMenuDocListener::BlockUpdatesScope updatesBlocker;
+
+    SetPopupState(ePopupState_Hiding);
+    DispatchMouseEvent(mPopupContent, eXULPopupHiding);
+
+    // Sigh, make sure all of our descendants are closed, as we don't
+    // always get closed events for submenus when scrubbing quickly through
+    // the menu
+    size_t count = ChildCount();
+    for (size_t i = 0; i < count; ++i) {
+        if (ChildAt(i)->Type() == nsMenuObject::eType_Menu) {
+            static_cast<nsMenu *>(ChildAt(i))->OnClose();
+        }
+    }
+
+    SetPopupState(ePopupState_Closed);
+    DispatchMouseEvent(mPopupContent, eXULPopupHidden);
+
+    ContentNode()->UnsetAttr(kNameSpaceID_None, nsGkAtoms::open, true);
+}
diff --git a/widget/gtk/nsMenu.h b/widget/gtk/nsMenu.h
new file mode 100644
index 000000000000..c840afa957f7
--- /dev/null
+++ b/widget/gtk/nsMenu.h
@@ -0,0 +1,124 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* vim:expandtab:shiftwidth=4:tabstop=4:
+ */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef __nsMenu_h__
+#define __nsMenu_h__
+
+#include "mozilla/Attributes.h"
+#include "mozilla/UniquePtr.h"
+#include "nsCOMPtr.h"
+
+#include "nsDbusmenu.h"
+#include "nsMenuContainer.h"
+#include "nsMenuObject.h"
+
+#include <glib.h>
+
+class nsIAtom;
+class nsIContent;
+class nsITimer;
+class nsStyleContext;
+
+#define NSMENU_NUMBER_OF_POPUPSTATE_BITS 2U
+#define NSMENU_NUMBER_OF_FLAGS           4U
+
+// This class represents a menu
+class nsMenu final : public nsMenuContainer
+{
+public:
+    nsMenu(nsMenuContainer *aParent, nsIContent *aContent);
+    ~nsMenu();
+
+    nsMenuObject::EType Type() const override;
+
+    bool IsBeingDisplayed() const override;
+    bool NeedsRebuild() const override;
+
+    // Tell the desktop shell to display this menu
+    void OpenMenu();
+
+    // Normally called via the shell, but it's public so that child
+    // menuitems can do the shells work. Sigh....
+    void OnClose();
+
+private:
+    friend class nsMenuContentInsertedEvent;
+    friend class nsMenuContentRemovedEvent;
+
+    enum EPopupState {
+        ePopupState_Closed,
+        ePopupState_Showing,
+        ePopupState_Open,
+        ePopupState_Hiding
+    };
+
+    void SetPopupState(EPopupState aState);
+
+    static void DoOpenCallback(nsITimer *aTimer, void *aClosure);
+    static void menu_event_cb(DbusmenuMenuitem *menu,
+                              const gchar *name,
+                              GVariant *value,
+                              guint timestamp,
+                              gpointer user_data);
+
+    // We add a placeholder item to empty menus so that Unity actually treats
+    // us as a proper menu, rather than a menuitem without a submenu
+    void MaybeAddPlaceholderItem();
+
+    // Removes a placeholder item if it exists and asserts that this succeeds
+    void EnsureNoPlaceholderItem();
+
+    void OnOpen();
+    void Build();
+    void InitializePopup();
+    void RemoveChildAt(size_t aIndex);
+    void RemoveChild(nsIContent *aChild);
+    void InsertChildAfter(mozilla::UniquePtr<nsMenuObject> aChild,
+                          nsIContent *aPrevSibling);
+    void AppendChild(mozilla::UniquePtr<nsMenuObject> aChild);
+    bool IsInBatchedUpdate() const;
+    void StructureMutated();
+    bool CanOpen() const;
+
+    void HandleContentInserted(nsIContent *aContainer,
+                               nsIContent *aChild,
+                               nsIContent *aPrevSibling);
+    void HandleContentRemoved(nsIContent *aContainer,
+                              nsIContent *aChild);
+
+    void InitializeNativeData() override;
+    void Update(nsStyleContext *aStyleContext) override;
+    nsMenuObject::PropertyFlags SupportedProperties() const override;
+
+    void OnAttributeChanged(nsIContent *aContent, nsIAtom *aAttribute) override;
+    void OnContentInserted(nsIContent *aContainer, nsIContent *aChild,
+                           nsIContent *aPrevSibling) override;
+    void OnContentRemoved(nsIContent *aContainer, nsIContent *aChild) override;
+    void OnBeginUpdates(nsIContent *aContent) override;
+    void OnEndUpdates() override;
+
+    bool mNeedsRebuild;
+    bool mNeedsUpdate;
+
+    DbusmenuMenuitem *mPlaceholderItem;
+
+    EPopupState mPopupState;
+
+    enum EBatchedUpdateState {
+        eBatchedUpdateState_Inactive,
+        eBatchedUpdateState_Active,
+        eBatchedUpdateState_DidMutate
+    };
+
+    EBatchedUpdateState mBatchedUpdateState;
+
+    nsCOMPtr<nsIContent> mPopupContent;
+
+    nsCOMPtr<nsITimer> mOpenDelayTimer;
+};
+
+#endif /* __nsMenu_h__ */
diff --git a/widget/gtk/nsMenuBar.cpp b/widget/gtk/nsMenuBar.cpp
new file mode 100644
index 000000000000..755d87174cc7
--- /dev/null
+++ b/widget/gtk/nsMenuBar.cpp
@@ -0,0 +1,576 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* vim:expandtab:shiftwidth=4:tabstop=4:
+ */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/Assertions.h"
+#include "mozilla/DebugOnly.h"
+#include "mozilla/dom/Element.h"
+#include "mozilla/Move.h"
+#include "mozilla/Preferences.h"
+#include "nsAutoPtr.h"
+#include "nsContentUtils.h"
+#include "nsIDocument.h"
+#include "nsIDOMEvent.h"
+#include "nsIDOMEventListener.h"
+#include "nsIDOMEventTarget.h"
+#include "nsIDOMKeyEvent.h"
+#include "nsIRunnable.h"
+#include "nsIWidget.h"
+#include "nsTArray.h"
+#include "nsUnicharUtils.h"
+
+#include "nsMenu.h"
+#include "nsNativeMenuAtoms.h"
+#include "nsNativeMenuService.h"
+
+#include <gdk/gdk.h>
+#include <gdk/gdkx.h>
+#include <glib.h>
+#include <glib-object.h>
+
+#include "nsMenuBar.h"
+
+using namespace mozilla;
+
+static bool
+ShouldHandleKeyEvent(nsIDOMEvent *aEvent)
+{
+    bool handled, trusted = false;
+    aEvent->GetPreventDefault(&handled);
+    aEvent->GetIsTrusted(&trusted);
+
+    if (handled || !trusted) {
+        return false;
+    }
+
+    return true;
+}
+
+class nsMenuBarContentInsertedEvent : public Runnable
+{
+public:
+    nsMenuBarContentInsertedEvent(nsMenuBar *aMenuBar,
+                                  nsIContent *aChild,
+                                  nsIContent *aPrevSibling) :
+        Runnable("nsMenuBarContentInsertedEvent"),
+        mWeakMenuBar(aMenuBar),
+        mChild(aChild),
+        mPrevSibling(aPrevSibling) { }
+
+    NS_IMETHODIMP Run()
+    {
+        if (!mWeakMenuBar) {
+            return NS_OK;
+        }
+
+        static_cast<nsMenuBar *>(mWeakMenuBar.get())->HandleContentInserted(mChild,
+                                                                            mPrevSibling);
+        return NS_OK;
+    }
+
+private:
+    nsWeakMenuObject mWeakMenuBar;
+
+    nsCOMPtr<nsIContent> mChild;
+    nsCOMPtr<nsIContent> mPrevSibling;
+};
+
+class nsMenuBarContentRemovedEvent : public Runnable
+{
+public:
+    nsMenuBarContentRemovedEvent(nsMenuBar *aMenuBar,
+                                 nsIContent *aChild) :
+        Runnable("nsMenuBarContentRemovedEvent"),
+        mWeakMenuBar(aMenuBar),
+        mChild(aChild) { }
+
+    NS_IMETHODIMP Run()
+    {
+        if (!mWeakMenuBar) {
+            return NS_OK;
+        }
+
+        static_cast<nsMenuBar *>(mWeakMenuBar.get())->HandleContentRemoved(mChild);
+        return NS_OK;
+    }
+
+private:
+    nsWeakMenuObject mWeakMenuBar;
+
+    nsCOMPtr<nsIContent> mChild;
+};
+
+class nsMenuBar::DocEventListener final : public nsIDOMEventListener
+{
+public:
+    NS_DECL_ISUPPORTS
+    NS_DECL_NSIDOMEVENTLISTENER
+
+    DocEventListener(nsMenuBar *aOwner) : mOwner(aOwner) { };
+
+private:
+    ~DocEventListener() { };
+
+    nsMenuBar *mOwner;
+};
+
+NS_IMPL_ISUPPORTS(nsMenuBar::DocEventListener, nsIDOMEventListener)
+
+NS_IMETHODIMP
+nsMenuBar::DocEventListener::HandleEvent(nsIDOMEvent *aEvent)
+{
+    nsAutoString type;
+    nsresult rv = aEvent->GetType(type);
+    if (NS_FAILED(rv)) {
+        NS_WARNING("Failed to determine event type");
+        return rv;
+    }
+
+    if (type.Equals(NS_LITERAL_STRING("focus"))) {
+        mOwner->Focus();
+    } else if (type.Equals(NS_LITERAL_STRING("blur"))) {
+        mOwner->Blur();
+    } else if (type.Equals(NS_LITERAL_STRING("keypress"))) {
+        rv = mOwner->Keypress(aEvent);
+    } else if (type.Equals(NS_LITERAL_STRING("keydown"))) {
+        rv = mOwner->KeyDown(aEvent);
+    } else if (type.Equals(NS_LITERAL_STRING("keyup"))) {
+        rv = mOwner->KeyUp(aEvent);
+    }
+
+    return rv;
+}
+
+nsMenuBar::nsMenuBar(nsIContent *aMenuBarNode) :
+    nsMenuContainer(new nsNativeMenuDocListener(aMenuBarNode), aMenuBarNode),
+    mTopLevel(nullptr),
+    mServer(nullptr),
+    mIsActive(false)
+{
+    MOZ_COUNT_CTOR(nsMenuBar);
+}
+
+nsresult
+nsMenuBar::Init(nsIWidget *aParent)
+{
+    MOZ_ASSERT(aParent);
+
+    GdkWindow *gdkWin = static_cast<GdkWindow *>(
+        aParent->GetNativeData(NS_NATIVE_WINDOW));
+    if (!gdkWin) {
+        return NS_ERROR_FAILURE;
+    }
+
+    gpointer user_data = nullptr;
+    gdk_window_get_user_data(gdkWin, &user_data);
+    if (!user_data || !GTK_IS_CONTAINER(user_data)) {
+        return NS_ERROR_FAILURE;
+    }
+
+    mTopLevel = gtk_widget_get_toplevel(GTK_WIDGET(user_data));
+    if (!mTopLevel) {
+        return NS_ERROR_FAILURE;
+    }
+
+    g_object_ref(mTopLevel);
+
+    nsAutoCString path;
+    path.Append(NS_LITERAL_CSTRING("/com/canonical/menu/"));
+    char xid[10];
+    sprintf(xid, "%X", static_cast<uint32_t>(
+        GDK_WINDOW_XID(gtk_widget_get_window(mTopLevel))));
+    path.Append(xid);
+
+    mServer = dbusmenu_server_new(path.get());
+    if (!mServer) {
+        return NS_ERROR_FAILURE;
+    }
+
+    CreateNativeData();
+    if (!GetNativeData()) {
+        return NS_ERROR_FAILURE;
+    }
+
+    dbusmenu_server_set_root(mServer, GetNativeData());
+
+    mEventListener = new DocEventListener(this);
+
+    mDocument = do_QueryInterface(ContentNode()->OwnerDoc());
+
+    mAccessKey = Preferences::GetInt("ui.key.menuAccessKey");
+    if (mAccessKey == nsIDOMKeyEvent::DOM_VK_SHIFT) {
+        mAccessKeyMask = eModifierShift;
+    } else if (mAccessKey == nsIDOMKeyEvent::DOM_VK_CONTROL) {
+        mAccessKeyMask = eModifierCtrl;
+    } else if (mAccessKey == nsIDOMKeyEvent::DOM_VK_ALT) {
+        mAccessKeyMask = eModifierAlt;
+    } else if (mAccessKey == nsIDOMKeyEvent::DOM_VK_META) {
+        mAccessKeyMask = eModifierMeta;
+    } else {
+        mAccessKeyMask = eModifierAlt;
+    }
+
+    return NS_OK;
+}
+
+void
+nsMenuBar::Build()
+{
+    uint32_t count = ContentNode()->GetChildCount();
+    for (uint32_t i = 0; i < count; ++i) {
+        nsIContent *childContent = ContentNode()->GetChildAt(i);
+
+        UniquePtr<nsMenuObject> child = CreateChild(childContent);
+
+        if (!child) {
+            continue;
+        }
+
+        AppendChild(Move(child));
+    }
+}
+
+void
+nsMenuBar::DisconnectDocumentEventListeners()
+{
+    mDocument->RemoveEventListener(NS_LITERAL_STRING("focus"),
+                                   mEventListener,
+                                   true);
+    mDocument->RemoveEventListener(NS_LITERAL_STRING("blur"),
+                                   mEventListener,
+                                   true);
+    mDocument->RemoveEventListener(NS_LITERAL_STRING("keypress"),
+                                   mEventListener,
+                                   false);
+    mDocument->RemoveEventListener(NS_LITERAL_STRING("keydown"),
+                                   mEventListener,
+                                   false);
+    mDocument->RemoveEventListener(NS_LITERAL_STRING("keyup"),
+                                   mEventListener,
+                                   false);
+}
+
+void
+nsMenuBar::SetShellShowingMenuBar(bool aShowing)
+{
+    ContentNode()->OwnerDoc()->GetRootElement()->SetAttr(
+        kNameSpaceID_None, nsNativeMenuAtoms::shellshowingmenubar,
+        aShowing ? NS_LITERAL_STRING("true") : NS_LITERAL_STRING("false"),
+        true);
+}
+
+void
+nsMenuBar::Focus()
+{
+    ContentNode()->SetAttr(kNameSpaceID_None, nsNativeMenuAtoms::openedwithkey,
+                           NS_LITERAL_STRING("false"), true);
+}
+
+void
+nsMenuBar::Blur()
+{
+    // We do this here in case we lose focus before getting the
+    // keyup event, which leaves the menubar state looking like
+    // the alt key is stuck down
+    dbusmenu_server_set_status(mServer, DBUSMENU_STATUS_NORMAL);
+}
+
+nsMenuBar::ModifierFlags
+nsMenuBar::GetModifiersFromEvent(nsIDOMKeyEvent *aEvent)
+{
+    ModifierFlags modifiers = static_cast<ModifierFlags>(0);
+    bool modifier;
+
+    aEvent->GetAltKey(&modifier);
+    if (modifier) {
+        modifiers = static_cast<ModifierFlags>(modifiers | eModifierAlt);
+    }
+
+    aEvent->GetShiftKey(&modifier);
+    if (modifier) {
+        modifiers = static_cast<ModifierFlags>(modifiers | eModifierShift);
+    }
+
+    aEvent->GetCtrlKey(&modifier);
+    if (modifier) {
+        modifiers = static_cast<ModifierFlags>(modifiers | eModifierCtrl);
+    }
+
+    aEvent->GetMetaKey(&modifier);
+    if (modifier) {
+        modifiers = static_cast<ModifierFlags>(modifiers | eModifierMeta);
+    }
+
+    return modifiers;
+}
+
+nsresult
+nsMenuBar::Keypress(nsIDOMEvent *aEvent)
+{
+    if (!ShouldHandleKeyEvent(aEvent)) {
+        return NS_OK;
+    }
+
+    nsCOMPtr<nsIDOMKeyEvent> keyEvent = do_QueryInterface(aEvent);
+    if (!keyEvent) {
+        return NS_OK;
+    }
+
+    ModifierFlags modifiers = GetModifiersFromEvent(keyEvent);
+    if (((modifiers & mAccessKeyMask) == 0) ||
+        ((modifiers & ~mAccessKeyMask) != 0)) {
+        return NS_OK;
+    }
+
+    uint32_t charCode;
+    keyEvent->GetCharCode(&charCode);
+    if (charCode == 0) {
+        return NS_OK;
+    }
+
+    char16_t ch = char16_t(charCode);
+    char16_t chl = ToLowerCase(ch);
+    char16_t chu = ToUpperCase(ch);
+
+    nsMenuObject *found = nullptr;
+    uint32_t count = ChildCount();
+    for (uint32_t i = 0; i < count; ++i) {
+        nsAutoString accesskey;
+        ChildAt(i)->ContentNode()->GetAttr(kNameSpaceID_None,
+                                           nsGkAtoms::accesskey,
+                                           accesskey);
+        const nsAutoString::char_type *key = accesskey.BeginReading();
+        if (*key == chu || *key == chl) {
+            found = ChildAt(i);
+            break;
+        }
+    }
+
+    if (!found || found->Type() != nsMenuObject::eType_Menu) {
+        return NS_OK;
+    }
+
+    ContentNode()->SetAttr(kNameSpaceID_None, nsNativeMenuAtoms::openedwithkey,
+                           NS_LITERAL_STRING("true"), true);
+    static_cast<nsMenu *>(found)->OpenMenu();
+
+    aEvent->StopPropagation();
+    aEvent->PreventDefault();
+
+    return NS_OK;
+}
+
+nsresult
+nsMenuBar::KeyDown(nsIDOMEvent *aEvent)
+{
+    if (!ShouldHandleKeyEvent(aEvent)) {
+        return NS_OK;
+    }
+
+    nsCOMPtr<nsIDOMKeyEvent> keyEvent = do_QueryInterface(aEvent);
+    if (!keyEvent) {
+        return NS_OK;
+    }
+
+    uint32_t keyCode;
+    keyEvent->GetKeyCode(&keyCode);
+    ModifierFlags modifiers = GetModifiersFromEvent(keyEvent);
+    if ((keyCode != mAccessKey) || ((modifiers & ~mAccessKeyMask) != 0)) {
+        return NS_OK;
+    }
+
+    dbusmenu_server_set_status(mServer, DBUSMENU_STATUS_NOTICE);
+
+    return NS_OK;
+}
+
+nsresult
+nsMenuBar::KeyUp(nsIDOMEvent *aEvent)
+{
+    if (!ShouldHandleKeyEvent(aEvent)) {
+        return NS_OK;
+    }
+
+    nsCOMPtr<nsIDOMKeyEvent> keyEvent = do_QueryInterface(aEvent);
+    if (!keyEvent) {
+        return NS_OK;
+    }
+
+    uint32_t keyCode;
+    keyEvent->GetKeyCode(&keyCode);
+    if (keyCode == mAccessKey) {
+        dbusmenu_server_set_status(mServer, DBUSMENU_STATUS_NORMAL);
+    }
+
+    return NS_OK;
+}
+
+void
+nsMenuBar::HandleContentInserted(nsIContent *aChild, nsIContent *aPrevSibling)
+{
+    UniquePtr<nsMenuObject> child = CreateChild(aChild);
+
+    if (!child) {
+        return;
+    }
+
+    InsertChildAfter(Move(child), aPrevSibling);
+}
+
+void
+nsMenuBar::HandleContentRemoved(nsIContent *aChild)
+{
+    RemoveChild(aChild);
+}
+
+void
+nsMenuBar::OnContentInserted(nsIContent *aContainer, nsIContent *aChild,
+                             nsIContent *aPrevSibling)
+{
+    MOZ_ASSERT(aContainer == ContentNode(),
+               "Received an event that wasn't meant for us");
+
+    nsContentUtils::AddScriptRunner(
+        new nsMenuBarContentInsertedEvent(this, aChild, aPrevSibling));
+}
+
+void
+nsMenuBar::OnContentRemoved(nsIContent *aContainer, nsIContent *aChild)
+{
+    MOZ_ASSERT(aContainer == ContentNode(),
+               "Received an event that wasn't meant for us");
+
+    nsContentUtils::AddScriptRunner(
+        new nsMenuBarContentRemovedEvent(this, aChild));
+}
+
+nsMenuBar::~nsMenuBar()
+{
+    nsNativeMenuService *service = nsNativeMenuService::GetSingleton();
+    if (service) {
+        service->NotifyNativeMenuBarDestroyed(this);
+    }
+
+    if (ContentNode()) {
+        SetShellShowingMenuBar(false);
+    }
+
+    // We want to destroy all children before dropping our reference
+    // to the doc listener
+    while (ChildCount() > 0) {
+        RemoveChildAt(0);
+    }
+
+    if (mTopLevel) {
+        g_object_unref(mTopLevel);
+    }
+
+    if (DocListener()) {
+        DocListener()->Stop();
+    }
+
+    if (mDocument) {
+        DisconnectDocumentEventListeners();
+    }
+
+    if (mServer) {
+        g_object_unref(mServer);
+    }
+
+    MOZ_COUNT_DTOR(nsMenuBar);
+}
+
+/* static */ UniquePtr<nsMenuBar>
+nsMenuBar::Create(nsIWidget *aParent, nsIContent *aMenuBarNode)
+{
+    UniquePtr<nsMenuBar> menubar(new nsMenuBar(aMenuBarNode));
+    if (NS_FAILED(menubar->Init(aParent))) {
+        return nullptr;
+    }
+
+    return Move(menubar);
+}
+
+nsMenuObject::EType
+nsMenuBar::Type() const
+{
+    return eType_MenuBar;
+}
+
+bool
+nsMenuBar::IsBeingDisplayed() const
+{
+    return true;
+}
+
+uint32_t
+nsMenuBar::WindowId() const
+{
+    return static_cast<uint32_t>(GDK_WINDOW_XID(gtk_widget_get_window(mTopLevel)));
+}
+
+nsCString
+nsMenuBar::ObjectPath() const
+{
+    gchar *tmp;
+    g_object_get(mServer, DBUSMENU_SERVER_PROP_DBUS_OBJECT, &tmp, NULL);
+
+    nsCString result;
+    result.Adopt(tmp);
+
+    return result;
+}
+
+void
+nsMenuBar::Activate()
+{
+    if (mIsActive) {
+        return;
+    }
+
+    mIsActive = true;
+
+    mDocument->AddEventListener(NS_LITERAL_STRING("focus"),
+                                mEventListener,
+                                true);
+    mDocument->AddEventListener(NS_LITERAL_STRING("blur"),
+                                mEventListener,
+                                true);
+    mDocument->AddEventListener(NS_LITERAL_STRING("keypress"),
+                                mEventListener,
+                                false);
+    mDocument->AddEventListener(NS_LITERAL_STRING("keydown"),
+                                mEventListener,
+                                false);
+    mDocument->AddEventListener(NS_LITERAL_STRING("keyup"),
+                                mEventListener,
+                                false);
+
+    // Clear this. Not sure if we really need to though
+    ContentNode()->SetAttr(kNameSpaceID_None, nsNativeMenuAtoms::openedwithkey,
+                           NS_LITERAL_STRING("false"), true);
+
+    DocListener()->Start();
+    Build();
+    SetShellShowingMenuBar(true);
+}
+
+void
+nsMenuBar::Deactivate()
+{
+    if (!mIsActive) {
+        return;
+    }
+
+    mIsActive = false;
+
+    SetShellShowingMenuBar(false);
+    while (ChildCount() > 0) {
+        RemoveChildAt(0);
+    }
+    DocListener()->Stop();
+    DisconnectDocumentEventListeners();
+}
diff --git a/widget/gtk/nsMenuBar.h b/widget/gtk/nsMenuBar.h
new file mode 100644
index 000000000000..706a3d3b4b20
--- /dev/null
+++ b/widget/gtk/nsMenuBar.h
@@ -0,0 +1,107 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* vim:expandtab:shiftwidth=4:tabstop=4:
+ */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef __nsMenuBar_h__
+#define __nsMenuBar_h__
+
+#include "mozilla/Attributes.h"
+#include "mozilla/UniquePtr.h"
+#include "nsCOMPtr.h"
+#include "nsString.h"
+
+#include "nsDbusmenu.h"
+#include "nsMenuContainer.h"
+#include "nsMenuObject.h"
+
+#include <gtk/gtk.h>
+
+class nsIAtom;
+class nsIContent;
+class nsIDOMEvent;
+class nsIDOMKeyEvent;
+class nsIWidget;
+class nsMenuBarDocEventListener;
+
+/*
+ * The menubar class. There is one of these per window (and the window
+ * owns its menubar). Each menubar has an object path, and the service is
+ * responsible for telling the desktop shell which object path corresponds
+ * to a particular window. A menubar and its hierarchy also own a
+ * nsNativeMenuDocListener.
+ */
+class nsMenuBar final : public nsMenuContainer
+{
+public:
+    ~nsMenuBar() override;
+
+    static mozilla::UniquePtr<nsMenuBar> Create(nsIWidget *aParent,
+                                                nsIContent *aMenuBarNode);
+
+    nsMenuObject::EType Type() const override;
+
+    bool IsBeingDisplayed() const override;
+
+    // Get the native window ID for this menubar
+    uint32_t WindowId() const;
+
+    // Get the object path for this menubar
+    nsCString ObjectPath() const;
+
+    // Get the top-level GtkWindow handle
+    GtkWidget* TopLevelWindow() { return mTopLevel; }
+
+    // Called from the menuservice when the menubar is about to be registered.
+    // Causes the native menubar to be created, and the XUL menubar to be hidden
+    void Activate();
+
+    // Called from the menuservice when the menubar is no longer registered
+    // with the desktop shell. Will cause the XUL menubar to be shown again
+    void Deactivate();
+
+private:
+    class DocEventListener;
+    friend class nsMenuBarContentInsertedEvent;
+    friend class nsMenuBarContentRemovedEvent;
+
+    enum ModifierFlags {
+        eModifierShift = (1 << 0),
+        eModifierCtrl = (1 << 1),
+        eModifierAlt = (1 << 2),
+        eModifierMeta = (1 << 3)
+    };
+
+    nsMenuBar(nsIContent *aMenuBarNode);
+    nsresult Init(nsIWidget *aParent);
+    void Build();
+    void DisconnectDocumentEventListeners();
+    void SetShellShowingMenuBar(bool aShowing);
+    void Focus();
+    void Blur();
+    ModifierFlags GetModifiersFromEvent(nsIDOMKeyEvent *aEvent);
+    nsresult Keypress(nsIDOMEvent *aEvent);
+    nsresult KeyDown(nsIDOMEvent *aEvent);
+    nsresult KeyUp(nsIDOMEvent *aEvent);
+
+    void HandleContentInserted(nsIContent *aChild,
+                               nsIContent *aPrevSibling);
+    void HandleContentRemoved(nsIContent *aChild);
+
+    void OnContentInserted(nsIContent *aContainer, nsIContent *aChild,
+                           nsIContent *aPrevSibling) override;
+    void OnContentRemoved(nsIContent *aContainer, nsIContent *aChild) override;
+
+    GtkWidget *mTopLevel;
+    DbusmenuServer *mServer;
+    nsCOMPtr<nsIDOMEventTarget> mDocument;
+    RefPtr<DocEventListener> mEventListener;
+
+    uint32_t mAccessKey;
+    ModifierFlags mAccessKeyMask;
+    bool mIsActive;
+};
+
+#endif /* __nsMenuBar_h__ */
diff --git a/widget/gtk/nsMenuContainer.cpp b/widget/gtk/nsMenuContainer.cpp
new file mode 100644
index 000000000000..f17b3e277903
--- /dev/null
+++ b/widget/gtk/nsMenuContainer.cpp
@@ -0,0 +1,172 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* vim:expandtab:shiftwidth=4:tabstop=4:
+ */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/DebugOnly.h"
+#include "mozilla/Move.h"
+#include "nsGkAtoms.h"
+#include "nsIAtom.h"
+#include "nsIContent.h"
+
+#include "nsDbusmenu.h"
+#include "nsMenu.h"
+#include "nsMenuItem.h"
+#include "nsMenuSeparator.h"
+
+#include "nsMenuContainer.h"
+
+using namespace mozilla;
+
+const nsMenuContainer::ChildTArray::index_type nsMenuContainer::NoIndex = nsMenuContainer::ChildTArray::NoIndex;
+
+typedef UniquePtr<nsMenuObject> (*nsMenuObjectConstructor)(nsMenuContainer*,
+                                                           nsIContent*);
+
+template<class T>
+static UniquePtr<nsMenuObject> CreateMenuObject(nsMenuContainer *aContainer,
+                                                nsIContent *aContent)
+{
+    return UniquePtr<T>(new T(aContainer, aContent));
+}
+
+static nsMenuObjectConstructor
+GetMenuObjectConstructor(nsIContent *aContent)
+{
+    if (aContent->IsXULElement(nsGkAtoms::menuitem)) {
+        return CreateMenuObject<nsMenuItem>;
+    } else if (aContent->IsXULElement(nsGkAtoms::menu)) {
+        return CreateMenuObject<nsMenu>;
+    } else if (aContent->IsXULElement(nsGkAtoms::menuseparator)) {
+        return CreateMenuObject<nsMenuSeparator>;
+    }
+
+    return nullptr;
+}
+
+static bool
+ContentIsSupported(nsIContent *aContent)
+{
+    return GetMenuObjectConstructor(aContent) ? true : false;
+}
+
+nsMenuContainer::nsMenuContainer(nsMenuContainer *aParent,
+                                 nsIContent *aContent) :
+    nsMenuObject(aParent, aContent)
+{
+}
+
+nsMenuContainer::nsMenuContainer(nsNativeMenuDocListener *aListener,
+                                 nsIContent *aContent) :
+    nsMenuObject(aListener, aContent)
+{
+}
+
+UniquePtr<nsMenuObject>
+nsMenuContainer::CreateChild(nsIContent *aContent)
+{
+    nsMenuObjectConstructor ctor = GetMenuObjectConstructor(aContent);
+    if (!ctor) {
+        // There are plenty of node types we might stumble across that
+        // aren't supported
+        return nullptr;
+    }
+
+    UniquePtr<nsMenuObject> res = ctor(this, aContent);
+    return Move(res);
+}
+
+size_t
+nsMenuContainer::IndexOf(nsIContent *aChild) const
+{
+    if (!aChild) {
+        return NoIndex;
+    }
+
+    size_t count = ChildCount();
+    for (size_t i = 0; i < count; ++i) {
+        if (ChildAt(i)->ContentNode() == aChild) {
+            return i;
+        }
+    }
+
+    return NoIndex;
+}
+
+void
+nsMenuContainer::RemoveChildAt(size_t aIndex, bool aUpdateNative)
+{
+    MOZ_ASSERT(aIndex < ChildCount());
+
+    if (aUpdateNative) {
+        MOZ_ALWAYS_TRUE(
+            dbusmenu_menuitem_child_delete(GetNativeData(),
+                                           ChildAt(aIndex)->GetNativeData()));
+    }
+
+    mChildren.RemoveElementAt(aIndex);
+}
+
+void
+nsMenuContainer::RemoveChild(nsIContent *aChild, bool aUpdateNative)
+{
+    size_t index = IndexOf(aChild);
+    if (index == NoIndex) {
+        return;
+    }
+
+    RemoveChildAt(index, aUpdateNative);
+}
+
+void
+nsMenuContainer::InsertChildAfter(UniquePtr<nsMenuObject> aChild,
+                                  nsIContent *aPrevSibling,
+                                  bool aUpdateNative)
+{
+    size_t index = IndexOf(aPrevSibling);
+    MOZ_ASSERT(!aPrevSibling || index != NoIndex);
+
+    ++index;
+
+    if (aUpdateNative) {
+        aChild->CreateNativeData();
+        MOZ_ALWAYS_TRUE(
+            dbusmenu_menuitem_child_add_position(GetNativeData(),
+                                                 aChild->GetNativeData(),
+                                                 index));
+    }
+
+    MOZ_ALWAYS_TRUE(mChildren.InsertElementAt(index, Move(aChild)));
+}
+
+void
+nsMenuContainer::AppendChild(UniquePtr<nsMenuObject> aChild,
+                             bool aUpdateNative)
+{
+    if (aUpdateNative) {
+        aChild->CreateNativeData();
+        MOZ_ALWAYS_TRUE(
+            dbusmenu_menuitem_child_append(GetNativeData(),
+                                           aChild->GetNativeData()));
+    }
+
+    MOZ_ALWAYS_TRUE(mChildren.AppendElement(Move(aChild)));
+}
+
+bool
+nsMenuContainer::NeedsRebuild() const
+{
+    return false;
+}
+
+/* static */ nsIContent*
+nsMenuContainer::GetPreviousSupportedSibling(nsIContent *aContent)
+{
+    do {
+        aContent = aContent->GetPreviousSibling();
+    } while (aContent && !ContentIsSupported(aContent));
+
+    return aContent;
+}
diff --git a/widget/gtk/nsMenuContainer.h b/widget/gtk/nsMenuContainer.h
new file mode 100644
index 000000000000..b7e8fa8db46f
--- /dev/null
+++ b/widget/gtk/nsMenuContainer.h
@@ -0,0 +1,70 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* vim:expandtab:shiftwidth=4:tabstop=4:
+ */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef __nsMenuContainer_h__
+#define __nsMenuContainer_h__
+
+#include "mozilla/UniquePtr.h"
+#include "nsTArray.h"
+
+#include "nsMenuObject.h"
+
+class nsIContent;
+class nsNativeMenuDocListener;
+
+// Base class for containers (menus and menubars)
+class nsMenuContainer : public nsMenuObject
+{
+public:
+    typedef nsTArray<mozilla::UniquePtr<nsMenuObject> > ChildTArray;
+
+    // Determine if this container is being displayed on screen. Must be
+    // implemented by subclasses. Must return true if the container is
+    // in the fully open state, or false otherwise
+    virtual bool IsBeingDisplayed() const = 0;
+
+    // Determine if this container will be rebuilt the next time it opens.
+    // Returns false by default but can be overridden by subclasses
+    virtual bool NeedsRebuild() const;
+
+    // Return the first previous sibling that is of a type supported by the
+    // menu system
+    static nsIContent* GetPreviousSupportedSibling(nsIContent *aContent);
+
+    static const ChildTArray::index_type NoIndex;
+
+protected:
+    nsMenuContainer(nsMenuContainer *aParent, nsIContent *aContent);
+    nsMenuContainer(nsNativeMenuDocListener *aListener, nsIContent *aContent);
+
+    // Create a new child element for the specified content node
+    mozilla::UniquePtr<nsMenuObject> CreateChild(nsIContent *aContent);
+
+    // Return the index of the child for the specified content node
+    size_t IndexOf(nsIContent *aChild) const;
+
+    size_t ChildCount() const { return mChildren.Length(); }
+    nsMenuObject* ChildAt(size_t aIndex) const { return mChildren[aIndex].get(); }
+
+    void RemoveChildAt(size_t aIndex, bool aUpdateNative = true);
+
+    // Remove the child that owns the specified content node
+    void RemoveChild(nsIContent *aChild, bool aUpdateNative = true);
+
+    // Insert a new child after the child that owns the specified content node
+    void InsertChildAfter(mozilla::UniquePtr<nsMenuObject> aChild,
+                          nsIContent *aPrevSibling,
+                          bool aUpdateNative = true);
+
+    void AppendChild(mozilla::UniquePtr<nsMenuObject> aChild,
+                     bool aUpdateNative = true);
+
+private:
+    ChildTArray mChildren;
+};
+
+#endif /* __nsMenuContainer_h__ */
diff --git a/widget/gtk/nsMenuItem.cpp b/widget/gtk/nsMenuItem.cpp
new file mode 100644
index 000000000000..42e6c033f23e
--- /dev/null
+++ b/widget/gtk/nsMenuItem.cpp
@@ -0,0 +1,737 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* vim:expandtab:shiftwidth=4:tabstop=4:
+ */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/ArrayUtils.h"
+#include "mozilla/Assertions.h"
+#include "mozilla/dom/Element.h"
+#include "mozilla/Move.h"
+#include "mozilla/Preferences.h"
+#include "mozilla/TextEvents.h"
+#include "nsAutoPtr.h"
+#include "nsContentUtils.h"
+#include "nsCRT.h"
+#include "nsGkAtoms.h"
+#include "nsGtkUtils.h"
+#include "nsIContent.h"
+#include "nsIDocument.h"
+#include "nsIDOMDocument.h"
+#include "nsIDOMEvent.h"
+#include "nsIDOMEventTarget.h"
+#include "nsIDOMKeyEvent.h"
+#include "nsIDOMXULCommandEvent.h"
+#include "nsIRunnable.h"
+#include "nsReadableUtils.h"
+#include "nsString.h"
+#include "nsStyleContext.h"
+#include "nsThreadUtils.h"
+
+#include "nsMenu.h"
+#include "nsMenuBar.h"
+#include "nsMenuContainer.h"
+#include "nsNativeMenuDocListener.h"
+
+#include <gdk/gdk.h>
+#include <gdk/gdkkeysyms.h>
+#if (MOZ_WIDGET_GTK == 3)
+#include <gdk/gdkkeysyms-compat.h>
+#endif
+#include <gdk/gdkx.h>
+#include <gtk/gtk.h>
+
+#include "nsMenuItem.h"
+
+using namespace mozilla;
+
+struct KeyCodeData {
+    const char* str;
+    size_t strlength;
+    uint32_t keycode;
+};
+
+static struct KeyCodeData gKeyCodes[] = {
+#define NS_DEFINE_VK(aDOMKeyName, aDOMKeyCode) \
+  { #aDOMKeyName, sizeof(#aDOMKeyName) - 1, aDOMKeyCode },
+#include "mozilla/VirtualKeyCodeList.h"
+#undef NS_DEFINE_VK
+  { nullptr, 0, 0 }
+};
+
+struct KeyPair {
+    uint32_t DOMKeyCode;
+    guint GDKKeyval;
+};
+
+//
+// Netscape keycodes are defined in widget/public/nsGUIEvent.h
+// GTK keycodes are defined in <gdk/gdkkeysyms.h>
+//
+static const KeyPair gKeyPairs[] = {
+    { NS_VK_CANCEL,     GDK_Cancel },
+    { NS_VK_BACK,       GDK_BackSpace },
+    { NS_VK_TAB,        GDK_Tab },
+    { NS_VK_TAB,        GDK_ISO_Left_Tab },
+    { NS_VK_CLEAR,      GDK_Clear },
+    { NS_VK_RETURN,     GDK_Return },
+    { NS_VK_SHIFT,      GDK_Shift_L },
+    { NS_VK_SHIFT,      GDK_Shift_R },
+    { NS_VK_SHIFT,      GDK_Shift_Lock },
+    { NS_VK_CONTROL,    GDK_Control_L },
+    { NS_VK_CONTROL,    GDK_Control_R },
+    { NS_VK_ALT,        GDK_Alt_L },
+    { NS_VK_ALT,        GDK_Alt_R },
+    { NS_VK_META,       GDK_Meta_L },
+    { NS_VK_META,       GDK_Meta_R },
+
+    // Assume that Super or Hyper is always mapped to physical Win key.
+    { NS_VK_WIN,        GDK_Super_L },
+    { NS_VK_WIN,        GDK_Super_R },
+    { NS_VK_WIN,        GDK_Hyper_L },
+    { NS_VK_WIN,        GDK_Hyper_R },
+
+    // GTK's AltGraph key is similar to Mac's Option (Alt) key.  However,
+    // unfortunately, browsers on Mac are using NS_VK_ALT for it even though
+    // it's really different from Alt key on Windows.
+    // On the other hand, GTK's AltGrapsh keys are really different from
+    // Alt key.  However, there is no AltGrapsh key on Windows.  On Windows,
+    // both Ctrl and Alt keys are pressed internally when AltGr key is pressed.
+    // For some languages' users, AltGraph key is important, so, web
+    // applications on such locale may want to know AltGraph key press.
+    // Therefore, we should map AltGr keycode for them only on GTK.
+    { NS_VK_ALTGR,      GDK_ISO_Level3_Shift },
+    { NS_VK_ALTGR,      GDK_ISO_Level5_Shift },
+    // We assume that Mode_switch is always used for level3 shift.
+    { NS_VK_ALTGR,      GDK_Mode_switch },
+
+    { NS_VK_PAUSE,      GDK_Pause },
+    { NS_VK_CAPS_LOCK,  GDK_Caps_Lock },
+    { NS_VK_KANA,       GDK_Kana_Lock },
+    { NS_VK_KANA,       GDK_Kana_Shift },
+    { NS_VK_HANGUL,     GDK_Hangul },
+    // { NS_VK_JUNJA,      GDK_XXX },
+    // { NS_VK_FINAL,      GDK_XXX },
+    { NS_VK_HANJA,      GDK_Hangul_Hanja },
+    { NS_VK_KANJI,      GDK_Kanji },
+    { NS_VK_ESCAPE,     GDK_Escape },
+    { NS_VK_CONVERT,    GDK_Henkan },
+    { NS_VK_NONCONVERT, GDK_Muhenkan },
+    // { NS_VK_ACCEPT,     GDK_XXX },
+    // { NS_VK_MODECHANGE, GDK_XXX },
+    { NS_VK_SPACE,      GDK_space },
+    { NS_VK_PAGE_UP,    GDK_Page_Up },
+    { NS_VK_PAGE_DOWN,  GDK_Page_Down },
+    { NS_VK_END,        GDK_End },
+    { NS_VK_HOME,       GDK_Home },
+    { NS_VK_LEFT,       GDK_Left },
+    { NS_VK_UP,         GDK_Up },
+    { NS_VK_RIGHT,      GDK_Right },
+    { NS_VK_DOWN,       GDK_Down },
+    { NS_VK_SELECT,     GDK_Select },
+    { NS_VK_PRINT,      GDK_Print },
+    { NS_VK_EXECUTE,    GDK_Execute },
+    { NS_VK_PRINTSCREEN, GDK_Print },
+    { NS_VK_INSERT,     GDK_Insert },
+    { NS_VK_DELETE,     GDK_Delete },
+    { NS_VK_HELP,       GDK_Help },
+
+    // keypad keys
+    { NS_VK_LEFT,       GDK_KP_Left },
+    { NS_VK_RIGHT,      GDK_KP_Right },
+    { NS_VK_UP,         GDK_KP_Up },
+    { NS_VK_DOWN,       GDK_KP_Down },
+    { NS_VK_PAGE_UP,    GDK_KP_Page_Up },
+    // Not sure what these are
+    //{ NS_VK_,       GDK_KP_Prior },
+    //{ NS_VK_,        GDK_KP_Next },
+    { NS_VK_CLEAR,      GDK_KP_Begin }, // Num-unlocked 5
+    { NS_VK_PAGE_DOWN,  GDK_KP_Page_Down },
+    { NS_VK_HOME,       GDK_KP_Home },
+    { NS_VK_END,        GDK_KP_End },
+    { NS_VK_INSERT,     GDK_KP_Insert },
+    { NS_VK_DELETE,     GDK_KP_Delete },
+    { NS_VK_RETURN,     GDK_KP_Enter },
+
+    { NS_VK_NUM_LOCK,   GDK_Num_Lock },
+    { NS_VK_SCROLL_LOCK,GDK_Scroll_Lock },
+
+    // Function keys
+    { NS_VK_F1,         GDK_F1 },
+    { NS_VK_F2,         GDK_F2 },
+    { NS_VK_F3,         GDK_F3 },
+    { NS_VK_F4,         GDK_F4 },
+    { NS_VK_F5,         GDK_F5 },
+    { NS_VK_F6,         GDK_F6 },
+    { NS_VK_F7,         GDK_F7 },
+    { NS_VK_F8,         GDK_F8 },
+    { NS_VK_F9,         GDK_F9 },
+    { NS_VK_F10,        GDK_F10 },
+    { NS_VK_F11,        GDK_F11 },
+    { NS_VK_F12,        GDK_F12 },
+    { NS_VK_F13,        GDK_F13 },
+    { NS_VK_F14,        GDK_F14 },
+    { NS_VK_F15,        GDK_F15 },
+    { NS_VK_F16,        GDK_F16 },
+    { NS_VK_F17,        GDK_F17 },
+    { NS_VK_F18,        GDK_F18 },
+    { NS_VK_F19,        GDK_F19 },
+    { NS_VK_F20,        GDK_F20 },
+    { NS_VK_F21,        GDK_F21 },
+    { NS_VK_F22,        GDK_F22 },
+    { NS_VK_F23,        GDK_F23 },
+    { NS_VK_F24,        GDK_F24 },
+
+    // context menu key, keysym 0xff67, typically keycode 117 on 105-key (Microsoft)
+    // x86 keyboards, located between right 'Windows' key and right Ctrl key
+    { NS_VK_CONTEXT_MENU, GDK_Menu },
+    { NS_VK_SLEEP,      GDK_Sleep },
+
+    { NS_VK_ATTN,       GDK_3270_Attn },
+    { NS_VK_CRSEL,      GDK_3270_CursorSelect },
+    { NS_VK_EXSEL,      GDK_3270_ExSelect },
+    { NS_VK_EREOF,      GDK_3270_EraseEOF },
+    { NS_VK_PLAY,       GDK_3270_Play },
+    //{ NS_VK_ZOOM,       GDK_XXX },
+    { NS_VK_PA1,        GDK_3270_PA1 },
+};
+
+static guint
+ConvertGeckoKeyNameToGDKKeyval(nsAString& aKeyName)
+{
+    NS_ConvertUTF16toUTF8 keyName(aKeyName);
+    ToUpperCase(keyName); // We want case-insensitive comparison with data
+                          // stored as uppercase.
+
+    uint32_t keyCode = 0;
+
+    uint32_t keyNameLength = keyName.Length();
+    const char* keyNameStr = keyName.get();
+    for (uint16_t i = 0; i < ArrayLength(gKeyCodes); ++i) {
+        if (keyNameLength == gKeyCodes[i].strlength &&
+            !nsCRT::strcmp(gKeyCodes[i].str, keyNameStr)) {
+            keyCode = gKeyCodes[i].keycode;
+            break;
+        }
+    }
+
+    // First, try to handle alphanumeric input, not listed in nsKeycodes:
+    // most likely, more letters will be getting typed in than things in
+    // the key list, so we will look through these first.
+
+    if (keyCode >= NS_VK_A && keyCode <= NS_VK_Z) {
+        // gdk and DOM both use the ASCII codes for these keys.
+        return keyCode;
+    }
+
+    // numbers
+    if (keyCode >= NS_VK_0 && keyCode <= NS_VK_9) {
+        // gdk and DOM both use the ASCII codes for these keys.
+        return keyCode - NS_VK_0 + GDK_0;
+    }
+
+    switch (keyCode) {
+        // keys in numpad
+        case NS_VK_MULTIPLY:  return GDK_KP_Multiply;
+        case NS_VK_ADD:       return GDK_KP_Add;
+        case NS_VK_SEPARATOR: return GDK_KP_Separator;
+        case NS_VK_SUBTRACT:  return GDK_KP_Subtract;
+        case NS_VK_DECIMAL:   return GDK_KP_Decimal;
+        case NS_VK_DIVIDE:    return GDK_KP_Divide;
+        case NS_VK_NUMPAD0:   return GDK_KP_0;
+        case NS_VK_NUMPAD1:   return GDK_KP_1;
+        case NS_VK_NUMPAD2:   return GDK_KP_2;
+        case NS_VK_NUMPAD3:   return GDK_KP_3;
+        case NS_VK_NUMPAD4:   return GDK_KP_4;
+        case NS_VK_NUMPAD5:   return GDK_KP_5;
+        case NS_VK_NUMPAD6:   return GDK_KP_6;
+        case NS_VK_NUMPAD7:   return GDK_KP_7;
+        case NS_VK_NUMPAD8:   return GDK_KP_8;
+        case NS_VK_NUMPAD9:   return GDK_KP_9;
+        // other prinable keys
+        case NS_VK_SPACE:               return GDK_space;
+        case NS_VK_COLON:               return GDK_colon;
+        case NS_VK_SEMICOLON:           return GDK_semicolon;
+        case NS_VK_LESS_THAN:           return GDK_less;
+        case NS_VK_EQUALS:              return GDK_equal;
+        case NS_VK_GREATER_THAN:        return GDK_greater;
+        case NS_VK_QUESTION_MARK:       return GDK_question;
+        case NS_VK_AT:                  return GDK_at;
+        case NS_VK_CIRCUMFLEX:          return GDK_asciicircum;
+        case NS_VK_EXCLAMATION:         return GDK_exclam;
+        case NS_VK_DOUBLE_QUOTE:        return GDK_quotedbl;
+        case NS_VK_HASH:                return GDK_numbersign;
+        case NS_VK_DOLLAR:              return GDK_dollar;
+        case NS_VK_PERCENT:             return GDK_percent;
+        case NS_VK_AMPERSAND:           return GDK_ampersand;
+        case NS_VK_UNDERSCORE:          return GDK_underscore;
+        case NS_VK_OPEN_PAREN:          return GDK_parenleft;
+        case NS_VK_CLOSE_PAREN:         return GDK_parenright;
+        case NS_VK_ASTERISK:            return GDK_asterisk;
+        case NS_VK_PLUS:                return GDK_plus;
+        case NS_VK_PIPE:                return GDK_bar;
+        case NS_VK_HYPHEN_MINUS:        return GDK_minus;
+        case NS_VK_OPEN_CURLY_BRACKET:  return GDK_braceleft;
+        case NS_VK_CLOSE_CURLY_BRACKET: return GDK_braceright;
+        case NS_VK_TILDE:               return GDK_asciitilde;
+        case NS_VK_COMMA:               return GDK_comma;
+        case NS_VK_PERIOD:              return GDK_period;
+        case NS_VK_SLASH:               return GDK_slash;
+        case NS_VK_BACK_QUOTE:          return GDK_grave;
+        case NS_VK_OPEN_BRACKET:        return GDK_bracketleft;
+        case NS_VK_BACK_SLASH:          return GDK_backslash;
+        case NS_VK_CLOSE_BRACKET:       return GDK_bracketright;
+        case NS_VK_QUOTE:               return GDK_apostrophe;
+    }
+
+    // misc other things
+    for (uint32_t i = 0; i < ArrayLength(gKeyPairs); ++i) {
+        if (gKeyPairs[i].DOMKeyCode == keyCode) {
+            return gKeyPairs[i].GDKKeyval;
+        }
+    }
+
+    return 0;
+}
+
+class nsMenuItemUncheckSiblingsRunnable final : public Runnable
+{
+public:
+    NS_IMETHODIMP Run()
+    {
+        if (mMenuItem) {
+            static_cast<nsMenuItem *>(mMenuItem.get())->UncheckSiblings();
+        }
+        return NS_OK;
+    }
+
+    nsMenuItemUncheckSiblingsRunnable(nsMenuItem *aMenuItem) :
+        Runnable("nsMenuItemUncheckSiblingsRunnable"),
+        mMenuItem(aMenuItem) { };
+
+private:
+    nsWeakMenuObject mMenuItem;
+};
+
+bool
+nsMenuItem::IsCheckboxOrRadioItem() const
+{
+    return mType == eMenuItemType_Radio ||
+           mType == eMenuItemType_CheckBox;
+}
+
+/* static */ void
+nsMenuItem::item_activated_cb(DbusmenuMenuitem *menuitem,
+                              guint timestamp,
+                              gpointer user_data)
+{
+    nsMenuItem *item = static_cast<nsMenuItem *>(user_data);
+    item->Activate(timestamp);
+}
+
+void
+nsMenuItem::Activate(uint32_t aTimestamp)
+{
+    GdkWindow *window = gtk_widget_get_window(MenuBar()->TopLevelWindow());
+    gdk_x11_window_set_user_time(
+        window, std::min(aTimestamp, gdk_x11_get_server_time(window)));
+
+    // We do this to avoid mutating our view of the menu until
+    // after we have finished
+    nsNativeMenuDocListener::BlockUpdatesScope updatesBlocker;
+
+    if (!ContentNode()->AttrValueIs(kNameSpaceID_None, nsGkAtoms::autocheck,
+                                    nsGkAtoms::_false, eCaseMatters) &&
+        (mType == eMenuItemType_CheckBox ||
+         (mType == eMenuItemType_Radio && !mIsChecked))) {
+        ContentNode()->SetAttr(kNameSpaceID_None, nsGkAtoms::checked,
+                               mIsChecked ?
+                               NS_LITERAL_STRING("false") :  NS_LITERAL_STRING("true"),
+                               true);
+    }
+
+    nsIDocument *doc = ContentNode()->OwnerDoc();
+    nsCOMPtr<nsIDOMEventTarget> target = do_QueryInterface(ContentNode());
+    nsCOMPtr<nsIDOMDocument> domDoc = do_QueryInterface(doc);
+    if (domDoc && target) {
+        nsCOMPtr<nsIDOMEvent> event;
+        domDoc->CreateEvent(NS_LITERAL_STRING("xulcommandevent"),
+                            getter_AddRefs(event));
+        nsCOMPtr<nsIDOMXULCommandEvent> command = do_QueryInterface(event);
+        if (command) {
+            command->InitCommandEvent(NS_LITERAL_STRING("command"),
+                                      true, true, doc->GetInnerWindow(), 0,
+                                      false, false, false, false, nullptr, 0);
+
+            event->SetTrusted(true);
+            bool dummy;
+            target->DispatchEvent(event, &dummy);
+        }
+    }
+
+    // This kinda sucks, but Unity doesn't send a closed event
+    // after activating a menuitem
+    nsMenuObject *ancestor = Parent();
+    while (ancestor && ancestor->Type() == eType_Menu) {
+        static_cast<nsMenu *>(ancestor)->OnClose();
+        ancestor = ancestor->Parent();
+    }
+}
+
+void
+nsMenuItem::CopyAttrFromNodeIfExists(nsIContent *aContent, nsIAtom *aAttribute)
+{
+    nsAutoString value;
+    if (aContent->GetAttr(kNameSpaceID_None, aAttribute, value)) {
+        ContentNode()->SetAttr(kNameSpaceID_None, aAttribute, value, true);
+    }
+}
+
+void
+nsMenuItem::UpdateState()
+{
+    if (!IsCheckboxOrRadioItem()) {
+        return;
+    }
+
+    mIsChecked = ContentNode()->AttrValueIs(kNameSpaceID_None,
+                                            nsGkAtoms::checked,
+                                            nsGkAtoms::_true,
+                                            eCaseMatters);
+    dbusmenu_menuitem_property_set_int(GetNativeData(),
+                                       DBUSMENU_MENUITEM_PROP_TOGGLE_STATE,
+                                       mIsChecked ?
+                                         DBUSMENU_MENUITEM_TOGGLE_STATE_CHECKED :
+                                         DBUSMENU_MENUITEM_TOGGLE_STATE_UNCHECKED);
+}
+
+void
+nsMenuItem::UpdateTypeAndState()
+{
+    static nsIContent::AttrValuesArray attrs[] =
+        { &nsGkAtoms::checkbox, &nsGkAtoms::radio, nullptr };
+    int32_t type = ContentNode()->FindAttrValueIn(kNameSpaceID_None,
+                                                  nsGkAtoms::type,
+                                                  attrs, eCaseMatters);
+
+    if (type >= 0 && type < 2) {
+        if (type == 0) {
+            dbusmenu_menuitem_property_set(GetNativeData(),
+                                           DBUSMENU_MENUITEM_PROP_TOGGLE_TYPE,
+                                           DBUSMENU_MENUITEM_TOGGLE_CHECK);
+            mType = eMenuItemType_CheckBox;
+        } else if (type == 1) {
+            dbusmenu_menuitem_property_set(GetNativeData(),
+                                           DBUSMENU_MENUITEM_PROP_TOGGLE_TYPE,
+                                           DBUSMENU_MENUITEM_TOGGLE_RADIO);
+            mType = eMenuItemType_Radio;
+        }
+
+        UpdateState();
+    } else {
+        dbusmenu_menuitem_property_remove(GetNativeData(),
+                                          DBUSMENU_MENUITEM_PROP_TOGGLE_TYPE);
+        dbusmenu_menuitem_property_remove(GetNativeData(),
+                                          DBUSMENU_MENUITEM_PROP_TOGGLE_STATE);
+        mType = eMenuItemType_Normal;
+    }
+}
+
+void
+nsMenuItem::UpdateAccel()
+{
+    nsIDocument *doc = ContentNode()->GetUncomposedDoc();
+    if (doc) {
+        nsCOMPtr<nsIContent> oldKeyContent;
+        oldKeyContent.swap(mKeyContent);
+
+        nsAutoString key;
+        ContentNode()->GetAttr(kNameSpaceID_None, nsGkAtoms::key, key);
+        if (!key.IsEmpty()) {
+            mKeyContent = doc->GetElementById(key);
+        }
+
+        if (mKeyContent != oldKeyContent) {
+            if (oldKeyContent) {
+                DocListener()->UnregisterForContentChanges(oldKeyContent);
+            }
+            if (mKeyContent) {
+                DocListener()->RegisterForContentChanges(mKeyContent, this);
+            }
+        }
+    }
+
+    if (!mKeyContent) {
+        dbusmenu_menuitem_property_remove(GetNativeData(),
+                                          DBUSMENU_MENUITEM_PROP_SHORTCUT);
+        return;
+    }
+
+    nsAutoString modifiers;
+    mKeyContent->GetAttr(kNameSpaceID_None, nsGkAtoms::modifiers, modifiers);
+
+    uint32_t modifier = 0;
+
+    if (!modifiers.IsEmpty()) {
+        char* str = ToNewUTF8String(modifiers);
+        char *token = strtok(str, ", \t");
+        while(token) {
+            if (nsCRT::strcmp(token, "shift") == 0) {
+                modifier |= GDK_SHIFT_MASK;
+            } else if (nsCRT::strcmp(token, "alt") == 0) {
+                modifier |= GDK_MOD1_MASK;
+            } else if (nsCRT::strcmp(token, "meta") == 0) {
+                modifier |= GDK_META_MASK;
+            } else if (nsCRT::strcmp(token, "control") == 0) {
+                modifier |= GDK_CONTROL_MASK;
+            } else if (nsCRT::strcmp(token, "accel") == 0) {
+                int32_t accel = Preferences::GetInt("ui.key.accelKey");
+                if (accel == nsIDOMKeyEvent::DOM_VK_META) {
+                    modifier |= GDK_META_MASK;
+                } else if (accel == nsIDOMKeyEvent::DOM_VK_ALT) {
+                    modifier |= GDK_MOD1_MASK;
+                } else {
+                    modifier |= GDK_CONTROL_MASK;
+                }
+            }
+
+            token = strtok(nullptr, ", \t");
+        }
+
+        free(str);
+    }
+
+    nsAutoString keyStr;
+    mKeyContent->GetAttr(kNameSpaceID_None, nsGkAtoms::key, keyStr);
+
+    guint key = 0;
+    if (!keyStr.IsEmpty()) {
+        key = gdk_unicode_to_keyval(*keyStr.BeginReading());
+    }
+
+    if (key == 0) {
+        mKeyContent->GetAttr(kNameSpaceID_None, nsGkAtoms::keycode, keyStr);
+        if (!keyStr.IsEmpty()) {
+            key = ConvertGeckoKeyNameToGDKKeyval(keyStr);
+        }
+    }
+
+    if (key == 0) {
+        key = GDK_VoidSymbol;
+    }
+
+    if (key != GDK_VoidSymbol) {
+        dbusmenu_menuitem_property_set_shortcut(GetNativeData(), key,
+                                                static_cast<GdkModifierType>(modifier));
+    } else {
+        dbusmenu_menuitem_property_remove(GetNativeData(),
+                                          DBUSMENU_MENUITEM_PROP_SHORTCUT);
+    }
+}
+
+nsMenuBar*
+nsMenuItem::MenuBar()
+{
+    nsMenuObject *tmp = this;
+    while (tmp->Parent()) {
+        tmp = tmp->Parent();
+    }
+
+    MOZ_ASSERT(tmp->Type() == eType_MenuBar, "The top-level should be a menubar");
+
+    return static_cast<nsMenuBar *>(tmp);
+}
+
+void
+nsMenuItem::UncheckSiblings()
+{
+    if (!ContentNode()->AttrValueIs(kNameSpaceID_None, nsGkAtoms::type,
+                                    nsGkAtoms::radio, eCaseMatters)) {
+        // If we're not a radio button, we don't care
+        return;
+    }
+
+    nsAutoString name;
+    ContentNode()->GetAttr(kNameSpaceID_None, nsGkAtoms::name, name);
+
+    nsIContent *parent = ContentNode()->GetParent();
+    if (!parent) {
+        return;
+    }
+
+    uint32_t count = parent->GetChildCount();
+    for (uint32_t i = 0; i < count; ++i) {
+        nsIContent *sibling = parent->GetChildAt(i);
+
+        nsAutoString otherName;
+        sibling->GetAttr(kNameSpaceID_None, nsGkAtoms::name, otherName);
+
+        if (sibling != ContentNode() && otherName == name &&
+            sibling->AttrValueIs(kNameSpaceID_None, nsGkAtoms::type,
+                                 nsGkAtoms::radio, eCaseMatters)) {
+            sibling->UnsetAttr(kNameSpaceID_None, nsGkAtoms::checked, true);
+        }
+    }
+}
+
+void
+nsMenuItem::InitializeNativeData()
+{
+    g_signal_connect(G_OBJECT(GetNativeData()),
+                     DBUSMENU_MENUITEM_SIGNAL_ITEM_ACTIVATED,
+                     G_CALLBACK(item_activated_cb), this);
+    mNeedsUpdate = true;
+}
+
+void
+nsMenuItem::UpdateContentAttributes()
+{
+    nsIDocument *doc = ContentNode()->GetUncomposedDoc();
+    if (!doc) {
+        return;
+    }
+
+    nsAutoString command;
+    ContentNode()->GetAttr(kNameSpaceID_None, nsGkAtoms::command, command);
+    if (command.IsEmpty()) {
+        return;
+    }
+
+    nsCOMPtr<nsIContent> commandContent = doc->GetElementById(command);
+    if (!commandContent) {
+        return;
+    }
+
+    if (commandContent->AttrValueIs(kNameSpaceID_None, nsGkAtoms::disabled,
+                                    nsGkAtoms::_true, eCaseMatters)) {
+        ContentNode()->SetAttr(kNameSpaceID_None, nsGkAtoms::disabled,
+                               NS_LITERAL_STRING("true"), true);
+    } else {
+        ContentNode()->UnsetAttr(kNameSpaceID_None, nsGkAtoms::disabled, true);
+    }
+
+    CopyAttrFromNodeIfExists(commandContent, nsGkAtoms::checked);
+    CopyAttrFromNodeIfExists(commandContent, nsGkAtoms::accesskey);
+    CopyAttrFromNodeIfExists(commandContent, nsGkAtoms::label);
+    CopyAttrFromNodeIfExists(commandContent, nsGkAtoms::hidden);
+}
+
+void
+nsMenuItem::Update(nsStyleContext *aStyleContext)
+{
+    if (mNeedsUpdate) {
+        mNeedsUpdate = false;
+
+        UpdateTypeAndState();
+        UpdateAccel();
+        UpdateLabel();
+        UpdateSensitivity();
+    }
+
+    UpdateVisibility(aStyleContext);
+    UpdateIcon(aStyleContext);
+}
+
+bool
+nsMenuItem::IsCompatibleWithNativeData(DbusmenuMenuitem *aNativeData) const
+{
+    return nsCRT::strcmp(dbusmenu_menuitem_property_get(aNativeData,
+                                                        DBUSMENU_MENUITEM_PROP_TYPE),
+                         "separator") != 0;
+}
+
+nsMenuObject::PropertyFlags
+nsMenuItem::SupportedProperties() const
+{
+    return static_cast<nsMenuObject::PropertyFlags>(
+        nsMenuObject::ePropLabel |
+        nsMenuObject::ePropEnabled |
+        nsMenuObject::ePropVisible |
+        nsMenuObject::ePropIconData |
+        nsMenuObject::ePropShortcut |
+        nsMenuObject::ePropToggleType |
+        nsMenuObject::ePropToggleState
+    );
+}
+
+void
+nsMenuItem::OnAttributeChanged(nsIContent *aContent, nsIAtom *aAttribute)
+{
+    MOZ_ASSERT(aContent == ContentNode() || aContent == mKeyContent,
+               "Received an event that wasn't meant for us!");
+
+    if (aContent == ContentNode() && aAttribute == nsGkAtoms::checked &&
+        aContent->AttrValueIs(kNameSpaceID_None, nsGkAtoms::checked,
+                              nsGkAtoms::_true, eCaseMatters)) {
+        nsContentUtils::AddScriptRunner(
+            new nsMenuItemUncheckSiblingsRunnable(this));
+    }
+
+    if (mNeedsUpdate) {
+        return;
+    }
+
+    if (!Parent()->IsBeingDisplayed()) {
+        mNeedsUpdate = true;
+        return;
+    }
+
+    if (aContent == ContentNode()) {
+        if (aAttribute == nsGkAtoms::key) {
+            UpdateAccel();
+        } else if (aAttribute == nsGkAtoms::label ||
+                   aAttribute == nsGkAtoms::accesskey ||
+                   aAttribute == nsGkAtoms::crop) {
+            UpdateLabel();
+        } else if (aAttribute == nsGkAtoms::disabled) {
+            UpdateSensitivity();
+        } else if (aAttribute == nsGkAtoms::type) {
+            UpdateTypeAndState();
+        } else if (aAttribute == nsGkAtoms::checked) {
+            UpdateState();
+        } else if (aAttribute == nsGkAtoms::hidden ||
+                   aAttribute == nsGkAtoms::collapsed) {
+            RefPtr<nsStyleContext> sc = GetStyleContext();
+            UpdateVisibility(sc);
+        } else if (aAttribute == nsGkAtoms::image) {
+            RefPtr<nsStyleContext> sc = GetStyleContext();
+            UpdateIcon(sc);
+        }
+    } else if (aContent == mKeyContent &&
+               (aAttribute == nsGkAtoms::key ||
+                aAttribute == nsGkAtoms::keycode ||
+                aAttribute == nsGkAtoms::modifiers)) {
+        UpdateAccel();
+    }
+}
+
+nsMenuItem::nsMenuItem(nsMenuContainer *aParent, nsIContent *aContent) :
+    nsMenuObject(aParent, aContent),
+    mType(eMenuItemType_Normal),
+    mIsChecked(false),
+    mNeedsUpdate(false)
+{
+    MOZ_COUNT_CTOR(nsMenuItem);
+}
+
+nsMenuItem::~nsMenuItem()
+{
+    if (DocListener() && mKeyContent) {
+        DocListener()->UnregisterForContentChanges(mKeyContent);
+    }
+
+    if (GetNativeData()) {
+        g_signal_handlers_disconnect_by_func(GetNativeData(),
+                                             FuncToGpointer(item_activated_cb),
+                                             this);
+    }
+
+    MOZ_COUNT_DTOR(nsMenuItem);
+}
+
+nsMenuObject::EType
+nsMenuItem::Type() const
+{
+    return eType_MenuItem;
+}
diff --git a/widget/gtk/nsMenuItem.h b/widget/gtk/nsMenuItem.h
new file mode 100644
index 000000000000..fb53e53aee34
--- /dev/null
+++ b/widget/gtk/nsMenuItem.h
@@ -0,0 +1,81 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* vim:expandtab:shiftwidth=4:tabstop=4:
+ */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef __nsMenuItem_h__
+#define __nsMenuItem_h__
+
+#include "mozilla/Attributes.h"
+#include "nsCOMPtr.h"
+
+#include "nsDbusmenu.h"
+#include "nsMenuObject.h"
+
+#include <glib.h>
+
+class nsIAtom;
+class nsIContent;
+class nsStyleContext;
+class nsMenuBar;
+class nsMenuContainer;
+
+/*
+ * This class represents 3 main classes of menuitems: labels, checkboxes and
+ * radio buttons (with/without an icon)
+ */
+class nsMenuItem final : public nsMenuObject
+{
+public:
+    nsMenuItem(nsMenuContainer *aParent, nsIContent *aContent);
+    ~nsMenuItem() override;
+
+    nsMenuObject::EType Type() const override;
+
+private:
+    friend class nsMenuItemUncheckSiblingsRunnable;
+
+    enum {
+        eMenuItemFlag_ToggleState = (1 << 0)
+    };
+
+    enum EMenuItemType {
+        eMenuItemType_Normal,
+        eMenuItemType_Radio,
+        eMenuItemType_CheckBox
+    };
+
+    bool IsCheckboxOrRadioItem() const;
+
+    static void item_activated_cb(DbusmenuMenuitem *menuitem,
+                                  guint timestamp,
+                                  gpointer user_data);
+    void Activate(uint32_t aTimestamp);
+
+    void CopyAttrFromNodeIfExists(nsIContent *aContent, nsIAtom *aAtom);
+    void UpdateState();
+    void UpdateTypeAndState();
+    void UpdateAccel();
+    nsMenuBar* MenuBar();
+    void UncheckSiblings();
+
+    void InitializeNativeData() override;
+    void UpdateContentAttributes() override;
+    void Update(nsStyleContext *aStyleContext) override;
+    bool IsCompatibleWithNativeData(DbusmenuMenuitem *aNativeData) const override;
+    nsMenuObject::PropertyFlags SupportedProperties() const override;
+
+    void OnAttributeChanged(nsIContent *aContent, nsIAtom *aAttribute) override;
+
+    EMenuItemType mType;
+
+    bool mIsChecked;
+
+    bool mNeedsUpdate;
+
+    nsCOMPtr<nsIContent> mKeyContent;
+};
+
+#endif /* __nsMenuItem_h__ */
diff --git a/widget/gtk/nsMenuObject.cpp b/widget/gtk/nsMenuObject.cpp
new file mode 100644
index 000000000000..4f5aa2cb2654
--- /dev/null
+++ b/widget/gtk/nsMenuObject.cpp
@@ -0,0 +1,666 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* vim:expandtab:shiftwidth=4:tabstop=4:
+ */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "ImageOps.h"
+#include "imgIContainer.h"
+#include "imgINotificationObserver.h"
+#include "imgLoader.h"
+#include "imgRequestProxy.h"
+#include "mozilla/ArrayUtils.h"
+#include "mozilla/Assertions.h"
+#include "mozilla/dom/Element.h"
+#include "mozilla/Preferences.h"
+#include "nsAttrValue.h"
+#include "nsComputedDOMStyle.h"
+#include "nsContentUtils.h"
+#include "nsGkAtoms.h"
+#include "nsIContent.h"
+#include "nsIContentPolicy.h"
+#include "nsIDocument.h"
+#include "nsILoadGroup.h"
+#include "nsImageToPixbuf.h"
+#include "nsIPresShell.h"
+#include "nsIURI.h"
+#include "nsNetUtil.h"
+#include "nsPresContext.h"
+#include "nsRect.h"
+#include "nsServiceManagerUtils.h"
+#include "nsString.h"
+#include "nsStyleConsts.h"
+#include "nsStyleContext.h"
+#include "nsStyleStruct.h"
+#include "nsUnicharUtils.h"
+
+#include "nsMenuContainer.h"
+#include "nsNativeMenuAtoms.h"
+#include "nsNativeMenuDocListener.h"
+
+#include <gdk/gdk.h>
+#include <glib-object.h>
+#include <pango/pango.h>
+
+#include "nsMenuObject.h"
+
+// X11's None clashes with StyleDisplay::None
+#include "X11UndefineNone.h"
+
+#undef None
+
+using namespace mozilla;
+using mozilla::image::ImageOps;
+
+#define MAX_WIDTH 350000
+
+const char *gPropertyStrings[] = {
+#define DBUSMENU_PROPERTY(e, s, b) s,
+    DBUSMENU_PROPERTIES
+#undef DBUSMENU_PROPERTY
+    nullptr
+};
+
+nsWeakMenuObject* nsWeakMenuObject::sHead;
+PangoLayout* gPangoLayout = nullptr;
+
+class nsMenuObjectIconLoader final : public imgINotificationObserver
+{
+public:
+    NS_DECL_ISUPPORTS
+    NS_DECL_IMGINOTIFICATIONOBSERVER
+
+    nsMenuObjectIconLoader(nsMenuObject *aOwner) : mOwner(aOwner) { };
+
+    void LoadIcon(nsStyleContext *aStyleContext);
+    void Destroy();
+
+private:
+    ~nsMenuObjectIconLoader() { };
+
+    nsMenuObject *mOwner;
+    RefPtr<imgRequestProxy> mImageRequest;
+    nsCOMPtr<nsIURI> mURI;
+    nsIntRect mImageRect;
+};
+
+NS_IMPL_ISUPPORTS(nsMenuObjectIconLoader, imgINotificationObserver)
+
+NS_IMETHODIMP
+nsMenuObjectIconLoader::Notify(imgIRequest *aProxy,
+                               int32_t aType, const nsIntRect *aRect)
+{
+    if (!mOwner) {
+        return NS_OK;
+    }
+
+    if (aProxy != mImageRequest) {
+        return NS_ERROR_FAILURE;
+    }
+
+    if (aType == imgINotificationObserver::LOAD_COMPLETE) {
+        uint32_t status = imgIRequest::STATUS_ERROR;
+        if (NS_FAILED(mImageRequest->GetImageStatus(&status)) ||
+            (status & imgIRequest::STATUS_ERROR)) {
+            mImageRequest->Cancel(NS_BINDING_ABORTED);
+            mImageRequest = nullptr;
+            return NS_ERROR_FAILURE;
+        }
+
+        nsCOMPtr<imgIContainer> image;
+        mImageRequest->GetImage(getter_AddRefs(image));
+        MOZ_ASSERT(image);
+
+        // Ask the image to decode at its intrinsic size.
+        int32_t width = 0, height = 0;
+        image->GetWidth(&width);
+        image->GetHeight(&height);
+        image->RequestDecodeForSize(nsIntSize(width, height), imgIContainer::FLAG_NONE);
+        return NS_OK;
+    }
+
+    if (aType == imgINotificationObserver::DECODE_COMPLETE) {
+        mImageRequest->Cancel(NS_BINDING_ABORTED);
+        mImageRequest = nullptr;
+        return NS_OK;
+    }
+
+    if (aType != imgINotificationObserver::FRAME_COMPLETE) {
+        return NS_OK;
+    }
+
+    nsCOMPtr<imgIContainer> img;
+    mImageRequest->GetImage(getter_AddRefs(img));
+    if (!img) {
+        return NS_ERROR_FAILURE;
+    }
+
+    if (!mImageRect.IsEmpty()) {
+        img = ImageOps::Clip(img, mImageRect);
+    }
+
+    int32_t width, height;
+    img->GetWidth(&width);
+    img->GetHeight(&height);
+
+    if (width <= 0 || height <= 0) {
+        mOwner->ClearIcon();
+        return NS_OK;
+    }
+
+    if (width > 100 || height > 100) {
+        // The icon data needs to go across DBus. Make sure the icon
+        // data isn't too large, else our connection gets terminated and
+        // GDbus helpfully aborts the application. Thank you :)
+        NS_WARNING("Icon data too large");
+        mOwner->ClearIcon();
+        return NS_OK;
+    }
+
+    GdkPixbuf *pixbuf = nsImageToPixbuf::ImageToPixbuf(img);
+    if (pixbuf) {
+        dbusmenu_menuitem_property_set_image(mOwner->GetNativeData(),
+                                             DBUSMENU_MENUITEM_PROP_ICON_DATA,
+                                             pixbuf);
+        g_object_unref(pixbuf);
+    }
+
+    return NS_OK;
+}
+
+void
+nsMenuObjectIconLoader::LoadIcon(nsStyleContext *aStyleContext)
+{
+    nsIDocument *doc = mOwner->ContentNode()->OwnerDoc();
+
+    nsCOMPtr<nsIURI> uri;
+    nsIntRect imageRect;
+    imgRequestProxy *imageRequest = nullptr;
+
+    nsAutoString uriString;
+    if (mOwner->ContentNode()->GetAttr(kNameSpaceID_None, nsGkAtoms::image,
+                                       uriString)) {
+        NS_NewURI(getter_AddRefs(uri), uriString);
+    } else {
+        nsIPresShell *shell = doc->GetShell();
+        if (!shell) {
+            return;
+        }
+
+        nsPresContext *pc = shell->GetPresContext();
+        if (!pc || !aStyleContext) {
+            return;
+        }
+
+        const nsStyleList *list = aStyleContext->StyleList();
+        imageRequest = list->GetListStyleImage();
+        if (imageRequest) {
+            imageRequest->GetURI(getter_AddRefs(uri));
+            imageRect = list->mImageRegion.ToNearestPixels(
+                            pc->AppUnitsPerDevPixel());
+        }
+    }
+
+    if (!uri) {
+        mOwner->ClearIcon();
+        mURI = nullptr;
+
+        if (mImageRequest) {
+            mImageRequest->Cancel(NS_BINDING_ABORTED);
+            mImageRequest = nullptr;
+        }
+
+        return;
+    }
+
+    bool same;
+    if (mURI && NS_SUCCEEDED(mURI->Equals(uri, &same)) && same &&
+        (!imageRequest || imageRect == mImageRect)) {
+        return;
+    }
+
+    if (mImageRequest) {
+        mImageRequest->Cancel(NS_BINDING_ABORTED);
+        mImageRequest = nullptr;
+    }
+
+    mURI = uri;
+
+    if (imageRequest) {
+        mImageRect = imageRect;
+        imageRequest->Clone(this, nullptr, getter_AddRefs(mImageRequest));
+    } else {
+        mImageRect.SetEmpty();
+        nsCOMPtr<nsILoadGroup> loadGroup = doc->GetDocumentLoadGroup();
+        RefPtr<imgLoader> loader =
+            nsContentUtils::GetImgLoaderForDocument(doc);
+        if (!loader || !loadGroup) {
+            NS_WARNING("Failed to get loader or load group for image load");
+            return;
+        }
+
+        loader->LoadImage(uri, nullptr, nullptr, mozilla::net::RP_Unset,
+                          nullptr, loadGroup, this, nullptr, nullptr,
+                          nsIRequest::LOAD_NORMAL, nullptr,
+                          nsIContentPolicy::TYPE_IMAGE, EmptyString(),
+                          false, getter_AddRefs(mImageRequest));
+    }
+}
+
+void
+nsMenuObjectIconLoader::Destroy()
+{
+    if (mImageRequest) {
+        mImageRequest->CancelAndForgetObserver(NS_BINDING_ABORTED);
+        mImageRequest = nullptr;
+    }
+
+    mOwner = nullptr;
+}
+
+static int
+CalculateTextWidth(const nsAString& aText)
+{
+    if (!gPangoLayout) {
+        PangoFontMap *fontmap = pango_cairo_font_map_get_default();
+        PangoContext *ctx = pango_font_map_create_context(fontmap);
+        gPangoLayout = pango_layout_new(ctx);
+        g_object_unref(ctx);
+    }
+
+    pango_layout_set_text(gPangoLayout, NS_ConvertUTF16toUTF8(aText).get(), -1);
+
+    int width, dummy;
+    pango_layout_get_size(gPangoLayout, &width, &dummy);
+
+    return width;
+}
+
+static const nsDependentString
+GetEllipsis()
+{
+    static char16_t sBuf[4] = { 0, 0, 0, 0 };
+    if (!sBuf[0]) {
+        nsString ellipsis;
+        Preferences::GetLocalizedString("intl.ellipsis", ellipsis);
+        if (!ellipsis.IsEmpty()) {
+            uint32_t l = ellipsis.Length();
+            const nsString::char_type *c = ellipsis.BeginReading();
+            uint32_t i = 0;
+            while (i < 3 && i < l) {
+                sBuf[i++] = *(c++);
+            }
+        } else {
+            sBuf[0] = '.';
+            sBuf[1] = '.';
+            sBuf[2] = '.';
+        }
+    }
+
+    return nsDependentString(sBuf);
+}
+
+static int
+GetEllipsisWidth()
+{
+    static int sEllipsisWidth = -1;
+
+    if (sEllipsisWidth == -1) {
+        sEllipsisWidth = CalculateTextWidth(GetEllipsis());
+    }
+
+    return sEllipsisWidth;
+}
+
+nsMenuObject::nsMenuObject(nsMenuContainer *aParent, nsIContent *aContent) :
+    mContent(aContent),
+    mListener(aParent->DocListener()),
+    mParent(aParent),
+    mNativeData(nullptr)
+{
+    MOZ_ASSERT(mContent);
+    MOZ_ASSERT(mListener);
+    MOZ_ASSERT(mParent);
+}
+
+nsMenuObject::nsMenuObject(nsNativeMenuDocListener *aListener,
+                           nsIContent *aContent) :
+    mContent(aContent),
+    mListener(aListener),
+    mParent(nullptr),
+    mNativeData(nullptr)
+{
+    MOZ_ASSERT(mContent);
+    MOZ_ASSERT(mListener);
+}
+
+void
+nsMenuObject::UpdateLabel()
+{
+    // Gecko stores the label and access key in separate attributes
+    // so we need to convert label="Foo_Bar"/accesskey="F" in to
+    // label="_Foo__Bar" for dbusmenu
+
+    nsAutoString label;
+    mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::label, label);
+
+    nsAutoString accesskey;
+    mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::accesskey, accesskey);
+
+    const nsAutoString::char_type *akey = accesskey.BeginReading();
+    char16_t keyLower = ToLowerCase(*akey);
+    char16_t keyUpper = ToUpperCase(*akey);
+
+    const nsAutoString::char_type *iter = label.BeginReading();
+    const nsAutoString::char_type *end = label.EndReading();
+    uint32_t length = label.Length();
+    uint32_t pos = 0;
+    bool foundAccessKey = false;
+
+    while (iter != end) {
+        if (*iter != char16_t('_')) {
+            if ((*iter != keyLower && *iter != keyUpper) || foundAccessKey) {
+                ++iter;
+                ++pos;
+                continue;
+            }
+            foundAccessKey = true;
+        }
+
+        label.SetLength(++length);
+
+        iter = label.BeginReading() + pos;
+        end = label.EndReading();
+        nsAutoString::char_type *cur = label.BeginWriting() + pos;
+
+        memmove(cur + 1, cur, (length - 1 - pos) * sizeof(nsAutoString::char_type));
+        *cur = nsAutoString::char_type('_');
+
+        iter += 2;
+        pos += 2;
+    }
+
+    if (CalculateTextWidth(label) <= MAX_WIDTH) {
+        dbusmenu_menuitem_property_set(mNativeData,
+                                       DBUSMENU_MENUITEM_PROP_LABEL,
+                                       NS_ConvertUTF16toUTF8(label).get());
+        return;
+    }
+
+    // This sucks.
+    // This should be done at the point where the menu is drawn (hello Unity),
+    // but unfortunately it doesn't do that and will happily fill your entire
+    // screen width with a menu if you have a bookmark with a really long title.
+    // This leaves us with no other option but to ellipsize here, with no proper
+    // knowledge of Unity's render path, font size etc. This is better than nothing
+    nsAutoString truncated;
+    int target = MAX_WIDTH - GetEllipsisWidth();
+    length = label.Length();
+
+    static nsIContent::AttrValuesArray strings[] = {
+        &nsGkAtoms::left, &nsGkAtoms::start,
+        &nsGkAtoms::center, &nsGkAtoms::right,
+        &nsGkAtoms::end, nullptr
+    };
+
+    int32_t type = mContent->FindAttrValueIn(kNameSpaceID_None,
+                                             nsGkAtoms::crop,
+                                             strings, eCaseMatters);
+
+    switch (type) {
+        case 0:
+        case 1:
+            // FIXME: Implement left cropping
+        case 2:
+            // FIXME: Implement center cropping
+        case 3:
+        case 4:
+        default:
+            for (uint32_t i = 0; i < length; i++) {
+                truncated.Append(label.CharAt(i));
+                if (CalculateTextWidth(truncated) > target) {
+                    break;
+                }
+            }
+
+            truncated.Append(GetEllipsis());
+    }
+
+    dbusmenu_menuitem_property_set(mNativeData,
+                                   DBUSMENU_MENUITEM_PROP_LABEL,
+                                   NS_ConvertUTF16toUTF8(truncated).get());
+}
+
+void
+nsMenuObject::UpdateVisibility(nsStyleContext *aStyleContext)
+{
+    bool vis = true;
+
+    if (aStyleContext &&
+        (aStyleContext->StyleDisplay()->mDisplay == StyleDisplay::None ||
+         aStyleContext->StyleVisibility()->mVisible ==
+            NS_STYLE_VISIBILITY_COLLAPSE)) {
+        vis = false;
+    }
+
+    dbusmenu_menuitem_property_set_bool(mNativeData,
+                                        DBUSMENU_MENUITEM_PROP_VISIBLE,
+                                        vis);
+}
+
+void
+nsMenuObject::UpdateSensitivity()
+{
+    bool disabled = mContent->AttrValueIs(kNameSpaceID_None,
+                                          nsGkAtoms::disabled,
+                                          nsGkAtoms::_true, eCaseMatters);
+
+    dbusmenu_menuitem_property_set_bool(mNativeData,
+                                        DBUSMENU_MENUITEM_PROP_ENABLED,
+                                        !disabled);
+
+}
+
+void
+nsMenuObject::UpdateIcon(nsStyleContext *aStyleContext)
+{
+    if (ShouldShowIcon()) {
+        if (!mIconLoader) {
+            mIconLoader = new nsMenuObjectIconLoader(this);
+        }
+
+        mIconLoader->LoadIcon(aStyleContext);
+    } else {
+        if (mIconLoader) {
+            mIconLoader->Destroy();
+            mIconLoader = nullptr;
+        }
+
+        ClearIcon();
+    }
+}
+
+already_AddRefed<nsStyleContext>
+nsMenuObject::GetStyleContext()
+{
+    nsIPresShell *shell = mContent->OwnerDoc()->GetShell();
+    if (!shell) {
+        return nullptr;
+    }
+
+    RefPtr<nsStyleContext> sc =
+        nsComputedDOMStyle::GetStyleContextNoFlush(
+            mContent->AsElement(), nullptr, shell);
+
+    return sc.forget();
+}
+
+void
+nsMenuObject::InitializeNativeData()
+{
+}
+
+nsMenuObject::PropertyFlags
+nsMenuObject::SupportedProperties() const
+{
+    return static_cast<nsMenuObject::PropertyFlags>(0);
+}
+
+bool
+nsMenuObject::IsCompatibleWithNativeData(DbusmenuMenuitem *aNativeData) const
+{
+    return true;
+}
+
+void
+nsMenuObject::UpdateContentAttributes()
+{
+}
+
+void
+nsMenuObject::Update(nsStyleContext *aStyleContext)
+{
+}
+
+bool
+nsMenuObject::ShouldShowIcon() const
+{
+    // Ideally we want to know the visibility of the anonymous XUL image in
+    // our menuitem, but this isn't created because we don't have a frame.
+    // The following works by default (because xul.css hides images in menuitems
+    // that don't have the "menuitem-with-favicon" class). It's possible a third
+    // party theme could override this, but, oh well...
+    const nsAttrValue *classes = mContent->AsElement()->GetClasses();
+    if (!classes) {
+        return false;
+    }
+
+    for (uint32_t i = 0; i < classes->GetAtomCount(); ++i) {
+        if (classes->AtomAt(i) == nsNativeMenuAtoms::menuitem_with_favicon) {
+            return true;
+        }
+    }
+
+    return false;
+}
+
+void
+nsMenuObject::ClearIcon()
+{
+    dbusmenu_menuitem_property_remove(mNativeData,
+                                      DBUSMENU_MENUITEM_PROP_ICON_DATA);
+}
+
+nsMenuObject::~nsMenuObject()
+{
+    nsWeakMenuObject::NotifyDestroyed(this);
+
+    if (mIconLoader) {
+        mIconLoader->Destroy();
+    }
+
+    if (mListener) {
+        mListener->UnregisterForContentChanges(mContent);
+    }
+
+    if (mNativeData) {
+        g_object_unref(mNativeData);
+        mNativeData = nullptr;
+    }
+}
+
+void
+nsMenuObject::CreateNativeData()
+{
+    MOZ_ASSERT(mNativeData == nullptr, "This node already has a DbusmenuMenuitem. The old one will be leaked");
+
+    mNativeData = dbusmenu_menuitem_new();
+    InitializeNativeData();
+    if (mParent && mParent->IsBeingDisplayed()) {
+        ContainerIsOpening();
+    }
+
+    mListener->RegisterForContentChanges(mContent, this);
+}
+
+nsresult
+nsMenuObject::AdoptNativeData(DbusmenuMenuitem *aNativeData)
+{
+    MOZ_ASSERT(mNativeData == nullptr, "This node already has a DbusmenuMenuitem. The old one will be leaked");
+
+    if (!IsCompatibleWithNativeData(aNativeData)) {
+        return NS_ERROR_FAILURE;
+    }
+
+    mNativeData = aNativeData;
+    g_object_ref(mNativeData);
+
+    PropertyFlags supported = SupportedProperties();
+    PropertyFlags mask = static_cast<PropertyFlags>(1);
+
+    for (uint32_t i = 0; gPropertyStrings[i]; ++i) {
+        if (!(mask & supported)) {
+            dbusmenu_menuitem_property_remove(mNativeData, gPropertyStrings[i]);
+        }
+        mask = static_cast<PropertyFlags>(mask << 1);
+    }
+
+    InitializeNativeData();
+    if (mParent && mParent->IsBeingDisplayed()) {
+        ContainerIsOpening();
+    }
+
+    mListener->RegisterForContentChanges(mContent, this);
+
+    return NS_OK;
+}
+
+void
+nsMenuObject::ContainerIsOpening()
+{
+    MOZ_ASSERT(nsContentUtils::IsSafeToRunScript());
+
+    UpdateContentAttributes();
+
+    RefPtr<nsStyleContext> sc = GetStyleContext();
+    Update(sc);
+}
+
+/* static */ void
+nsWeakMenuObject::AddWeakReference(nsWeakMenuObject *aWeak)
+{
+    aWeak->mPrev = sHead;
+    sHead = aWeak;
+}
+
+/* static */ void
+nsWeakMenuObject::RemoveWeakReference(nsWeakMenuObject *aWeak)
+{
+    if (aWeak == sHead) {
+        sHead = aWeak->mPrev;
+        return;
+    }
+
+    nsWeakMenuObject *weak = sHead;
+    while (weak && weak->mPrev != aWeak) {
+        weak = weak->mPrev;
+    }
+
+    if (weak) {
+        weak->mPrev = aWeak->mPrev;
+    }
+}
+
+/* static */ void
+nsWeakMenuObject::NotifyDestroyed(nsMenuObject *aMenuObject)
+{
+    nsWeakMenuObject *weak = sHead;
+    while (weak) {
+        if (weak->mMenuObject == aMenuObject) {
+            weak->mMenuObject = nullptr;
+        }
+
+        weak = weak->mPrev;
+    }
+}
diff --git a/widget/gtk/nsMenuObject.h b/widget/gtk/nsMenuObject.h
new file mode 100644
index 000000000000..b1a58bab8ddb
--- /dev/null
+++ b/widget/gtk/nsMenuObject.h
@@ -0,0 +1,170 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* vim:expandtab:shiftwidth=4:tabstop=4:
+ */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef __nsMenuObject_h__
+#define __nsMenuObject_h__
+
+#include "mozilla/Attributes.h"
+#include "nsCOMPtr.h"
+
+#include "nsDbusmenu.h"
+#include "nsNativeMenuDocListener.h"
+
+class nsIAtom;
+class nsIContent;
+class nsStyleContext;
+class nsMenuContainer;
+class nsMenuObjectIconLoader;
+
+#define DBUSMENU_PROPERTIES \
+    DBUSMENU_PROPERTY(Label, DBUSMENU_MENUITEM_PROP_LABEL, 0) \
+    DBUSMENU_PROPERTY(Enabled, DBUSMENU_MENUITEM_PROP_ENABLED, 1) \
+    DBUSMENU_PROPERTY(Visible, DBUSMENU_MENUITEM_PROP_VISIBLE, 2) \
+    DBUSMENU_PROPERTY(IconData, DBUSMENU_MENUITEM_PROP_ICON_DATA, 3) \
+    DBUSMENU_PROPERTY(Type, DBUSMENU_MENUITEM_PROP_TYPE, 4) \
+    DBUSMENU_PROPERTY(Shortcut, DBUSMENU_MENUITEM_PROP_SHORTCUT, 5) \
+    DBUSMENU_PROPERTY(ToggleType, DBUSMENU_MENUITEM_PROP_TOGGLE_TYPE, 6) \
+    DBUSMENU_PROPERTY(ToggleState, DBUSMENU_MENUITEM_PROP_TOGGLE_STATE, 7) \
+    DBUSMENU_PROPERTY(ChildDisplay, DBUSMENU_MENUITEM_PROP_CHILD_DISPLAY, 8)
+
+/*
+ * This is the base class for all menu nodes. Each instance represents
+ * a single node in the menu hierarchy. It wraps the corresponding DOM node and
+ * native menu node, keeps them in sync and transfers events between the two.
+ * It is not reference counted - each node is owned by its parent (the top
+ * level menubar is owned by the window) and keeps a weak pointer to its
+ * parent (which is guaranteed to always be valid because a node will never
+ * outlive its parent). It is not safe to keep a reference to nsMenuObject
+ * externally.
+ */
+class nsMenuObject : public nsNativeMenuChangeObserver
+{
+public:
+    enum EType {
+        eType_MenuBar,
+        eType_Menu,
+        eType_MenuItem
+    };
+
+    virtual ~nsMenuObject();
+
+    // Get the native menu item node
+    DbusmenuMenuitem* GetNativeData() const { return mNativeData; }
+
+    // Get the parent menu object
+    nsMenuContainer* Parent() const { return mParent; }
+
+    // Get the content node
+    nsIContent* ContentNode() const { return mContent; }
+
+    // Get the type of this node. Must be provided by subclasses
+    virtual EType Type() const = 0;
+
+    // Get the document listener
+    nsNativeMenuDocListener* DocListener() const { return mListener; }
+
+    // Create the native menu item node (called by containers)
+    void CreateNativeData();
+
+    // Adopt the specified native menu item node (called by containers)
+    nsresult AdoptNativeData(DbusmenuMenuitem *aNativeData);
+
+    // Called by the container to tell us that it's opening
+    void ContainerIsOpening();
+
+protected:
+    nsMenuObject(nsMenuContainer *aParent, nsIContent *aContent);
+    nsMenuObject(nsNativeMenuDocListener *aListener, nsIContent *aContent);
+
+    enum PropertyFlags {
+#define DBUSMENU_PROPERTY(e, s, b) eProp##e = (1 << b),
+        DBUSMENU_PROPERTIES
+#undef DBUSMENU_PROPERTY
+    };
+
+    void UpdateLabel();
+    void UpdateVisibility(nsStyleContext *aStyleContext);
+    void UpdateSensitivity();
+    void UpdateIcon(nsStyleContext *aStyleContext);
+
+    already_AddRefed<nsStyleContext> GetStyleContext();
+
+private:
+    friend class nsMenuObjectIconLoader;
+
+    // Set up initial properties on the native data, connect to signals etc.
+    // This should be implemented by subclasses
+    virtual void InitializeNativeData();
+
+    // Return the properties that this menu object type supports
+    // This should be implemented by subclasses
+    virtual PropertyFlags SupportedProperties() const;
+
+    // Determine whether this menu object could use the specified
+    // native item. Returns true by default but can be overridden by subclasses
+    virtual bool
+    IsCompatibleWithNativeData(DbusmenuMenuitem *aNativeData) const;
+
+    // Update attributes on this objects content node when the container opens.
+    // This is called before style resolution, and should be implemented by
+    // subclasses who want to modify attributes that might affect style.
+    // This will not be called when there are script blockers
+    virtual void UpdateContentAttributes();
+
+    // Update properties that should be refreshed when the container opens.
+    // This should be implemented by subclasses that have properties which
+    // need refreshing
+    virtual void Update(nsStyleContext *aStyleContext);
+
+    bool ShouldShowIcon() const;
+    void ClearIcon();
+
+    nsCOMPtr<nsIContent> mContent;
+    // mListener is a strong ref for simplicity - someone in the tree needs to
+    // own it, and this only really needs to be the top-level object (as no
+    // children outlives their parent). However, we need to keep it alive until
+    // after running the nsMenuObject destructor for the top-level menu object,
+    // hence the strong ref
+    RefPtr<nsNativeMenuDocListener> mListener;
+    nsMenuContainer *mParent; // [weak]
+    DbusmenuMenuitem *mNativeData; // [strong]
+    RefPtr<nsMenuObjectIconLoader> mIconLoader;
+};
+
+// Keep a weak pointer to a menu object
+class nsWeakMenuObject
+{
+public:
+    nsWeakMenuObject() : mPrev(nullptr), mMenuObject(nullptr) {}
+
+    nsWeakMenuObject(nsMenuObject *aMenuObject) :
+        mPrev(nullptr), mMenuObject(aMenuObject)
+    {
+        AddWeakReference(this);
+    }
+
+    ~nsWeakMenuObject() { RemoveWeakReference(this); }
+
+    nsMenuObject* get() const { return mMenuObject; }
+
+    nsMenuObject* operator->() const { return mMenuObject; }
+
+    explicit operator bool() const { return !!mMenuObject; }
+
+    static void NotifyDestroyed(nsMenuObject *aMenuObject);
+
+private:
+    static void AddWeakReference(nsWeakMenuObject *aWeak);
+    static void RemoveWeakReference(nsWeakMenuObject *aWeak);
+
+    nsWeakMenuObject *mPrev;
+    static nsWeakMenuObject *sHead;
+
+    nsMenuObject *mMenuObject;
+};
+
+#endif /* __nsMenuObject_h__ */
diff --git a/widget/gtk/nsMenuSeparator.cpp b/widget/gtk/nsMenuSeparator.cpp
new file mode 100644
index 000000000000..d3045c4b29d9
--- /dev/null
+++ b/widget/gtk/nsMenuSeparator.cpp
@@ -0,0 +1,85 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* vim:expandtab:shiftwidth=4:tabstop=4:
+ */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/Assertions.h"
+#include "mozilla/Move.h"
+#include "nsAutoPtr.h"
+#include "nsCRT.h"
+#include "nsGkAtoms.h"
+#include "nsStyleContext.h"
+
+#include "nsDbusmenu.h"
+
+#include "nsMenuContainer.h"
+#include "nsMenuSeparator.h"
+
+using namespace mozilla;
+
+void
+nsMenuSeparator::InitializeNativeData()
+{
+    dbusmenu_menuitem_property_set(GetNativeData(),
+                                   DBUSMENU_MENUITEM_PROP_TYPE,
+                                   "separator");
+}
+
+void
+nsMenuSeparator::Update(nsStyleContext *aContext)
+{
+    UpdateVisibility(aContext);
+}
+
+bool
+nsMenuSeparator::IsCompatibleWithNativeData(DbusmenuMenuitem *aNativeData) const
+{
+    return nsCRT::strcmp(dbusmenu_menuitem_property_get(aNativeData,
+                                                        DBUSMENU_MENUITEM_PROP_TYPE),
+                         "separator") == 0;
+}
+
+nsMenuObject::PropertyFlags
+nsMenuSeparator::SupportedProperties() const
+{
+    return static_cast<nsMenuObject::PropertyFlags>(
+        nsMenuObject::ePropVisible |
+        nsMenuObject::ePropType
+    );
+}
+
+void
+nsMenuSeparator::OnAttributeChanged(nsIContent *aContent, nsIAtom *aAttribute)
+{
+    MOZ_ASSERT(aContent == ContentNode(), "Received an event that wasn't meant for us!");
+
+    if (!Parent()->IsBeingDisplayed()) {
+        return;
+    }
+
+    if (aAttribute == nsGkAtoms::hidden ||
+        aAttribute == nsGkAtoms::collapsed) {
+        RefPtr<nsStyleContext> sc = GetStyleContext();
+        UpdateVisibility(sc);
+    }
+}
+
+nsMenuSeparator::nsMenuSeparator(nsMenuContainer *aParent,
+                                 nsIContent *aContent) :
+    nsMenuObject(aParent, aContent)
+{
+    MOZ_COUNT_CTOR(nsMenuSeparator);
+}
+
+nsMenuSeparator::~nsMenuSeparator()
+{
+    MOZ_COUNT_DTOR(nsMenuSeparator);
+}
+
+nsMenuObject::EType
+nsMenuSeparator::Type() const
+{
+    return eType_MenuItem;
+}
diff --git a/widget/gtk/nsMenuSeparator.h b/widget/gtk/nsMenuSeparator.h
new file mode 100644
index 000000000000..35140e0596c0
--- /dev/null
+++ b/widget/gtk/nsMenuSeparator.h
@@ -0,0 +1,37 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* vim:expandtab:shiftwidth=4:tabstop=4:
+ */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef __nsMenuSeparator_h__
+#define __nsMenuSeparator_h__
+
+#include "mozilla/Attributes.h"
+
+#include "nsMenuObject.h"
+
+class nsIContent;
+class nsIAtom;
+class nsMenuContainer;
+
+// Menu separator class
+class nsMenuSeparator final : public nsMenuObject
+{
+public:
+    nsMenuSeparator(nsMenuContainer *aParent, nsIContent *aContent);
+    ~nsMenuSeparator();
+
+    nsMenuObject::EType Type() const override;
+
+private:
+    void InitializeNativeData() override;
+    void Update(nsStyleContext *aStyleContext) override;
+    bool IsCompatibleWithNativeData(DbusmenuMenuitem *aNativeData) const override;
+    nsMenuObject::PropertyFlags SupportedProperties() const override;
+
+    void OnAttributeChanged(nsIContent *aContent, nsIAtom *aAttribute) override;
+};
+
+#endif /* __nsMenuSeparator_h__ */
diff --git a/widget/gtk/nsNativeMenuAtomList.h b/widget/gtk/nsNativeMenuAtomList.h
new file mode 100644
index 000000000000..32da73c42c8b
--- /dev/null
+++ b/widget/gtk/nsNativeMenuAtomList.h
@@ -0,0 +1,12 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* vim:expandtab:shiftwidth=4:tabstop=4:
+ */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+WIDGET_ATOM2(menuitem_with_favicon, "menuitem-with-favicon")
+WIDGET_ATOM2(_moz_menubarkeeplocal, "_moz-menubarkeeplocal")
+WIDGET_ATOM2(_moz_nativemenupopupstate, "_moz-nativemenupopupstate")
+WIDGET_ATOM(openedwithkey)
+WIDGET_ATOM(shellshowingmenubar)
diff --git a/widget/gtk/nsNativeMenuAtoms.cpp b/widget/gtk/nsNativeMenuAtoms.cpp
new file mode 100644
index 000000000000..2d5492b48147
--- /dev/null
+++ b/widget/gtk/nsNativeMenuAtoms.cpp
@@ -0,0 +1,39 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* vim:expandtab:shiftwidth=4:tabstop=4:
+ */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "nsIAtom.h"
+#include "nsStaticAtom.h"
+
+#include "nsNativeMenuAtoms.h"
+
+using namespace mozilla;
+
+#define WIDGET_ATOM(_name) nsIAtom* nsNativeMenuAtoms::_name;
+#define WIDGET_ATOM2(_name, _value) nsIAtom* nsNativeMenuAtoms::_name;
+#include "nsNativeMenuAtomList.h"
+#undef WIDGET_ATOM
+#undef WIDGET_ATOM2
+
+#define WIDGET_ATOM(name_) NS_STATIC_ATOM_BUFFER(name_##_buffer, #name_)
+#define WIDGET_ATOM2(name_, value_) NS_STATIC_ATOM_BUFFER(name_##_buffer, value_)
+#include "nsNativeMenuAtomList.h"
+#undef WIDGET_ATOM
+#undef WIDGET_ATOM2
+
+static const nsStaticAtom gAtoms[] = {
+#define WIDGET_ATOM(name_) NS_STATIC_ATOM(name_##_buffer, &nsNativeMenuAtoms::name_),
+#define WIDGET_ATOM2(name_, value_) NS_STATIC_ATOM(name_##_buffer, &nsNativeMenuAtoms::name_),
+#include "nsNativeMenuAtomList.h"
+#undef WIDGET_ATOM
+#undef WIDGET_ATOM2
+};
+
+/* static */ void
+nsNativeMenuAtoms::RegisterAtoms()
+{
+    NS_RegisterStaticAtoms(gAtoms);
+}
diff --git a/widget/gtk/nsNativeMenuAtoms.h b/widget/gtk/nsNativeMenuAtoms.h
new file mode 100644
index 000000000000..0f053688004f
--- /dev/null
+++ b/widget/gtk/nsNativeMenuAtoms.h
@@ -0,0 +1,27 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* vim:expandtab:shiftwidth=4:tabstop=4:
+ */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef __nsNativeMenuAtoms_h__
+#define __nsNativeMenuAtoms_h__
+
+class nsIAtom;
+
+class nsNativeMenuAtoms
+{
+public:
+    nsNativeMenuAtoms() = delete;
+
+    static void RegisterAtoms();
+
+#define WIDGET_ATOM(_name) static nsIAtom* _name;
+#define WIDGET_ATOM2(_name, _value) static nsIAtom* _name;
+#include "nsNativeMenuAtomList.h"
+#undef WIDGET_ATOM
+#undef WIDGET_ATOM2
+};
+
+#endif /* __nsNativeMenuAtoms_h__ */
diff --git a/widget/gtk/nsNativeMenuDocListener.cpp b/widget/gtk/nsNativeMenuDocListener.cpp
new file mode 100644
index 000000000000..4b106f714b04
--- /dev/null
+++ b/widget/gtk/nsNativeMenuDocListener.cpp
@@ -0,0 +1,350 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* vim:expandtab:shiftwidth=4:tabstop=4:
+ */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/Assertions.h"
+#include "mozilla/DebugOnly.h"
+#include "mozilla/dom/Element.h"
+#include "nsContentUtils.h"
+#include "nsIAtom.h"
+#include "nsIContent.h"
+#include "nsIDocument.h"
+
+#include "nsMenuContainer.h"
+
+#include "nsNativeMenuDocListener.h"
+
+using namespace mozilla;
+
+uint32_t nsNativeMenuDocListener::sUpdateBlockersCount = 0;
+
+nsNativeMenuDocListenerTArray *gPendingListeners;
+
+/*
+ * Small helper which caches a single listener, so that consecutive
+ * events which go to the same node avoid multiple hash table lookups
+ */
+class MOZ_STACK_CLASS DispatchHelper
+{
+public:
+    DispatchHelper(nsNativeMenuDocListener *aListener,
+                   nsIContent *aContent
+                   MOZ_GUARD_OBJECT_NOTIFIER_PARAM) :
+                   mObserver(nullptr)
+    {
+        MOZ_GUARD_OBJECT_NOTIFIER_INIT;
+        if (aContent == aListener->mLastSource) {
+            mObserver = aListener->mLastTarget;
+        } else {
+            mObserver = aListener->mContentToObserverTable.Get(aContent);
+            if (mObserver) {
+                aListener->mLastSource = aContent;
+                aListener->mLastTarget = mObserver;
+            }
+        }
+    }
+
+    ~DispatchHelper() { };
+
+    nsNativeMenuChangeObserver* Observer() const { return mObserver; }
+
+    bool HasObserver() const { return !!mObserver; }
+
+private:
+    nsNativeMenuChangeObserver *mObserver;
+    MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
+};
+
+NS_IMPL_ISUPPORTS(nsNativeMenuDocListener, nsIMutationObserver)
+
+nsNativeMenuDocListener::~nsNativeMenuDocListener()
+{
+    MOZ_ASSERT(mContentToObserverTable.Count() == 0,
+               "Some nodes forgot to unregister listeners. This is bad! (and we're lucky we made it this far)");
+    MOZ_COUNT_DTOR(nsNativeMenuDocListener);
+}
+
+void
+nsNativeMenuDocListener::AttributeChanged(nsIDocument *aDocument,
+                                          mozilla::dom::Element *aElement,
+                                          int32_t aNameSpaceID,
+                                          nsIAtom *aAttribute,
+                                          int32_t aModType,
+                                          const nsAttrValue* aOldValue)
+{
+    if (sUpdateBlockersCount == 0) {
+        DoAttributeChanged(aElement, aAttribute);
+        return;
+    }
+
+    MutationRecord *m = *mPendingMutations.AppendElement(new MutationRecord);
+    m->mType = MutationRecord::eAttributeChanged;
+    m->mTarget = aElement;
+    m->mAttribute = aAttribute;
+
+    ScheduleFlush(this);
+}
+
+void
+nsNativeMenuDocListener::ContentAppended(nsIDocument *aDocument,
+                                         nsIContent *aContainer,
+                                         nsIContent *aFirstNewContent,
+                                         int32_t aNewIndexInContainer)
+{
+    for (nsIContent *c = aFirstNewContent; c; c = c->GetNextSibling()) {
+        ContentInserted(aDocument, aContainer, c, 0);
+    }
+}
+
+void
+nsNativeMenuDocListener::ContentInserted(nsIDocument *aDocument,
+                                         nsIContent *aContainer,
+                                         nsIContent *aChild,
+                                         int32_t aIndexInContainer)
+{
+    nsIContent *prevSibling = nsMenuContainer::GetPreviousSupportedSibling(aChild);
+
+    if (sUpdateBlockersCount == 0) {
+        DoContentInserted(aContainer, aChild, prevSibling);
+        return;
+    }
+
+    MutationRecord *m = *mPendingMutations.AppendElement(new MutationRecord);
+    m->mType = MutationRecord::eContentInserted;
+    m->mTarget = aContainer;
+    m->mChild = aChild;
+    m->mPrevSibling = prevSibling;
+
+    ScheduleFlush(this);
+}
+
+void
+nsNativeMenuDocListener::ContentRemoved(nsIDocument *aDocument,
+                                        nsIContent *aContainer,
+                                        nsIContent *aChild,
+                                        int32_t aIndexInContainer,
+                                        nsIContent *aPreviousSibling)
+{
+    if (sUpdateBlockersCount == 0) {
+        DoContentRemoved(aContainer, aChild);
+        return;
+    }
+
+    MutationRecord *m = *mPendingMutations.AppendElement(new MutationRecord);
+    m->mType = MutationRecord::eContentRemoved;
+    m->mTarget = aContainer;
+    m->mChild = aChild;
+
+    ScheduleFlush(this);
+}
+
+void
+nsNativeMenuDocListener::NodeWillBeDestroyed(const nsINode *aNode)
+{
+    mDocument = nullptr;
+}
+
+void
+nsNativeMenuDocListener::DoAttributeChanged(nsIContent *aContent,
+                                            nsIAtom *aAttribute)
+{
+    DispatchHelper h(this, aContent);
+    if (h.HasObserver()) {
+        h.Observer()->OnAttributeChanged(aContent, aAttribute);
+    }
+}
+
+void
+nsNativeMenuDocListener::DoContentInserted(nsIContent *aContainer,
+                                           nsIContent *aChild,
+                                           nsIContent *aPrevSibling)
+{
+    DispatchHelper h(this, aContainer);
+    if (h.HasObserver()) {
+        h.Observer()->OnContentInserted(aContainer, aChild, aPrevSibling);
+    }
+}
+
+void
+nsNativeMenuDocListener::DoContentRemoved(nsIContent *aContainer,
+                                          nsIContent *aChild)
+{
+    DispatchHelper h(this, aContainer);
+    if (h.HasObserver()) {
+        h.Observer()->OnContentRemoved(aContainer, aChild);
+    }
+}
+
+void
+nsNativeMenuDocListener::DoBeginUpdates(nsIContent *aTarget)
+{
+    DispatchHelper h(this, aTarget);
+    if (h.HasObserver()) {
+        h.Observer()->OnBeginUpdates(aTarget);
+    }
+}
+
+void
+nsNativeMenuDocListener::DoEndUpdates(nsIContent *aTarget)
+{
+    DispatchHelper h(this, aTarget);
+    if (h.HasObserver()) {
+        h.Observer()->OnEndUpdates();
+    }
+}
+
+void
+nsNativeMenuDocListener::FlushPendingMutations()
+{
+    nsIContent *currentTarget = nullptr;
+    bool inUpdateSequence = false;
+
+    while (mPendingMutations.Length() > 0) {
+        MutationRecord *m = mPendingMutations[0];
+
+        if (m->mTarget != currentTarget) {
+            if (inUpdateSequence) {
+                DoEndUpdates(currentTarget);
+                inUpdateSequence = false;
+            }
+
+            currentTarget = m->mTarget;
+
+            if (mPendingMutations.Length() > 1 &&
+                mPendingMutations[1]->mTarget == currentTarget) {
+                DoBeginUpdates(currentTarget);
+                inUpdateSequence = true;
+            }
+        }
+
+        switch (m->mType) {
+            case MutationRecord::eAttributeChanged:
+                DoAttributeChanged(m->mTarget, m->mAttribute);
+                break;
+            case MutationRecord::eContentInserted:
+                DoContentInserted(m->mTarget, m->mChild, m->mPrevSibling);
+                break;
+            case MutationRecord::eContentRemoved:
+                DoContentRemoved(m->mTarget, m->mChild);
+                break;
+            default:
+                NS_NOTREACHED("Invalid type");
+        }
+
+        mPendingMutations.RemoveElementAt(0);
+    }
+
+    if (inUpdateSequence) {
+        DoEndUpdates(currentTarget);
+    }
+}
+
+/* static */ void
+nsNativeMenuDocListener::ScheduleFlush(nsNativeMenuDocListener *aListener)
+{
+    MOZ_ASSERT(sUpdateBlockersCount > 0, "Shouldn't be doing this now");
+
+    if (!gPendingListeners) {
+        gPendingListeners = new nsNativeMenuDocListenerTArray;
+    }
+
+    if (gPendingListeners->IndexOf(aListener) ==
+        nsNativeMenuDocListenerTArray::NoIndex) {
+        gPendingListeners->AppendElement(aListener);
+    }
+}
+
+/* static */ void
+nsNativeMenuDocListener::CancelFlush(nsNativeMenuDocListener *aListener)
+{
+    if (!gPendingListeners) {
+        return;
+    }
+
+    gPendingListeners->RemoveElement(aListener);
+}
+
+/* static */ void
+nsNativeMenuDocListener::RemoveUpdateBlocker()
+{
+    if (sUpdateBlockersCount == 1 && gPendingListeners) {
+        while (gPendingListeners->Length() > 0) {
+            (*gPendingListeners)[0]->FlushPendingMutations();
+            gPendingListeners->RemoveElementAt(0);
+        }
+    }
+
+    MOZ_ASSERT(sUpdateBlockersCount > 0, "Negative update blockers count!");
+    sUpdateBlockersCount--;
+}
+
+nsNativeMenuDocListener::nsNativeMenuDocListener(nsIContent *aRootNode) :
+    mRootNode(aRootNode),
+    mDocument(nullptr),
+    mLastSource(nullptr),
+    mLastTarget(nullptr)
+{
+    MOZ_COUNT_CTOR(nsNativeMenuDocListener);
+}
+
+void
+nsNativeMenuDocListener::RegisterForContentChanges(nsIContent *aContent,
+                                                   nsNativeMenuChangeObserver *aObserver)
+{
+    MOZ_ASSERT(aContent, "Need content parameter");
+    MOZ_ASSERT(aObserver, "Need observer parameter");
+    if (!aContent || !aObserver) {
+        return;
+    }
+
+    DebugOnly<nsNativeMenuChangeObserver *> old;
+    MOZ_ASSERT(!mContentToObserverTable.Get(aContent, &old) || old == aObserver,
+               "Multiple observers for the same content node are not supported");
+
+    mContentToObserverTable.Put(aContent, aObserver);
+}
+
+void
+nsNativeMenuDocListener::UnregisterForContentChanges(nsIContent *aContent)
+{
+    MOZ_ASSERT(aContent, "Need content parameter");
+    if (!aContent) {
+        return;
+    }
+
+    mContentToObserverTable.Remove(aContent);
+    if (aContent == mLastSource) {
+        mLastSource = nullptr;
+        mLastTarget = nullptr;
+    }
+}
+
+void
+nsNativeMenuDocListener::Start()
+{
+    if (mDocument) {
+        return;
+    }
+
+    mDocument = mRootNode->OwnerDoc();
+    if (!mDocument) {
+        return;
+    }
+
+    mDocument->AddMutationObserver(this);
+}
+
+void
+nsNativeMenuDocListener::Stop()
+{
+    if (mDocument) {
+        mDocument->RemoveMutationObserver(this);
+        mDocument = nullptr;
+    }
+
+    CancelFlush(this);
+    mPendingMutations.Clear();
+}
diff --git a/widget/gtk/nsNativeMenuDocListener.h b/widget/gtk/nsNativeMenuDocListener.h
new file mode 100644
index 000000000000..cfdd5b2cf40d
--- /dev/null
+++ b/widget/gtk/nsNativeMenuDocListener.h
@@ -0,0 +1,152 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* vim:expandtab:shiftwidth=4:tabstop=4:
+ */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef __nsNativeMenuDocListener_h__
+#define __nsNativeMenuDocListener_h__
+
+#include "mozilla/Attributes.h"
+#include "mozilla/GuardObjects.h"
+#include "mozilla/RefPtr.h"
+#include "nsAutoPtr.h"
+#include "nsDataHashtable.h"
+#include "nsStubMutationObserver.h"
+#include "nsTArray.h"
+
+class nsIAtom;
+class nsIContent;
+class nsIDocument;
+class nsNativeMenuChangeObserver;
+
+/*
+ * This class keeps a mapping of content nodes to observers and forwards DOM
+ * mutations to these. There is exactly one of these for every menubar.
+ */
+class nsNativeMenuDocListener final : nsStubMutationObserver
+{
+public:
+    NS_DECL_ISUPPORTS
+
+    nsNativeMenuDocListener(nsIContent *aRootNode);
+
+    // Register an observer to receive mutation events for the specified
+    // content node. The caller must keep the observer alive until
+    // UnregisterForContentChanges is called.
+    void RegisterForContentChanges(nsIContent *aContent,
+                                   nsNativeMenuChangeObserver *aObserver);
+
+    // Unregister the registered observer for the specified content node
+    void UnregisterForContentChanges(nsIContent *aContent);
+
+    // Start listening to the document and forwarding DOM mutations to
+    // registered observers.
+    void Start();
+
+    // Stop listening to the document. No DOM mutations will be forwarded
+    // to registered observers.
+    void Stop();
+
+    /*
+     * This class is intended to be used inside GObject signal handlers.
+     * It allows us to queue updates until we have finished delivering
+     * events to Gecko, and then we can batch updates to our view of the
+     * menu. This allows us to do menu updates without altering the structure
+     * seen by the OS.
+     */
+    class MOZ_STACK_CLASS BlockUpdatesScope
+    {
+    public:
+        BlockUpdatesScope(MOZ_GUARD_OBJECT_NOTIFIER_ONLY_PARAM)
+        {
+            MOZ_GUARD_OBJECT_NOTIFIER_INIT;
+            nsNativeMenuDocListener::AddUpdateBlocker();
+        }
+
+        ~BlockUpdatesScope()
+        {
+            nsNativeMenuDocListener::RemoveUpdateBlocker();
+        }
+
+    private:
+        MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
+    };
+
+private:
+    friend class DispatchHelper;
+
+    struct MutationRecord {
+        enum RecordType {
+            eAttributeChanged,
+            eContentInserted,
+            eContentRemoved
+        } mType;
+
+        nsCOMPtr<nsIContent> mTarget;
+        nsCOMPtr<nsIContent> mChild;
+        nsCOMPtr<nsIContent> mPrevSibling;
+        nsCOMPtr<nsIAtom> mAttribute;
+    };
+
+    ~nsNativeMenuDocListener();
+
+    NS_DECL_NSIMUTATIONOBSERVER_ATTRIBUTECHANGED
+    NS_DECL_NSIMUTATIONOBSERVER_CONTENTAPPENDED
+    NS_DECL_NSIMUTATIONOBSERVER_CONTENTINSERTED
+    NS_DECL_NSIMUTATIONOBSERVER_CONTENTREMOVED
+    NS_DECL_NSIMUTATIONOBSERVER_NODEWILLBEDESTROYED
+
+    void DoAttributeChanged(nsIContent *aContent, nsIAtom *aAttribute);
+    void DoContentInserted(nsIContent *aContainer,
+                           nsIContent *aChild,
+                           nsIContent *aPrevSibling);
+    void DoContentRemoved(nsIContent *aContainer, nsIContent *aChild);
+    void DoBeginUpdates(nsIContent *aTarget);
+    void DoEndUpdates(nsIContent *aTarget);
+
+    void FlushPendingMutations();
+    static void ScheduleFlush(nsNativeMenuDocListener *aListener);
+    static void CancelFlush(nsNativeMenuDocListener *aListener);
+
+    static void AddUpdateBlocker() { ++sUpdateBlockersCount; }
+    static void RemoveUpdateBlocker();
+
+    nsCOMPtr<nsIContent> mRootNode;
+    nsIDocument *mDocument;
+    nsIContent *mLastSource;
+    nsNativeMenuChangeObserver *mLastTarget;
+    nsTArray<nsAutoPtr<MutationRecord> > mPendingMutations;
+    nsDataHashtable<nsPtrHashKey<nsIContent>, nsNativeMenuChangeObserver *> mContentToObserverTable;
+
+    static uint32_t sUpdateBlockersCount;
+};
+
+typedef nsTArray<RefPtr<nsNativeMenuDocListener> > nsNativeMenuDocListenerTArray;
+
+/*
+ * Implemented by classes that want to listen to mutation events from content
+ * nodes.
+ */
+class nsNativeMenuChangeObserver
+{
+public:
+    virtual void OnAttributeChanged(nsIContent *aContent, nsIAtom *aAttribute) {}
+
+    virtual void OnContentInserted(nsIContent *aContainer,
+                                   nsIContent *aChild,
+                                   nsIContent *aPrevSibling) {}
+
+    virtual void OnContentRemoved(nsIContent *aContainer, nsIContent *aChild) {}
+
+    // Signals the start of a sequence of more than 1 event for the specified
+    // node. This only happens when events are flushed as all BlockUpdatesScope
+    // instances go out of scope
+    virtual void OnBeginUpdates(nsIContent *aContent) {};
+
+    // Signals the end of a sequence of events
+    virtual void OnEndUpdates() {};
+};
+
+#endif /* __nsNativeMenuDocListener_h__ */
diff --git a/widget/gtk/nsNativeMenuService.cpp b/widget/gtk/nsNativeMenuService.cpp
new file mode 100644
index 000000000000..ab7e7101b91b
--- /dev/null
+++ b/widget/gtk/nsNativeMenuService.cpp
@@ -0,0 +1,508 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* vim:expandtab:shiftwidth=4:tabstop=4:
+ */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/Assertions.h"
+#include "mozilla/Move.h"
+#include "mozilla/Preferences.h"
+#include "mozilla/UniquePtr.h"
+#include "nsAutoPtr.h"
+#include "nsCOMPtr.h"
+#include "nsCRT.h"
+#include "nsGtkUtils.h"
+#include "nsIContent.h"
+#include "nsIWidget.h"
+#include "nsServiceManagerUtils.h"
+#include "nsWindow.h"
+#include "prlink.h"
+
+#include "nsDbusmenu.h"
+#include "nsMenuBar.h"
+#include "nsNativeMenuAtoms.h"
+#include "nsNativeMenuDocListener.h"
+
+#include <glib-object.h>
+#include <pango/pango.h>
+#include <stdlib.h>
+
+#include "nsNativeMenuService.h"
+
+using namespace mozilla;
+
+nsNativeMenuService* nsNativeMenuService::sService = nullptr;
+
+extern PangoLayout* gPangoLayout;
+extern nsNativeMenuDocListenerTArray* gPendingListeners;
+
+static const nsTArray<nsMenuBar *>::index_type NoIndex = nsTArray<nsMenuBar *>::NoIndex;
+
+#if not GLIB_CHECK_VERSION(2,26,0)
+enum GBusType {
+    G_BUS_TYPE_STARTER = -1,
+    G_BUS_TYPE_NONE = 0,
+    G_BUS_TYPE_SYSTEM = 1,
+    G_BUS_TYPE_SESSION = 2
+};
+
+enum GDBusProxyFlags {
+    G_DBUS_PROXY_FLAGS_NONE = 0,
+    G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES = 1 << 0,
+    G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS = 1 << 1,
+    G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START = 1 << 2,
+    G_DBUS_PROXY_FLAGS_GET_INVALIDATED_PROPERTIES = 1 << 3
+};
+
+enum GDBusCallFlags {
+    G_DBUS_CALL_FLAGS_NONE = 0,
+    G_DBUS_CALL_FLAGS_NO_AUTO_START = 1 << 0
+};
+
+typedef _GDBusInterfaceInfo GDBusInterfaceInfo;
+typedef _GDBusProxy GDBusProxy;
+typedef _GVariant GVariant;
+#endif
+
+#undef g_dbus_proxy_new_for_bus
+#undef g_dbus_proxy_new_for_bus_finish
+#undef g_dbus_proxy_call
+#undef g_dbus_proxy_call_finish
+#undef g_dbus_proxy_get_name_owner
+
+typedef void (*_g_dbus_proxy_new_for_bus_fn)(GBusType, GDBusProxyFlags,
+                                             GDBusInterfaceInfo*,
+                                             const gchar*, const gchar*,
+                                             const gchar*, GCancellable*,
+                                             GAsyncReadyCallback, gpointer);
+
+typedef GDBusProxy* (*_g_dbus_proxy_new_for_bus_finish_fn)(GAsyncResult*,
+                                                           GError**);
+typedef void (*_g_dbus_proxy_call_fn)(GDBusProxy*, const gchar*, GVariant*,
+                                      GDBusCallFlags, gint, GCancellable*,
+                                      GAsyncReadyCallback, gpointer);
+typedef GVariant* (*_g_dbus_proxy_call_finish_fn)(GDBusProxy*, GAsyncResult*,
+                                                  GError**);
+typedef gchar* (*_g_dbus_proxy_get_name_owner_fn)(GDBusProxy*);
+
+static _g_dbus_proxy_new_for_bus_fn _g_dbus_proxy_new_for_bus;
+static _g_dbus_proxy_new_for_bus_finish_fn _g_dbus_proxy_new_for_bus_finish;
+static _g_dbus_proxy_call_fn _g_dbus_proxy_call;
+static _g_dbus_proxy_call_finish_fn _g_dbus_proxy_call_finish;
+static _g_dbus_proxy_get_name_owner_fn _g_dbus_proxy_get_name_owner;
+
+#define g_dbus_proxy_new_for_bus _g_dbus_proxy_new_for_bus
+#define g_dbus_proxy_new_for_bus_finish _g_dbus_proxy_new_for_bus_finish
+#define g_dbus_proxy_call _g_dbus_proxy_call
+#define g_dbus_proxy_call_finish _g_dbus_proxy_call_finish
+#define g_dbus_proxy_get_name_owner _g_dbus_proxy_get_name_owner
+
+static PRLibrary *gGIOLib = nullptr;
+
+static nsresult
+GDBusInit()
+{
+    gGIOLib = PR_LoadLibrary("libgio-2.0.so.0");
+    if (!gGIOLib) {
+        return NS_ERROR_FAILURE;
+    }
+
+    g_dbus_proxy_new_for_bus = (_g_dbus_proxy_new_for_bus_fn)PR_FindFunctionSymbol(gGIOLib, "g_dbus_proxy_new_for_bus");
+    g_dbus_proxy_new_for_bus_finish = (_g_dbus_proxy_new_for_bus_finish_fn)PR_FindFunctionSymbol(gGIOLib, "g_dbus_proxy_new_for_bus_finish");
+    g_dbus_proxy_call = (_g_dbus_proxy_call_fn)PR_FindFunctionSymbol(gGIOLib, "g_dbus_proxy_call");
+    g_dbus_proxy_call_finish = (_g_dbus_proxy_call_finish_fn)PR_FindFunctionSymbol(gGIOLib, "g_dbus_proxy_call_finish");
+    g_dbus_proxy_get_name_owner = (_g_dbus_proxy_get_name_owner_fn)PR_FindFunctionSymbol(gGIOLib, "g_dbus_proxy_get_name_owner");
+
+    if (!g_dbus_proxy_new_for_bus ||
+        !g_dbus_proxy_new_for_bus_finish ||
+        !g_dbus_proxy_call ||
+        !g_dbus_proxy_call_finish ||
+        !g_dbus_proxy_get_name_owner) {
+        return NS_ERROR_FAILURE;
+    }
+
+    return NS_OK;
+}
+
+NS_IMPL_ISUPPORTS(nsNativeMenuService, nsINativeMenuService)
+
+nsNativeMenuService::nsNativeMenuService() :
+    mCreateProxyCancellable(nullptr), mDbusProxy(nullptr), mOnline(false)
+{
+}
+
+nsNativeMenuService::~nsNativeMenuService()
+{
+    SetOnline(false);
+
+    if (mCreateProxyCancellable) {
+        g_cancellable_cancel(mCreateProxyCancellable);
+        g_object_unref(mCreateProxyCancellable);
+        mCreateProxyCancellable = nullptr;
+    }
+
+    // Make sure we disconnect map-event handlers
+    while (mMenuBars.Length() > 0) {
+        NotifyNativeMenuBarDestroyed(mMenuBars[0]);
+    }
+
+    Preferences::UnregisterCallback(PrefChangedCallback,
+                                    "ui.use_unity_menubar");
+
+    if (mDbusProxy) {
+        g_signal_handlers_disconnect_by_func(mDbusProxy,
+                                             FuncToGpointer(name_owner_changed_cb),
+                                             NULL);
+        g_object_unref(mDbusProxy);
+    }
+
+    if (gPendingListeners) {
+        delete gPendingListeners;
+        gPendingListeners = nullptr;
+    }
+    if (gPangoLayout) {
+        g_object_unref(gPangoLayout);
+        gPangoLayout = nullptr;
+    }
+
+    MOZ_ASSERT(sService == this);
+    sService = nullptr;
+}
+
+nsresult
+nsNativeMenuService::Init()
+{
+    nsresult rv = nsDbusmenuFunctions::Init();
+    if (NS_FAILED(rv)) {
+        return rv;
+    }
+
+    rv = GDBusInit();
+    if (NS_FAILED(rv)) {
+        return rv;
+    }
+
+    Preferences::RegisterCallback(PrefChangedCallback,
+                                  "ui.use_unity_menubar");
+
+    mCreateProxyCancellable = g_cancellable_new();
+
+    g_dbus_proxy_new_for_bus(G_BUS_TYPE_SESSION,
+                             static_cast<GDBusProxyFlags>(
+                                 G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES |
+                                 G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS |
+                                 G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START),
+                             nullptr,
+                             "com.canonical.AppMenu.Registrar",
+                             "/com/canonical/AppMenu/Registrar",
+                             "com.canonical.AppMenu.Registrar",
+                             mCreateProxyCancellable, proxy_created_cb,
+                             nullptr);
+
+    /* We don't technically know that the shell will draw the menubar until
+     * we know whether anybody owns the name of the menubar service on the
+     * session bus. However, discovering this happens asynchronously so
+     * we optimize for the common case here by assuming that the shell will
+     * draw window menubars if we are running inside Unity. This should
+     * mean that we avoid temporarily displaying the window menubar ourselves
+     */
+    const char *desktop = getenv("XDG_CURRENT_DESKTOP");
+    if (nsCRT::strcmp(desktop, "Unity") == 0) {
+        SetOnline(true);
+    }
+
+    return NS_OK;
+}
+
+/* static */ void
+nsNativeMenuService::EnsureInitialized()
+{
+    if (sService) {
+        return;
+    }
+    nsCOMPtr<nsINativeMenuService> service =
+        do_GetService("@mozilla.org/widget/nativemenuservice;1");
+}
+
+void
+nsNativeMenuService::SetOnline(bool aOnline)
+{
+    if (!Preferences::GetBool("ui.use_unity_menubar", true)) {
+        aOnline = false;
+    }
+
+    mOnline = aOnline;
+    if (aOnline) {
+        for (uint32_t i = 0; i < mMenuBars.Length(); ++i) {
+            RegisterNativeMenuBar(mMenuBars[i]);
+        }
+    } else {
+        for (uint32_t i = 0; i < mMenuBars.Length(); ++i) {
+            mMenuBars[i]->Deactivate();
+        }
+    }
+}
+
+void
+nsNativeMenuService::RegisterNativeMenuBar(nsMenuBar *aMenuBar)
+{
+    if (!mOnline) {
+        return;
+    }
+
+    // This will effectively create the native menubar for
+    // exporting over the session bus, and hide the XUL menubar
+    aMenuBar->Activate();
+
+    if (!mDbusProxy ||
+        !gtk_widget_get_mapped(aMenuBar->TopLevelWindow()) ||
+        mMenuBarRegistrationCancellables.Get(aMenuBar, nullptr)) {
+        // Don't go further if we don't have a proxy for the shell menu
+        // service, the window isn't mapped or there is a request in progress.
+        return;
+    }
+
+    uint32_t xid = aMenuBar->WindowId();
+    nsCString path = aMenuBar->ObjectPath();
+    if (xid == 0 || path.IsEmpty()) {
+        NS_WARNING("Menubar has invalid XID or object path");
+        return;
+    }
+
+    GCancellable *cancellable = g_cancellable_new();
+    mMenuBarRegistrationCancellables.Put(aMenuBar, cancellable);
+
+    // We keep a weak ref because we can't assume that GDBus cancellation
+    // is reliable (see https://launchpad.net/bugs/953562)
+
+    g_dbus_proxy_call(mDbusProxy, "RegisterWindow",
+                      g_variant_new("(uo)", xid, path.get()),
+                      G_DBUS_CALL_FLAGS_NONE, -1,
+                      cancellable,
+                      register_native_menubar_cb, aMenuBar);
+}
+
+/* static */ void
+nsNativeMenuService::name_owner_changed_cb(GObject *gobject,
+                                           GParamSpec *pspec,
+                                           gpointer user_data)
+{
+    nsNativeMenuService::GetSingleton()->OnNameOwnerChanged();
+}
+
+/* static */ void
+nsNativeMenuService::proxy_created_cb(GObject *source_object,
+                                      GAsyncResult *res,
+                                      gpointer user_data)
+{
+    GError *error = nullptr;
+    GDBusProxy *proxy = g_dbus_proxy_new_for_bus_finish(res, &error);
+    if (error && g_error_matches(error, G_IO_ERROR, G_IO_ERROR_CANCELLED)) {
+        g_error_free(error);
+        return;
+    }
+
+    if (error) {
+        g_error_free(error);
+    }
+
+    // We need this check because we can't assume that GDBus cancellation
+    // is reliable (see https://launchpad.net/bugs/953562)
+    nsNativeMenuService *self = nsNativeMenuService::GetSingleton();
+    if (!self) {
+        if (proxy) {
+            g_object_unref(proxy);
+        }
+        return;
+    }
+
+    self->OnProxyCreated(proxy);
+}
+
+/* static */ void
+nsNativeMenuService::register_native_menubar_cb(GObject *source_object,
+                                                GAsyncResult *res,
+                                                gpointer user_data)
+{
+    nsMenuBar *menuBar = static_cast<nsMenuBar *>(user_data);
+
+    GError *error = nullptr;
+    GVariant *results = g_dbus_proxy_call_finish(G_DBUS_PROXY(source_object),
+                                                 res, &error);
+    if (results) {
+        // There's nothing useful in the response
+        g_variant_unref(results);
+    }
+
+    bool success = error ? false : true;
+    if (error && g_error_matches(error, G_IO_ERROR, G_IO_ERROR_CANCELLED)) {
+        g_error_free(error);
+        return;
+    }
+
+    if (error) {
+        g_error_free(error);
+    }
+
+    nsNativeMenuService *self = nsNativeMenuService::GetSingleton();
+    if (!self) {
+        return;
+    }
+
+    self->OnNativeMenuBarRegistered(menuBar, success);
+}
+
+/* static */ gboolean
+nsNativeMenuService::map_event_cb(GtkWidget *widget,
+                                  GdkEvent *event,
+                                  gpointer user_data)
+{
+    nsMenuBar *menubar = static_cast<nsMenuBar *>(user_data);
+    nsNativeMenuService::GetSingleton()->RegisterNativeMenuBar(menubar);
+
+    return FALSE;
+}
+
+void
+nsNativeMenuService::OnNameOwnerChanged()
+{
+    char *owner = g_dbus_proxy_get_name_owner(mDbusProxy);
+    SetOnline(owner ? true : false);
+    g_free(owner);
+}
+
+void
+nsNativeMenuService::OnProxyCreated(GDBusProxy *aProxy)
+{
+    mDbusProxy = aProxy;
+
+    g_object_unref(mCreateProxyCancellable);
+    mCreateProxyCancellable = nullptr;
+
+    if (!mDbusProxy) {
+        SetOnline(false);
+        return;
+    }
+
+    g_signal_connect(mDbusProxy, "notify::g-name-owner",
+                     G_CALLBACK(name_owner_changed_cb), nullptr);
+
+    OnNameOwnerChanged();
+}
+
+void
+nsNativeMenuService::OnNativeMenuBarRegistered(nsMenuBar *aMenuBar,
+                                               bool aSuccess)
+{
+    // Don't assume that GDBus cancellation is reliable (ie, |aMenuBar| might
+    // have already been deleted (see https://launchpad.net/bugs/953562)
+    GCancellable *cancellable = nullptr;
+    if (!mMenuBarRegistrationCancellables.Get(aMenuBar, &cancellable)) {
+        return;
+    }
+
+    g_object_unref(cancellable);
+    mMenuBarRegistrationCancellables.Remove(aMenuBar);
+
+    if (!aSuccess) {
+        aMenuBar->Deactivate();
+    }
+}
+
+/* static */ void
+nsNativeMenuService::PrefChangedCallback(const char *aPref,
+                                         void *aClosure)
+{
+    nsNativeMenuService::GetSingleton()->PrefChanged();
+}
+
+void
+nsNativeMenuService::PrefChanged()
+{
+    if (!mDbusProxy) {
+        SetOnline(false);
+        return;
+    }
+
+    OnNameOwnerChanged();
+}
+
+NS_IMETHODIMP
+nsNativeMenuService::CreateNativeMenuBar(nsIWidget *aParent,
+                                         nsIContent *aMenuBarNode)
+{
+    NS_ENSURE_ARG(aParent);
+    NS_ENSURE_ARG(aMenuBarNode);
+
+    if (aMenuBarNode->AttrValueIs(kNameSpaceID_None,
+                                  nsNativeMenuAtoms::_moz_menubarkeeplocal,
+                                  nsGkAtoms::_true,
+                                  eCaseMatters)) {
+        return NS_OK;
+    }
+
+    UniquePtr<nsMenuBar> menubar(nsMenuBar::Create(aParent, aMenuBarNode));
+    if (!menubar) {
+        NS_WARNING("Failed to create menubar");
+        return NS_ERROR_FAILURE;
+    }
+
+    // Unity forgets our window if it is unmapped by the application, which
+    // happens with some extensions that add "minimize to tray" type
+    // functionality. We hook on to the MapNotify event to re-register our menu
+    // with Unity
+    g_signal_connect(G_OBJECT(menubar->TopLevelWindow()),
+                     "map-event", G_CALLBACK(map_event_cb),
+                     menubar.get());
+
+    mMenuBars.AppendElement(menubar.get());
+    RegisterNativeMenuBar(menubar.get());
+
+    static_cast<nsWindow *>(aParent)->SetMenuBar(Move(menubar));
+
+    return NS_OK;
+}
+
+/* static */ already_AddRefed<nsNativeMenuService>
+nsNativeMenuService::GetInstanceForServiceManager()
+{
+    RefPtr<nsNativeMenuService> service(sService);
+
+    if (service) {
+        return service.forget();
+    }
+
+    service = new nsNativeMenuService();
+
+    if (NS_FAILED(service->Init())) {
+        return nullptr;
+    }
+
+    sService = service.get();
+    return service.forget();
+}
+
+/* static */ nsNativeMenuService*
+nsNativeMenuService::GetSingleton()
+{
+    EnsureInitialized();
+    return sService;
+}
+
+void
+nsNativeMenuService::NotifyNativeMenuBarDestroyed(nsMenuBar *aMenuBar)
+{
+    g_signal_handlers_disconnect_by_func(aMenuBar->TopLevelWindow(),
+                                         FuncToGpointer(map_event_cb),
+                                         aMenuBar);
+
+    mMenuBars.RemoveElement(aMenuBar);
+
+    GCancellable *cancellable = nullptr;
+    if (mMenuBarRegistrationCancellables.Get(aMenuBar, &cancellable)) {
+        mMenuBarRegistrationCancellables.Remove(aMenuBar);
+        g_cancellable_cancel(cancellable);
+        g_object_unref(cancellable);
+    }
+}
diff --git a/widget/gtk/nsNativeMenuService.h b/widget/gtk/nsNativeMenuService.h
new file mode 100644
index 000000000000..82fcb72f8488
--- /dev/null
+++ b/widget/gtk/nsNativeMenuService.h
@@ -0,0 +1,84 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* vim:expandtab:shiftwidth=4:tabstop=4:
+ */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef __nsNativeMenuService_h__
+#define __nsNativeMenuService_h__
+
+#include "mozilla/Attributes.h"
+#include "nsCOMPtr.h"
+#include "nsDataHashtable.h"
+#include "nsINativeMenuService.h"
+#include "nsTArray.h"
+
+#include <gdk/gdk.h>
+#include <gio/gio.h>
+#include <gtk/gtk.h>
+
+class nsMenuBar;
+
+/*
+ * The main native menu service singleton. nsWebShellWindow calls in to this when
+ * a new top level window is created.
+ *
+ * Menubars are owned by their nsWindow. This service holds a weak reference to
+ * each menubar for the purpose of re-registering them with the shell if it
+ * needs to. The menubar is responsible for notifying the service when the last
+ * reference to it is dropped.
+ */
+class nsNativeMenuService final : public nsINativeMenuService
+{
+public:
+    NS_DECL_ISUPPORTS
+
+    NS_IMETHOD CreateNativeMenuBar(nsIWidget* aParent, nsIContent* aMenuBarNode) override;
+
+    // Returns the singleton addref'd for the service manager
+    static already_AddRefed<nsNativeMenuService> GetInstanceForServiceManager();
+
+    // Returns the singleton without increasing the reference count
+    static nsNativeMenuService* GetSingleton();
+
+    // Called by a menubar when it is deleted
+    void NotifyNativeMenuBarDestroyed(nsMenuBar *aMenuBar);
+
+private:
+    nsNativeMenuService();
+    ~nsNativeMenuService();
+    nsresult Init();
+
+    static void EnsureInitialized();
+    void SetOnline(bool aOnline);
+    void RegisterNativeMenuBar(nsMenuBar *aMenuBar);
+    static void name_owner_changed_cb(GObject *gobject,
+                                      GParamSpec *pspec,
+                                      gpointer user_data);
+    static void proxy_created_cb(GObject *source_object,
+                                 GAsyncResult *res,
+                                 gpointer user_data);
+    static void register_native_menubar_cb(GObject *source_object,
+                                           GAsyncResult *res,
+                                           gpointer user_data);
+    static gboolean map_event_cb(GtkWidget *widget, GdkEvent *event,
+                                 gpointer user_data);
+    void OnNameOwnerChanged();
+    void OnProxyCreated(GDBusProxy *aProxy);
+    void OnNativeMenuBarRegistered(nsMenuBar *aMenuBar,
+                                   bool aSuccess);
+    static void PrefChangedCallback(const char *aPref, void *aClosure);
+    void PrefChanged();
+
+    GCancellable *mCreateProxyCancellable;
+    GDBusProxy *mDbusProxy;
+    bool mOnline;
+    nsTArray<nsMenuBar *> mMenuBars;
+    nsDataHashtable<nsPtrHashKey<nsMenuBar>, GCancellable*> mMenuBarRegistrationCancellables;
+
+    static bool sShutdown;
+    static nsNativeMenuService *sService;
+};
+
+#endif /* __nsNativeMenuService_h__ */
diff --git a/widget/gtk/nsNativeThemeGTK.cpp b/widget/gtk/nsNativeThemeGTK.cpp
index 69a8b40e926b..fa63c892d7f0 100644
--- a/widget/gtk/nsNativeThemeGTK.cpp
+++ b/widget/gtk/nsNativeThemeGTK.cpp
@@ -51,6 +51,7 @@
 
 using namespace mozilla;
 using namespace mozilla::gfx;
+using mozilla::widget::ScreenHelperGTK;
 
 NS_IMPL_ISUPPORTS_INHERITED(nsNativeThemeGTK, nsNativeTheme, nsITheme,
                                                              nsIObserver)
diff --git a/widget/gtk/nsWidgetFactory.cpp b/widget/gtk/nsWidgetFactory.cpp
index 3c8bc02ebbb5..89888e2f3a75 100644
--- a/widget/gtk/nsWidgetFactory.cpp
+++ b/widget/gtk/nsWidgetFactory.cpp
@@ -48,6 +48,8 @@
 #include "GfxInfoX11.h"
 #endif
 
+#include "nsNativeMenuService.h"
+
 #include "nsNativeThemeGTK.h"
 
 #include "nsIComponentRegistrar.h"
@@ -123,6 +125,9 @@ NS_GENERIC_FACTORY_CONSTRUCTOR_INIT(GfxInfo, Init)
 }
 #endif
 
+NS_GENERIC_FACTORY_SINGLETON_CONSTRUCTOR(nsNativeMenuService,
+                                         nsNativeMenuService::GetInstanceForServiceManager)
+
 #ifdef NS_PRINTING
 NS_GENERIC_FACTORY_CONSTRUCTOR(nsDeviceContextSpecGTK)
 NS_GENERIC_FACTORY_CONSTRUCTOR_INIT(nsPrintOptionsGTK, Init)
@@ -225,6 +230,7 @@ NS_DEFINE_NAMED_CID(NS_IMAGE_TO_PIXBUF_CID);
 NS_DEFINE_NAMED_CID(NS_IDLE_SERVICE_CID);
 NS_DEFINE_NAMED_CID(NS_GFXINFO_CID);
 #endif
+NS_DEFINE_NAMED_CID(NS_NATIVEMENUSERVICE_CID);
 
 
 static const mozilla::Module::CIDEntry kWidgetCIDs[] = {
@@ -260,6 +266,7 @@ static const mozilla::Module::CIDEntry kWidgetCIDs[] = {
     { &kNS_IDLE_SERVICE_CID, false, nullptr, nsIdleServiceGTKConstructor },
     { &kNS_GFXINFO_CID, false, nullptr, mozilla::widget::GfxInfoConstructor },
 #endif
+    { &kNS_NATIVEMENUSERVICE_CID, true, NULL, nsNativeMenuServiceConstructor },
     { nullptr }
 };
 
@@ -297,6 +304,7 @@ static const mozilla::Module::ContractIDEntry kWidgetContracts[] = {
     { "@mozilla.org/widget/idleservice;1", &kNS_IDLE_SERVICE_CID },
     { "@mozilla.org/gfx/info;1", &kNS_GFXINFO_CID },
 #endif
+    { "@mozilla.org/widget/nativemenuservice;1", &kNS_NATIVEMENUSERVICE_CID },
     { nullptr }
 };
 
diff --git a/widget/gtk/nsWindow.cpp b/widget/gtk/nsWindow.cpp
index 11aa0769bb16..8bab873955e7 100644
--- a/widget/gtk/nsWindow.cpp
+++ b/widget/gtk/nsWindow.cpp
@@ -72,6 +72,7 @@
 
 #include "mozilla/Assertions.h"
 #include "mozilla/Likely.h"
+#include "mozilla/Move.h"
 #include "mozilla/Preferences.h"
 #include "nsIPrefService.h"
 #include "nsIGConfService.h"
@@ -5092,6 +5093,11 @@ nsWindow::HideWindowChrome(bool aShouldHide)
 #endif /* MOZ_X11 */
 }
 
+void
+nsWindow::SetMenuBar(UniquePtr<nsMenuBar> aMenuBar) {
+    mMenuBar = mozilla::Move(aMenuBar);
+}
+
 bool
 nsWindow::CheckForRollup(gdouble aMouseX, gdouble aMouseY,
                          bool aIsWheel, bool aAlwaysRollup)
diff --git a/widget/gtk/nsWindow.h b/widget/gtk/nsWindow.h
index dbdff5fefb3e..779e17a97084 100644
--- a/widget/gtk/nsWindow.h
+++ b/widget/gtk/nsWindow.h
@@ -35,6 +35,8 @@
 
 #include "IMContextWrapper.h"
 
+#include "nsMenuBar.h"
+
 #undef LOG
 #ifdef MOZ_LOGGING
 
@@ -157,6 +159,8 @@ public:
                                       nsIScreen* aTargetScreen = nullptr) override;
     virtual void       HideWindowChrome(bool aShouldHide) override;
 
+    void               SetMenuBar(mozilla::UniquePtr<nsMenuBar> aMenuBar);
+
     /**
      * GetLastUserInputTime returns a timestamp for the most recent user input
      * event.  This is intended for pointer grab requests (including drags).
@@ -561,6 +565,8 @@ private:
     RefPtr<mozilla::widget::IMContextWrapper> mIMContext;
 
     mozilla::UniquePtr<mozilla::CurrentX11TimeGetter> mCurrentTimeGetter;
+
+    mozilla::UniquePtr<nsMenuBar> mMenuBar;
 };
 
 #endif /* __nsWindow_h__ */
diff --git a/widget/moz.build b/widget/moz.build
index 4d211bfdbd5e..f05c8a27b40c 100644
--- a/widget/moz.build
+++ b/widget/moz.build
@@ -63,9 +63,9 @@ elif toolkit == 'cocoa':
         'nsISystemStatusBar.idl',
         'nsITaskbarProgress.idl',
     ]
-    EXPORTS += [
-        'nsINativeMenuService.h',
-    ]
+
+if toolkit in ('cocoa', 'gtk2', 'gtk3'):
+    EXPORTS += ['nsINativeMenuService.h']
 
 TEST_DIRS += ['tests']
 
diff --git a/xpcom/components/ManifestParser.cpp b/xpcom/components/ManifestParser.cpp
index 63d7d56523d4..e6d294b84929 100644
--- a/xpcom/components/ManifestParser.cpp
+++ b/xpcom/components/ManifestParser.cpp
@@ -38,6 +38,7 @@
 #include "nsIScriptError.h"
 #include "nsIXULAppInfo.h"
 #include "nsIXULRuntime.h"
+#include "nsKDEUtils.h"
 
 using namespace mozilla;
 
@@ -471,6 +472,7 @@ ParseManifest(NSLocationType aType, FileLocation& aFile, char* aBuf,
   NS_NAMED_LITERAL_STRING(kOs, "os");
   NS_NAMED_LITERAL_STRING(kOsVersion, "osversion");
   NS_NAMED_LITERAL_STRING(kABI, "abi");
+  NS_NAMED_LITERAL_STRING(kDesktop, "desktop");
   NS_NAMED_LITERAL_STRING(kProcess, "process");
 #if defined(MOZ_WIDGET_ANDROID)
   NS_NAMED_LITERAL_STRING(kTablet, "tablet");
@@ -531,6 +533,7 @@ ParseManifest(NSLocationType aType, FileLocation& aFile, char* aBuf,
   }
 
   nsAutoString osVersion;
+  nsAutoString desktop;
 #if defined(XP_WIN)
 #pragma warning(push)
 #pragma warning(disable:4996) // VC12+ deprecates GetVersionEx
@@ -540,6 +543,7 @@ ParseManifest(NSLocationType aType, FileLocation& aFile, char* aBuf,
                               info.dwMajorVersion,
                               info.dwMinorVersion);
   }
+  desktop = NS_LITERAL_STRING("win");
 #pragma warning(pop)
 #elif defined(MOZ_WIDGET_COCOA)
   SInt32 majorVersion = nsCocoaFeatures::OSXVersionMajor();
@@ -547,10 +551,12 @@ ParseManifest(NSLocationType aType, FileLocation& aFile, char* aBuf,
   nsTextFormatter::ssprintf(osVersion, u"%ld.%ld",
                             majorVersion,
                             minorVersion);
+  desktop = NS_LITERAL_STRING("macosx");
 #elif defined(MOZ_WIDGET_GTK)
   nsTextFormatter::ssprintf(osVersion, u"%ld.%ld",
                             gtk_major_version,
                             gtk_minor_version);
+  desktop = nsKDEUtils::kdeSession() ? NS_LITERAL_STRING("kde") : NS_LITERAL_STRING("gnome");
 #elif defined(MOZ_WIDGET_ANDROID)
   bool isTablet = false;
   if (mozilla::AndroidBridge::Bridge()) {
@@ -559,6 +565,7 @@ ParseManifest(NSLocationType aType, FileLocation& aFile, char* aBuf,
                                                            osVersion);
     isTablet = java::GeckoAppShell::IsTablet();
   }
+  desktop = NS_LITERAL_STRING("android");
 #endif
 
   if (XRE_IsContentProcess()) {
@@ -671,6 +678,7 @@ ParseManifest(NSLocationType aType, FileLocation& aFile, char* aBuf,
     TriState stTablet = eUnspecified;
 #endif
     int flags = 0;
+    TriState stDesktop = eUnspecified;
 
     while ((token = nsCRT::strtok(whitespace, kWhitespace, &whitespace)) &&
            ok) {
@@ -680,6 +688,7 @@ ParseManifest(NSLocationType aType, FileLocation& aFile, char* aBuf,
       if (CheckStringFlag(kApplication, wtoken, appID, stApp) ||
           CheckOsFlag(kOs, wtoken, osTarget, stOs) ||
           CheckStringFlag(kABI, wtoken, abi, stABI) ||
+          CheckStringFlag(kDesktop, wtoken, desktop, stDesktop) ||
           CheckStringFlag(kProcess, wtoken, process, stProcess) ||
           CheckVersionFlag(kOsVersion, wtoken, osVersion, stOsVersion) ||
           CheckVersionFlag(kAppVersion, wtoken, appVersion, stAppVersion) ||
@@ -734,6 +743,7 @@ ParseManifest(NSLocationType aType, FileLocation& aFile, char* aBuf,
         stGeckoVersion == eBad ||
         stOs == eBad ||
         stOsVersion == eBad ||
+        stDesktop == eBad ||
 #ifdef MOZ_WIDGET_ANDROID
         stTablet == eBad ||
 #endif
diff --git a/xpcom/components/moz.build b/xpcom/components/moz.build
index 3efbc8739972..ea761d31bd3f 100644
--- a/xpcom/components/moz.build
+++ b/xpcom/components/moz.build
@@ -49,6 +49,7 @@ LOCAL_INCLUDES += [
     '../reflect/xptinfo',
     '/chrome',
     '/modules/libjar',
+    '/toolkit/xre'
 ]
 
 if 'gtk' in CONFIG['MOZ_WIDGET_TOOLKIT']:
diff --git a/xpcom/io/nsLocalFileUnix.cpp b/xpcom/io/nsLocalFileUnix.cpp
index 8af0a8712588..d3583b03e273 100644
--- a/xpcom/io/nsLocalFileUnix.cpp
+++ b/xpcom/io/nsLocalFileUnix.cpp
@@ -51,6 +51,7 @@
 
 #ifdef MOZ_WIDGET_GTK
 #include "nsIGIOService.h"
+#include "nsKDEUtils.h"
 #endif
 
 #ifdef MOZ_WIDGET_COCOA
@@ -1946,18 +1947,16 @@ NS_IMETHODIMP
 nsLocalFile::Reveal()
 {
 #ifdef MOZ_WIDGET_GTK
-  nsCOMPtr<nsIGIOService> giovfs = do_GetService(NS_GIOSERVICE_CONTRACTID);
-  if (!giovfs) {
-    return NS_ERROR_FAILURE;
-  }
+  nsAutoCString url;
 
   bool isDirectory;
   if (NS_FAILED(IsDirectory(&isDirectory))) {
     return NS_ERROR_FAILURE;
   }
 
+  nsCOMPtr<nsIGIOService> giovfs = do_GetService(NS_GIOSERVICE_CONTRACTID);
   if (isDirectory) {
-    return giovfs->ShowURIForInput(mPath);
+    url = mPath;
   }
   if (NS_SUCCEEDED(giovfs->OrgFreedesktopFileManager1ShowItems(mPath))) {
     return NS_OK;
@@ -1971,7 +1970,7 @@ nsLocalFile::Reveal()
     return NS_ERROR_FAILURE;
   }
 
-  return giovfs->ShowURIForInput(dirPath);
+  url = dirPath;
 #elif defined(MOZ_WIDGET_COCOA)
   CFURLRef url;
   if (NS_SUCCEEDED(GetCFURL(&url))) {
@@ -1983,12 +1982,29 @@ nsLocalFile::Reveal()
 #else
   return NS_ERROR_FAILURE;
 #endif
+  if(nsKDEUtils::kdeSupport()) {
+    nsTArray<nsCString> command;
+    command.AppendElement( NS_LITERAL_CSTRING("REVEAL") );
+    command.AppendElement( mPath );
+    return nsKDEUtils::command( command ) ? NS_OK : NS_ERROR_FAILURE;
+  }
+
+  if (!giovfs)
+    return NS_ERROR_FAILURE;
+
+  return giovfs->ShowURIForInput(url);
 }
 
 NS_IMETHODIMP
 nsLocalFile::Launch()
 {
 #ifdef MOZ_WIDGET_GTK
+  if( nsKDEUtils::kdeSupport()) {
+    nsTArray<nsCString> command;
+    command.AppendElement( NS_LITERAL_CSTRING("OPEN") );
+    command.AppendElement( mPath );
+    return nsKDEUtils::command( command ) ? NS_OK : NS_ERROR_FAILURE;
+  }
   nsCOMPtr<nsIGIOService> giovfs = do_GetService(NS_GIOSERVICE_CONTRACTID);
   if (!giovfs) {
     return NS_ERROR_FAILURE;
diff --git a/xpfe/appshell/nsWebShellWindow.cpp b/xpfe/appshell/nsWebShellWindow.cpp
index 922a883c8ac3..add09fa06cc2 100644
--- a/xpfe/appshell/nsWebShellWindow.cpp
+++ b/xpfe/appshell/nsWebShellWindow.cpp
@@ -74,7 +74,7 @@
 
 #include "gfxPlatform.h"
 
-#ifdef XP_MACOSX
+#if defined(XP_MACOSX) || defined(MOZ_WIDGET_GTK)
 #include "nsINativeMenuService.h"
 #define USE_NATIVE_MENUS
 #endif
